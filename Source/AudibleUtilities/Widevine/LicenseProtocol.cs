// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: license_protocol.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace AudibleUtilities.Widevine; 

/// <summary>Holder for reflection information generated from license_protocol.proto</summary>
internal static partial class LicenseProtocolReflection {

#region Descriptor
/// <summary>File descriptor for license_protocol.proto</summary>
public static pbr::FileDescriptor Descriptor {
  get { return descriptor; }
}
private static pbr::FileDescriptor descriptor;

static LicenseProtocolReflection() {
  byte[] descriptorData = global::System.Convert.FromBase64String(
      string.Concat(
        "ChZsaWNlbnNlX3Byb3RvY29sLnByb3RvEhFBQVhDbGVhbi5XaWRldmluZSKz",
        "AQoVTGljZW5zZUlkZW50aWZpY2F0aW9uEhIKCnJlcXVlc3RfaWQYASABKAwS",
        "EgoKc2Vzc2lvbl9pZBgCIAEoDBITCgtwdXJjaGFzZV9pZBgDIAEoDBIsCgR0",
        "eXBlGAQgASgOMh4uQUFYQ2xlYW4uV2lkZXZpbmUuTGljZW5zZVR5cGUSDwoH",
        "dmVyc2lvbhgFIAEoBRIeChZwcm92aWRlcl9zZXNzaW9uX3Rva2VuGAYgASgM",
        "ItsXCgdMaWNlbnNlEjQKAmlkGAEgASgLMiguQUFYQ2xlYW4uV2lkZXZpbmUu",
        "TGljZW5zZUlkZW50aWZpY2F0aW9uEjEKBnBvbGljeRgCIAEoCzIhLkFBWENs",
        "ZWFuLldpZGV2aW5lLkxpY2Vuc2UuUG9saWN5EjQKA2tleRgDIAMoCzInLkFB",
        "WENsZWFuLldpZGV2aW5lLkxpY2Vuc2UuS2V5Q29udGFpbmVyEhoKEmxpY2Vu",
        "c2Vfc3RhcnRfdGltZRgEIAEoAxIqChtyZW1vdGVfYXR0ZXN0YXRpb25fdmVy",
        "aWZpZWQYBSABKAg6BWZhbHNlEh0KFXByb3ZpZGVyX2NsaWVudF90b2tlbhgG",
        "IAEoDBIZChFwcm90ZWN0aW9uX3NjaGVtZRgHIAEoDRIXCg9zcm1fcmVxdWly",
        "ZW1lbnQYCCABKAwSEgoKc3JtX3VwZGF0ZRgJIAEoDBJtChxwbGF0Zm9ybV92",
        "ZXJpZmljYXRpb25fc3RhdHVzGAogASgOMi0uQUFYQ2xlYW4uV2lkZXZpbmUu",
        "UGxhdGZvcm1WZXJpZmljYXRpb25TdGF0dXM6GFBMQVRGT1JNX05PX1ZFUklG",
        "SUNBVElPThIRCglncm91cF9pZHMYCyADKAwargQKBlBvbGljeRIXCghjYW5f",
        "cGxheRgBIAEoCDoFZmFsc2USGgoLY2FuX3BlcnNpc3QYAiABKAg6BWZhbHNl",
        "EhgKCWNhbl9yZW5ldxgDIAEoCDoFZmFsc2USIgoXcmVudGFsX2R1cmF0aW9u",
        "X3NlY29uZHMYBCABKAM6ATASJAoZcGxheWJhY2tfZHVyYXRpb25fc2Vjb25k",
        "cxgFIAEoAzoBMBIjChhsaWNlbnNlX2R1cmF0aW9uX3NlY29uZHMYBiABKAM6",
        "ATASLAohcmVuZXdhbF9yZWNvdmVyeV9kdXJhdGlvbl9zZWNvbmRzGAcgASgD",
        "OgEwEhoKEnJlbmV3YWxfc2VydmVyX3VybBgIIAEoCRIgChVyZW5ld2FsX2Rl",
        "bGF5X3NlY29uZHMYCSABKAM6ATASKQoecmVuZXdhbF9yZXRyeV9pbnRlcnZh",
        "bF9zZWNvbmRzGAogASgDOgEwEh8KEHJlbmV3X3dpdGhfdXNhZ2UYCyABKAg6",
        "BWZhbHNlEicKGGFsd2F5c19pbmNsdWRlX2NsaWVudF9pZBgMIAEoCDoFZmFs",
        "c2USKgofcGxheV9zdGFydF9ncmFjZV9wZXJpb2Rfc2Vjb25kcxgNIAEoAzoB",
        "MBItCh5zb2Z0X2VuZm9yY2VfcGxheWJhY2tfZHVyYXRpb24YDiABKAg6BWZh",
        "bHNlEioKHHNvZnRfZW5mb3JjZV9yZW50YWxfZHVyYXRpb24YDyABKAg6BHRy",
        "dWUazg8KDEtleUNvbnRhaW5lchIKCgJpZBgBIAEoDBIKCgJpdhgCIAEoDBIL",
        "CgNrZXkYAyABKAwSPQoEdHlwZRgEIAEoDjIvLkFBWENsZWFuLldpZGV2aW5l",
        "LkxpY2Vuc2UuS2V5Q29udGFpbmVyLktleVR5cGUSVgoFbGV2ZWwYBSABKA4y",
        "NS5BQVhDbGVhbi5XaWRldmluZS5MaWNlbnNlLktleUNvbnRhaW5lci5TZWN1",
        "cml0eUxldmVsOhBTV19TRUNVUkVfQ1JZUFRPElUKE3JlcXVpcmVkX3Byb3Rl",
        "Y3Rpb24YBiABKAsyOC5BQVhDbGVhbi5XaWRldmluZS5MaWNlbnNlLktleUNv",
        "bnRhaW5lci5PdXRwdXRQcm90ZWN0aW9uElYKFHJlcXVlc3RlZF9wcm90ZWN0",
        "aW9uGAcgASgLMjguQUFYQ2xlYW4uV2lkZXZpbmUuTGljZW5zZS5LZXlDb250",
        "YWluZXIuT3V0cHV0UHJvdGVjdGlvbhJHCgtrZXlfY29udHJvbBgIIAEoCzIy",
        "LkFBWENsZWFuLldpZGV2aW5lLkxpY2Vuc2UuS2V5Q29udGFpbmVyLktleUNv",
        "bnRyb2wSbwogb3BlcmF0b3Jfc2Vzc2lvbl9rZXlfcGVybWlzc2lvbnMYCSAB",
        "KAsyRS5BQVhDbGVhbi5XaWRldmluZS5MaWNlbnNlLktleUNvbnRhaW5lci5P",
        "cGVyYXRvclNlc3Npb25LZXlQZXJtaXNzaW9ucxJnChx2aWRlb19yZXNvbHV0",
        "aW9uX2NvbnN0cmFpbnRzGAogAygLMkEuQUFYQ2xlYW4uV2lkZXZpbmUuTGlj",
        "ZW5zZS5LZXlDb250YWluZXIuVmlkZW9SZXNvbHV0aW9uQ29uc3RyYWludBIo",
        "ChlhbnRpX3JvbGxiYWNrX3VzYWdlX3RhYmxlGAsgASgIOgVmYWxzZRITCgt0",
        "cmFja19sYWJlbBgMIAEoCRozCgpLZXlDb250cm9sEhkKEWtleV9jb250cm9s",
        "X2Jsb2NrGAEgASgMEgoKAml2GAIgASgMGv4EChBPdXRwdXRQcm90ZWN0aW9u",
        "ElYKBGhkY3AYASABKA4yPS5BQVhDbGVhbi5XaWRldmluZS5MaWNlbnNlLktl",
        "eUNvbnRhaW5lci5PdXRwdXRQcm90ZWN0aW9uLkhEQ1A6CUhEQ1BfTk9ORRJc",
        "CgpjZ21zX2ZsYWdzGAIgASgOMj0uQUFYQ2xlYW4uV2lkZXZpbmUuTGljZW5z",
        "ZS5LZXlDb250YWluZXIuT3V0cHV0UHJvdGVjdGlvbi5DR01TOglDR01TX05P",
        "TkUSbwoNaGRjcF9zcm1fcnVsZRgDIAEoDjJELkFBWENsZWFuLldpZGV2aW5l",
        "LkxpY2Vuc2UuS2V5Q29udGFpbmVyLk91dHB1dFByb3RlY3Rpb24uSGRjcFNy",
        "bVJ1bGU6EkhEQ1BfU1JNX1JVTEVfTk9ORRIkChVkaXNhYmxlX2FuYWxvZ19v",
        "dXRwdXQYBCABKAg6BWZhbHNlEiUKFmRpc2FibGVfZGlnaXRhbF9vdXRwdXQY",
        "BSABKAg6BWZhbHNlInkKBEhEQ1ASDQoJSERDUF9OT05FEAASCwoHSERDUF9W",
        "MRABEgsKB0hEQ1BfVjIQAhINCglIRENQX1YyXzEQAxINCglIRENQX1YyXzIQ",
        "BBINCglIRENQX1YyXzMQBRIbChZIRENQX05PX0RJR0lUQUxfT1VUUFVUEP8B",
        "IkMKBENHTVMSDQoJQ0dNU19OT05FECoSDQoJQ09QWV9GUkVFEAASDQoJQ09Q",
        "WV9PTkNFEAISDgoKQ09QWV9ORVZFUhADIjYKC0hkY3BTcm1SdWxlEhYKEkhE",
        "Q1BfU1JNX1JVTEVfTk9ORRAAEg8KC0NVUlJFTlRfU1JNEAEasAEKGVZpZGVv",
        "UmVzb2x1dGlvbkNvbnN0cmFpbnQSHQoVbWluX3Jlc29sdXRpb25fcGl4ZWxz",
        "GAEgASgNEh0KFW1heF9yZXNvbHV0aW9uX3BpeGVscxgCIAEoDRJVChNyZXF1",
        "aXJlZF9wcm90ZWN0aW9uGAMgASgLMjguQUFYQ2xlYW4uV2lkZXZpbmUuTGlj",
        "ZW5zZS5LZXlDb250YWluZXIuT3V0cHV0UHJvdGVjdGlvbhqdAQodT3BlcmF0",
        "b3JTZXNzaW9uS2V5UGVybWlzc2lvbnMSHAoNYWxsb3dfZW5jcnlwdBgBIAEo",
        "CDoFZmFsc2USHAoNYWxsb3dfZGVjcnlwdBgCIAEoCDoFZmFsc2USGQoKYWxs",
        "b3dfc2lnbhgDIAEoCDoFZmFsc2USJQoWYWxsb3dfc2lnbmF0dXJlX3Zlcmlm",
        "eRgEIAEoCDoFZmFsc2UibAoHS2V5VHlwZRILCgdTSUdOSU5HEAESCwoHQ09O",
        "VEVOVBACEg8KC0tFWV9DT05UUk9MEAMSFAoQT1BFUkFUT1JfU0VTU0lPThAE",
        "Eg8KC0VOVElUTEVNRU5UEAUSDwoLT0VNX0NPTlRFTlQQBiJ6Cg1TZWN1cml0",
        "eUxldmVsEhQKEFNXX1NFQ1VSRV9DUllQVE8QARIUChBTV19TRUNVUkVfREVD",
        "T0RFEAISFAoQSFdfU0VDVVJFX0NSWVBUTxADEhQKEEhXX1NFQ1VSRV9ERUNP",
        "REUQBBIRCg1IV19TRUNVUkVfQUxMEAUisQwKDkxpY2Vuc2VSZXF1ZXN0EjoK",
        "CWNsaWVudF9pZBgBIAEoCzInLkFBWENsZWFuLldpZGV2aW5lLkNsaWVudElk",
        "ZW50aWZpY2F0aW9uEksKCmNvbnRlbnRfaWQYAiABKAsyNy5BQVhDbGVhbi5X",
        "aWRldmluZS5MaWNlbnNlUmVxdWVzdC5Db250ZW50SWRlbnRpZmljYXRpb24S",
        "OwoEdHlwZRgDIAEoDjItLkFBWENsZWFuLldpZGV2aW5lLkxpY2Vuc2VSZXF1",
        "ZXN0LlJlcXVlc3RUeXBlEhQKDHJlcXVlc3RfdGltZRgEIAEoAxIkChxrZXlf",
        "Y29udHJvbF9ub25jZV9kZXByZWNhdGVkGAUgASgMEkkKEHByb3RvY29sX3Zl",
        "cnNpb24YBiABKA4yIi5BQVhDbGVhbi5XaWRldmluZS5Qcm90b2NvbFZlcnNp",
        "b246C1ZFUlNJT05fMl8wEhkKEWtleV9jb250cm9sX25vbmNlGAcgASgNEk0K",
        "E2VuY3J5cHRlZF9jbGllbnRfaWQYCCABKAsyMC5BQVhDbGVhbi5XaWRldmlu",
        "ZS5FbmNyeXB0ZWRDbGllbnRJZGVudGlmaWNhdGlvbhq1CAoVQ29udGVudElk",
        "ZW50aWZpY2F0aW9uEmYKEndpZGV2aW5lX3Bzc2hfZGF0YRgBIAEoCzJILkFB",
        "WENsZWFuLldpZGV2aW5lLkxpY2Vuc2VSZXF1ZXN0LkNvbnRlbnRJZGVudGlm",
        "aWNhdGlvbi5XaWRldmluZVBzc2hEYXRhSAASWAoLd2VibV9rZXlfaWQYAiAB",
        "KAsyQS5BQVhDbGVhbi5XaWRldmluZS5MaWNlbnNlUmVxdWVzdC5Db250ZW50",
        "SWRlbnRpZmljYXRpb24uV2VibUtleUlkSAASYwoQZXhpc3RpbmdfbGljZW5z",
        "ZRgDIAEoCzJHLkFBWENsZWFuLldpZGV2aW5lLkxpY2Vuc2VSZXF1ZXN0LkNv",
        "bnRlbnRJZGVudGlmaWNhdGlvbi5FeGlzdGluZ0xpY2Vuc2VIABJVCglpbml0",
        "X2RhdGEYBCABKAsyQC5BQVhDbGVhbi5XaWRldmluZS5MaWNlbnNlUmVxdWVz",
        "dC5Db250ZW50SWRlbnRpZmljYXRpb24uSW5pdERhdGFIABpvChBXaWRldmlu",
        "ZVBzc2hEYXRhEhEKCXBzc2hfZGF0YRgBIAMoDBI0CgxsaWNlbnNlX3R5cGUY",
        "AiABKA4yHi5BQVhDbGVhbi5XaWRldmluZS5MaWNlbnNlVHlwZRISCgpyZXF1",
        "ZXN0X2lkGAMgASgMGmUKCVdlYm1LZXlJZBIOCgZoZWFkZXIYASABKAwSNAoM",
        "bGljZW5zZV90eXBlGAIgASgOMh4uQUFYQ2xlYW4uV2lkZXZpbmUuTGljZW5z",
        "ZVR5cGUSEgoKcmVxdWVzdF9pZBgDIAEoDBq0AQoPRXhpc3RpbmdMaWNlbnNl",
        "EjwKCmxpY2Vuc2VfaWQYASABKAsyKC5BQVhDbGVhbi5XaWRldmluZS5MaWNl",
        "bnNlSWRlbnRpZmljYXRpb24SHQoVc2Vjb25kc19zaW5jZV9zdGFydGVkGAIg",
        "ASgDEiEKGXNlY29uZHNfc2luY2VfbGFzdF9wbGF5ZWQYAyABKAMSIQoZc2Vz",
        "c2lvbl91c2FnZV90YWJsZV9lbnRyeRgEIAEoDBr4AQoISW5pdERhdGESawoO",
        "aW5pdF9kYXRhX3R5cGUYASABKA4yTS5BQVhDbGVhbi5XaWRldmluZS5MaWNl",
        "bnNlUmVxdWVzdC5Db250ZW50SWRlbnRpZmljYXRpb24uSW5pdERhdGEuSW5p",
        "dERhdGFUeXBlOgRDRU5DEhEKCWluaXRfZGF0YRgCIAEoDBI0CgxsaWNlbnNl",
        "X3R5cGUYAyABKA4yHi5BQVhDbGVhbi5XaWRldmluZS5MaWNlbnNlVHlwZRIS",
        "CgpyZXF1ZXN0X2lkGAQgASgMIiIKDEluaXREYXRhVHlwZRIICgRDRU5DEAES",
        "CAoEV0VCTRACQhQKEmNvbnRlbnRfaWRfdmFyaWFudCIwCgtSZXF1ZXN0VHlw",
        "ZRIHCgNORVcQARILCgdSRU5FV0FMEAISCwoHUkVMRUFTRRADIt8BCgpNZXRy",
        "aWNEYXRhEhIKCnN0YWdlX25hbWUYASABKAkSPAoLbWV0cmljX2RhdGEYAiAD",
        "KAsyJy5BQVhDbGVhbi5XaWRldmluZS5NZXRyaWNEYXRhLlR5cGVWYWx1ZRpV",
        "CglUeXBlVmFsdWUSNgoEdHlwZRgBIAEoDjIoLkFBWENsZWFuLldpZGV2aW5l",
        "Lk1ldHJpY0RhdGEuTWV0cmljVHlwZRIQCgV2YWx1ZRgCIAEoAzoBMCIoCgpN",
        "ZXRyaWNUeXBlEgsKB0xBVEVOQ1kQARINCglUSU1FU1RBTVAQAiJLCgtWZXJz",
        "aW9uSW5mbxIbChNsaWNlbnNlX3Nka192ZXJzaW9uGAEgASgJEh8KF2xpY2Vu",
        "c2Vfc2VydmljZV92ZXJzaW9uGAIgASgJIs4FCg1TaWduZWRNZXNzYWdlEjoK",
        "BHR5cGUYASABKA4yLC5BQVhDbGVhbi5XaWRldmluZS5TaWduZWRNZXNzYWdl",
        "Lk1lc3NhZ2VUeXBlEgsKA21zZxgCIAEoDBIRCglzaWduYXR1cmUYAyABKAwS",
        "EwoLc2Vzc2lvbl9rZXkYBCABKAwSGgoScmVtb3RlX2F0dGVzdGF0aW9uGAUg",
        "ASgMEjIKC21ldHJpY19kYXRhGAYgAygLMh0uQUFYQ2xlYW4uV2lkZXZpbmUu",
        "TWV0cmljRGF0YRI8ChRzZXJ2aWNlX3ZlcnNpb25faW5mbxgHIAEoCzIeLkFB",
        "WENsZWFuLldpZGV2aW5lLlZlcnNpb25JbmZvEloKEHNlc3Npb25fa2V5X3R5",
        "cGUYCCABKA4yLy5BQVhDbGVhbi5XaWRldmluZS5TaWduZWRNZXNzYWdlLlNl",
        "c3Npb25LZXlUeXBlOg9XUkFQUEVEX0FFU19LRVkSHgoWb2VtY3J5cHRvX2Nv",
        "cmVfbWVzc2FnZRgJIAEoDCLsAQoLTWVzc2FnZVR5cGUSEwoPTElDRU5TRV9S",
        "RVFVRVNUEAESCwoHTElDRU5TRRACEhIKDkVSUk9SX1JFU1BPTlNFEAMSHwob",
        "U0VSVklDRV9DRVJUSUZJQ0FURV9SRVFVRVNUEAQSFwoTU0VSVklDRV9DRVJU",
        "SUZJQ0FURRAFEg8KC1NVQl9MSUNFTlNFEAYSFwoTQ0FTX0xJQ0VOU0VfUkVR",
        "VUVTVBAHEg8KC0NBU19MSUNFTlNFEAgSHAoYRVhURVJOQUxfTElDRU5TRV9S",
        "RVFVRVNUEAkSFAoQRVhURVJOQUxfTElDRU5TRRAKIlMKDlNlc3Npb25LZXlU",
        "eXBlEg0KCVVOREVGSU5FRBAAEhMKD1dSQVBQRURfQUVTX0tFWRABEh0KGUVQ",
        "SEVSTUVSQUxfRUNDX1BVQkxJQ19LRVkQAiL3DQoUQ2xpZW50SWRlbnRpZmlj",
        "YXRpb24SRwoEdHlwZRgBIAEoDjIxLkFBWENsZWFuLldpZGV2aW5lLkNsaWVu",
        "dElkZW50aWZpY2F0aW9uLlRva2VuVHlwZToGS0VZQk9YEg0KBXRva2VuGAIg",
        "ASgMEkYKC2NsaWVudF9pbmZvGAMgAygLMjEuQUFYQ2xlYW4uV2lkZXZpbmUu",
        "Q2xpZW50SWRlbnRpZmljYXRpb24uTmFtZVZhbHVlEh0KFXByb3ZpZGVyX2Ns",
        "aWVudF90b2tlbhgEIAEoDBIXCg9saWNlbnNlX2NvdW50ZXIYBSABKA0SVwoT",
        "Y2xpZW50X2NhcGFiaWxpdGllcxgGIAEoCzI6LkFBWENsZWFuLldpZGV2aW5l",
        "LkNsaWVudElkZW50aWZpY2F0aW9uLkNsaWVudENhcGFiaWxpdGllcxIQCgh2",
        "bXBfZGF0YRgHIAEoDBJVChJkZXZpY2VfY3JlZGVudGlhbHMYCCADKAsyOS5B",
        "QVhDbGVhbi5XaWRldmluZS5DbGllbnRJZGVudGlmaWNhdGlvbi5DbGllbnRD",
        "cmVkZW50aWFscxooCglOYW1lVmFsdWUSDAoEbmFtZRgBIAEoCRINCgV2YWx1",
        "ZRgCIAEoCRq4CAoSQ2xpZW50Q2FwYWJpbGl0aWVzEhsKDGNsaWVudF90b2tl",
        "bhgBIAEoCDoFZmFsc2USHAoNc2Vzc2lvbl90b2tlbhgCIAEoCDoFZmFsc2US",
        "KwocdmlkZW9fcmVzb2x1dGlvbl9jb25zdHJhaW50cxgDIAEoCDoFZmFsc2US",
        "awoQbWF4X2hkY3BfdmVyc2lvbhgEIAEoDjJGLkFBWENsZWFuLldpZGV2aW5l",
        "LkNsaWVudElkZW50aWZpY2F0aW9uLkNsaWVudENhcGFiaWxpdGllcy5IZGNw",
        "VmVyc2lvbjoJSERDUF9OT05FEh4KFm9lbV9jcnlwdG9fYXBpX3ZlcnNpb24Y",
        "BSABKA0SKAoZYW50aV9yb2xsYmFja191c2FnZV90YWJsZRgGIAEoCDoFZmFs",
        "c2USEwoLc3JtX3ZlcnNpb24YByABKA0SHQoOY2FuX3VwZGF0ZV9zcm0YCCAB",
        "KAg6BWZhbHNlEnUKHnN1cHBvcnRlZF9jZXJ0aWZpY2F0ZV9rZXlfdHlwZRgJ",
        "IAMoDjJNLkFBWENsZWFuLldpZGV2aW5lLkNsaWVudElkZW50aWZpY2F0aW9u",
        "LkNsaWVudENhcGFiaWxpdGllcy5DZXJ0aWZpY2F0ZUtleVR5cGUSjgEKGmFu",
        "YWxvZ19vdXRwdXRfY2FwYWJpbGl0aWVzGAogASgOMlMuQUFYQ2xlYW4uV2lk",
        "ZXZpbmUuQ2xpZW50SWRlbnRpZmljYXRpb24uQ2xpZW50Q2FwYWJpbGl0aWVz",
        "LkFuYWxvZ091dHB1dENhcGFiaWxpdGllczoVQU5BTE9HX09VVFBVVF9VTktO",
        "T1dOEigKGWNhbl9kaXNhYmxlX2FuYWxvZ19vdXRwdXQYCyABKAg6BWZhbHNl",
        "Eh8KFHJlc291cmNlX3JhdGluZ190aWVyGAwgASgNOgEwIoABCgtIZGNwVmVy",
        "c2lvbhINCglIRENQX05PTkUQABILCgdIRENQX1YxEAESCwoHSERDUF9WMhAC",
        "Eg0KCUhEQ1BfVjJfMRADEg0KCUhEQ1BfVjJfMhAEEg0KCUhEQ1BfVjJfMxAF",
        "EhsKFkhEQ1BfTk9fRElHSVRBTF9PVVRQVVQQ/wEiaQoSQ2VydGlmaWNhdGVL",
        "ZXlUeXBlEgwKCFJTQV8yMDQ4EAASDAoIUlNBXzMwNzIQARIRCg1FQ0NfU0VD",
        "UDI1NlIxEAISEQoNRUNDX1NFQ1AzODRSMRADEhEKDUVDQ19TRUNQNTIxUjEQ",
        "BCKNAQoYQW5hbG9nT3V0cHV0Q2FwYWJpbGl0aWVzEhkKFUFOQUxPR19PVVRQ",
        "VVRfVU5LTk9XThAAEhYKEkFOQUxPR19PVVRQVVRfTk9ORRABEhsKF0FOQUxP",
        "R19PVVRQVVRfU1VQUE9SVEVEEAISIQodQU5BTE9HX09VVFBVVF9TVVBQT1JU",
        "U19DR01TX0EQAxprChFDbGllbnRDcmVkZW50aWFscxJHCgR0eXBlGAEgASgO",
        "MjEuQUFYQ2xlYW4uV2lkZXZpbmUuQ2xpZW50SWRlbnRpZmljYXRpb24uVG9r",
        "ZW5UeXBlOgZLRVlCT1gSDQoFdG9rZW4YAiABKAwicwoJVG9rZW5UeXBlEgoK",
        "BktFWUJPWBAAEhoKFkRSTV9ERVZJQ0VfQ0VSVElGSUNBVEUQARIiCh5SRU1P",
        "VEVfQVRURVNUQVRJT05fQ0VSVElGSUNBVEUQAhIaChZPRU1fREVWSUNFX0NF",
        "UlRJRklDQVRFEAMiuwEKHUVuY3J5cHRlZENsaWVudElkZW50aWZpY2F0aW9u",
        "EhMKC3Byb3ZpZGVyX2lkGAEgASgJEikKIXNlcnZpY2VfY2VydGlmaWNhdGVf",
        "c2VyaWFsX251bWJlchgCIAEoDBIbChNlbmNyeXB0ZWRfY2xpZW50X2lkGAMg",
        "ASgMEh4KFmVuY3J5cHRlZF9jbGllbnRfaWRfaXYYBCABKAwSHQoVZW5jcnlw",
        "dGVkX3ByaXZhY3lfa2V5GAUgASgMIogHCg5Ecm1DZXJ0aWZpY2F0ZRI0CgR0",
        "eXBlGAEgASgOMiYuQUFYQ2xlYW4uV2lkZXZpbmUuRHJtQ2VydGlmaWNhdGUu",
        "VHlwZRIVCg1zZXJpYWxfbnVtYmVyGAIgASgMEh0KFWNyZWF0aW9uX3RpbWVf",
        "c2Vjb25kcxgDIAEoDRIfChdleHBpcmF0aW9uX3RpbWVfc2Vjb25kcxgMIAEo",
        "DRISCgpwdWJsaWNfa2V5GAQgASgMEhEKCXN5c3RlbV9pZBgFIAEoDRIiChZ0",
        "ZXN0X2RldmljZV9kZXByZWNhdGVkGAYgASgIQgIYARITCgtwcm92aWRlcl9p",
        "ZBgHIAEoCRJECg1zZXJ2aWNlX3R5cGVzGAggAygOMi0uQUFYQ2xlYW4uV2lk",
        "ZXZpbmUuRHJtQ2VydGlmaWNhdGUuU2VydmljZVR5cGUSQwoJYWxnb3JpdGht",
        "GAkgASgOMisuQUFYQ2xlYW4uV2lkZXZpbmUuRHJtQ2VydGlmaWNhdGUuQWxn",
        "b3JpdGhtOgNSU0ESDgoGcm90X2lkGAogASgMEkcKDmVuY3J5cHRpb25fa2V5",
        "GAsgASgLMi8uQUFYQ2xlYW4uV2lkZXZpbmUuRHJtQ2VydGlmaWNhdGUuRW5j",
        "cnlwdGlvbktleRpoCg1FbmNyeXB0aW9uS2V5EhIKCnB1YmxpY19rZXkYASAB",
        "KAwSQwoJYWxnb3JpdGhtGAIgASgOMisuQUFYQ2xlYW4uV2lkZXZpbmUuRHJt",
        "Q2VydGlmaWNhdGUuQWxnb3JpdGhtOgNSU0EiTAoEVHlwZRIICgRST09UEAAS",
        "EAoMREVWSUNFX01PREVMEAESCgoGREVWSUNFEAISCwoHU0VSVklDRRADEg8K",
        "C1BST1ZJU0lPTkVSEAQihgEKC1NlcnZpY2VUeXBlEhgKFFVOS05PV05fU0VS",
        "VklDRV9UWVBFEAASFgoSTElDRU5TRV9TRVJWRVJfU0RLEAESHAoYTElDRU5T",
        "RV9TRVJWRVJfUFJPWFlfU0RLEAISFAoQUFJPVklTSU9OSU5HX1NESxADEhEK",
        "DUNBU19QUk9YWV9TREsQBCJkCglBbGdvcml0aG0SFQoRVU5LTk9XTl9BTEdP",
        "UklUSE0QABIHCgNSU0EQARIRCg1FQ0NfU0VDUDI1NlIxEAISEQoNRUNDX1NF",
        "Q1AzODRSMRADEhEKDUVDQ19TRUNQNTIxUjEQBCK6AQoUU2lnbmVkRHJtQ2Vy",
        "dGlmaWNhdGUSFwoPZHJtX2NlcnRpZmljYXRlGAEgASgMEhEKCXNpZ25hdHVy",
        "ZRgCIAEoDBI3CgZzaWduZXIYAyABKAsyJy5BQVhDbGVhbi5XaWRldmluZS5T",
        "aWduZWREcm1DZXJ0aWZpY2F0ZRI9Cg5oYXNoX2FsZ29yaXRobRgEIAEoDjIl",
        "LkFBWENsZWFuLldpZGV2aW5lLkhhc2hBbGdvcml0aG1Qcm90byLYBQoQV2lk",
        "ZXZpbmVQc3NoRGF0YRIPCgdrZXlfaWRzGAIgAygMEhIKCmNvbnRlbnRfaWQY",
        "BCABKAwSGwoTY3J5cHRvX3BlcmlvZF9pbmRleBgHIAEoDRIZChFwcm90ZWN0",
        "aW9uX3NjaGVtZRgJIAEoDRIdChVjcnlwdG9fcGVyaW9kX3NlY29uZHMYCiAB",
        "KA0SPgoEdHlwZRgLIAEoDjIoLkFBWENsZWFuLldpZGV2aW5lLldpZGV2aW5l",
        "UHNzaERhdGEuVHlwZToGU0lOR0xFEhQKDGtleV9zZXF1ZW5jZRgMIAEoDRIR",
        "Cglncm91cF9pZHMYDSADKAwSRgoNZW50aXRsZWRfa2V5cxgOIAMoCzIvLkFB",
        "WENsZWFuLldpZGV2aW5lLldpZGV2aW5lUHNzaERhdGEuRW50aXRsZWRLZXkS",
        "FQoNdmlkZW9fZmVhdHVyZRgPIAEoCRJECglhbGdvcml0aG0YASABKA4yLS5B",
        "QVhDbGVhbi5XaWRldmluZS5XaWRldmluZVBzc2hEYXRhLkFsZ29yaXRobUIC",
        "GAESFAoIcHJvdmlkZXIYAyABKAlCAhgBEhYKCnRyYWNrX3R5cGUYBSABKAlC",
        "AhgBEhIKBnBvbGljeRgGIAEoCUICGAESGwoPZ3JvdXBlZF9saWNlbnNlGAgg",
        "ASgMQgIYARp6CgtFbnRpdGxlZEtleRIaChJlbnRpdGxlbWVudF9rZXlfaWQY",
        "ASABKAwSDgoGa2V5X2lkGAIgASgMEgsKA2tleRgDIAEoDBIKCgJpdhgEIAEo",
        "DBImChplbnRpdGxlbWVudF9rZXlfc2l6ZV9ieXRlcxgFIAEoDToCMzIiNQoE",
        "VHlwZRIKCgZTSU5HTEUQABIPCgtFTlRJVExFTUVOVBABEhAKDEVOVElUTEVE",
        "X0tFWRACIigKCUFsZ29yaXRobRIPCgtVTkVOQ1JZUFRFRBAAEgoKBkFFU0NU",
        "UhABIscBCgpGaWxlSGFzaGVzEg4KBnNpZ25lchgBIAEoDBI7CgpzaWduYXR1",
        "cmVzGAIgAygLMicuQUFYQ2xlYW4uV2lkZXZpbmUuRmlsZUhhc2hlcy5TaWdu",
        "YXR1cmUabAoJU2lnbmF0dXJlEhAKCGZpbGVuYW1lGAEgASgJEhQKDHRlc3Rf",
        "c2lnbmluZxgCIAEoCBISCgpTSEE1MTJIYXNoGAMgASgMEhAKCG1haW5fZXhl",
        "GAQgASgIEhEKCXNpZ25hdHVyZRgFIAEoDCo4CgtMaWNlbnNlVHlwZRINCglT",
        "VFJFQU1JTkcQARILCgdPRkZMSU5FEAISDQoJQVVUT01BVElDEAMq2QEKGlBs",
        "YXRmb3JtVmVyaWZpY2F0aW9uU3RhdHVzEhcKE1BMQVRGT1JNX1VOVkVSSUZJ",
        "RUQQABIVChFQTEFURk9STV9UQU1QRVJFRBABEh4KGlBMQVRGT1JNX1NPRlRX",
        "QVJFX1ZFUklGSUVEEAISHgoaUExBVEZPUk1fSEFSRFdBUkVfVkVSSUZJRUQQ",
        "AxIcChhQTEFURk9STV9OT19WRVJJRklDQVRJT04QBBItCilQTEFURk9STV9T",
        "RUNVUkVfU1RPUkFHRV9TT0ZUV0FSRV9WRVJJRklFRBAFKkQKD1Byb3RvY29s",
        "VmVyc2lvbhIPCgtWRVJTSU9OXzJfMBAUEg8KC1ZFUlNJT05fMl8xEBUSDwoL",
        "VkVSU0lPTl8yXzIQFiqGAQoSSGFzaEFsZ29yaXRobVByb3RvEh4KGkhBU0hf",
        "QUxHT1JJVEhNX1VOU1BFQ0lGSUVEEAASGAoUSEFTSF9BTEdPUklUSE1fU0hB",
        "XzEQARIaChZIQVNIX0FMR09SSVRITV9TSEFfMjU2EAISGgoWSEFTSF9BTEdP",
        "UklUSE1fU0hBXzM4NBAD"));
  descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
      new pbr::FileDescriptor[] { },
      new pbr::GeneratedClrTypeInfo(new[] {typeof(global::AudibleUtilities.Widevine.LicenseType), typeof(global::AudibleUtilities.Widevine.PlatformVerificationStatus), typeof(global::AudibleUtilities.Widevine.ProtocolVersion), typeof(global::AudibleUtilities.Widevine.HashAlgorithmProto), }, null, new pbr::GeneratedClrTypeInfo[] {
        new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.LicenseIdentification), global::AudibleUtilities.Widevine.LicenseIdentification.Parser, new[]{ "RequestId", "SessionId", "PurchaseId", "Type", "Version", "ProviderSessionToken" }, null, null, null, null),
        new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.License), global::AudibleUtilities.Widevine.License.Parser, new[]{ "Id", "Policy", "Key", "LicenseStartTime", "RemoteAttestationVerified", "ProviderClientToken", "ProtectionScheme", "SrmRequirement", "SrmUpdate", "PlatformVerificationStatus", "GroupIds" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.License.Types.Policy), global::AudibleUtilities.Widevine.License.Types.Policy.Parser, new[]{ "CanPlay", "CanPersist", "CanRenew", "RentalDurationSeconds", "PlaybackDurationSeconds", "LicenseDurationSeconds", "RenewalRecoveryDurationSeconds", "RenewalServerUrl", "RenewalDelaySeconds", "RenewalRetryIntervalSeconds", "RenewWithUsage", "AlwaysIncludeClientId", "PlayStartGracePeriodSeconds", "SoftEnforcePlaybackDuration", "SoftEnforceRentalDuration" }, null, null, null, null),
        new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.License.Types.KeyContainer), global::AudibleUtilities.Widevine.License.Types.KeyContainer.Parser, new[]{ "Id", "Iv", "Key", "Type", "Level", "RequiredProtection", "RequestedProtection", "KeyControl", "OperatorSessionKeyPermissions", "VideoResolutionConstraints", "AntiRollbackUsageTable", "TrackLabel" }, null, new[]{ typeof(global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.KeyType), typeof(global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.SecurityLevel) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.KeyControl), global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.KeyControl.Parser, new[]{ "KeyControlBlock", "Iv" }, null, null, null, null),
        new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection), global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection.Parser, new[]{ "Hdcp", "CgmsFlags", "HdcpSrmRule", "DisableAnalogOutput", "DisableDigitalOutput" }, null, new[]{ typeof(global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection.Types.HDCP), typeof(global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection.Types.CGMS), typeof(global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection.Types.HdcpSrmRule) }, null, null),
        new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.VideoResolutionConstraint), global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.VideoResolutionConstraint.Parser, new[]{ "MinResolutionPixels", "MaxResolutionPixels", "RequiredProtection" }, null, null, null, null),
        new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OperatorSessionKeyPermissions), global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OperatorSessionKeyPermissions.Parser, new[]{ "AllowEncrypt", "AllowDecrypt", "AllowSign", "AllowSignatureVerify" }, null, null, null, null)})}),
        new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.LicenseRequest), global::AudibleUtilities.Widevine.LicenseRequest.Parser, new[]{ "ClientId", "ContentId", "Type", "RequestTime", "KeyControlNonceDeprecated", "ProtocolVersion", "KeyControlNonce", "EncryptedClientId" }, null, new[]{ typeof(global::AudibleUtilities.Widevine.LicenseRequest.Types.RequestType) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification), global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Parser, new[]{ "WidevinePsshData", "WebmKeyId", "ExistingLicense", "InitData" }, new[]{ "ContentIdVariant" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.WidevinePsshData), global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.WidevinePsshData.Parser, new[]{ "PsshData", "LicenseType", "RequestId" }, null, null, null, null),
        new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.WebmKeyId), global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.WebmKeyId.Parser, new[]{ "Header", "LicenseType", "RequestId" }, null, null, null, null),
        new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.ExistingLicense), global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.ExistingLicense.Parser, new[]{ "LicenseId", "SecondsSinceStarted", "SecondsSinceLastPlayed", "SessionUsageTableEntry" }, null, null, null, null),
        new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.InitData), global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.InitData.Parser, new[]{ "InitDataType", "InitData_", "LicenseType", "RequestId" }, null, new[]{ typeof(global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.InitData.Types.InitDataType) }, null, null)})}),
        new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.MetricData), global::AudibleUtilities.Widevine.MetricData.Parser, new[]{ "StageName", "MetricData_" }, null, new[]{ typeof(global::AudibleUtilities.Widevine.MetricData.Types.MetricType) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.MetricData.Types.TypeValue), global::AudibleUtilities.Widevine.MetricData.Types.TypeValue.Parser, new[]{ "Type", "Value" }, null, null, null, null)}),
        new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.VersionInfo), global::AudibleUtilities.Widevine.VersionInfo.Parser, new[]{ "LicenseSdkVersion", "LicenseServiceVersion" }, null, null, null, null),
        new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.SignedMessage), global::AudibleUtilities.Widevine.SignedMessage.Parser, new[]{ "Type", "Msg", "Signature", "SessionKey", "RemoteAttestation", "MetricData", "ServiceVersionInfo", "SessionKeyType", "OemcryptoCoreMessage" }, null, new[]{ typeof(global::AudibleUtilities.Widevine.SignedMessage.Types.MessageType), typeof(global::AudibleUtilities.Widevine.SignedMessage.Types.SessionKeyType) }, null, null),
        new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.ClientIdentification), global::AudibleUtilities.Widevine.ClientIdentification.Parser, new[]{ "Type", "Token", "ClientInfo", "ProviderClientToken", "LicenseCounter", "ClientCapabilities", "VmpData", "DeviceCredentials" }, null, new[]{ typeof(global::AudibleUtilities.Widevine.ClientIdentification.Types.TokenType) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.ClientIdentification.Types.NameValue), global::AudibleUtilities.Widevine.ClientIdentification.Types.NameValue.Parser, new[]{ "Name", "Value" }, null, null, null, null),
        new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities), global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities.Parser, new[]{ "ClientToken", "SessionToken", "VideoResolutionConstraints", "MaxHdcpVersion", "OemCryptoApiVersion", "AntiRollbackUsageTable", "SrmVersion", "CanUpdateSrm", "SupportedCertificateKeyType", "AnalogOutputCapabilities", "CanDisableAnalogOutput", "ResourceRatingTier" }, null, new[]{ typeof(global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities.Types.HdcpVersion), typeof(global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities.Types.CertificateKeyType), typeof(global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities.Types.AnalogOutputCapabilities) }, null, null),
        new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCredentials), global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCredentials.Parser, new[]{ "Type", "Token" }, null, null, null, null)}),
        new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.EncryptedClientIdentification), global::AudibleUtilities.Widevine.EncryptedClientIdentification.Parser, new[]{ "ProviderId", "ServiceCertificateSerialNumber", "EncryptedClientId", "EncryptedClientIdIv", "EncryptedPrivacyKey" }, null, null, null, null),
        new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.DrmCertificate), global::AudibleUtilities.Widevine.DrmCertificate.Parser, new[]{ "Type", "SerialNumber", "CreationTimeSeconds", "ExpirationTimeSeconds", "PublicKey", "SystemId", "TestDeviceDeprecated", "ProviderId", "ServiceTypes", "Algorithm", "RotId", "EncryptionKey" }, null, new[]{ typeof(global::AudibleUtilities.Widevine.DrmCertificate.Types.Type), typeof(global::AudibleUtilities.Widevine.DrmCertificate.Types.ServiceType), typeof(global::AudibleUtilities.Widevine.DrmCertificate.Types.Algorithm) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.DrmCertificate.Types.EncryptionKey), global::AudibleUtilities.Widevine.DrmCertificate.Types.EncryptionKey.Parser, new[]{ "PublicKey", "Algorithm" }, null, null, null, null)}),
        new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.SignedDrmCertificate), global::AudibleUtilities.Widevine.SignedDrmCertificate.Parser, new[]{ "DrmCertificate", "Signature", "Signer", "HashAlgorithm" }, null, null, null, null),
        new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.WidevinePsshData), global::AudibleUtilities.Widevine.WidevinePsshData.Parser, new[]{ "KeyIds", "ContentId", "CryptoPeriodIndex", "ProtectionScheme", "CryptoPeriodSeconds", "Type", "KeySequence", "GroupIds", "EntitledKeys", "VideoFeature", "Algorithm", "Provider", "TrackType", "Policy", "GroupedLicense" }, null, new[]{ typeof(global::AudibleUtilities.Widevine.WidevinePsshData.Types.Type), typeof(global::AudibleUtilities.Widevine.WidevinePsshData.Types.Algorithm) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.WidevinePsshData.Types.EntitledKey), global::AudibleUtilities.Widevine.WidevinePsshData.Types.EntitledKey.Parser, new[]{ "EntitlementKeyId", "KeyId", "Key", "Iv", "EntitlementKeySizeBytes" }, null, null, null, null)}),
        new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.FileHashes), global::AudibleUtilities.Widevine.FileHashes.Parser, new[]{ "Signer", "Signatures" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::AudibleUtilities.Widevine.FileHashes.Types.Signature), global::AudibleUtilities.Widevine.FileHashes.Types.Signature.Parser, new[]{ "Filename", "TestSigning", "SHA512Hash", "MainExe", "Signature_" }, null, null, null, null)})
      }));
}
#endregion

}
#region Enums
internal enum LicenseType {
[pbr::OriginalName("STREAMING")] Streaming = 1,
[pbr::OriginalName("OFFLINE")] Offline = 2,
/// <summary>
/// License type decision is left to provider.
/// </summary>
[pbr::OriginalName("AUTOMATIC")] Automatic = 3,
}

internal enum PlatformVerificationStatus {
/// <summary>
/// The platform is not verified.
/// </summary>
[pbr::OriginalName("PLATFORM_UNVERIFIED")] PlatformUnverified = 0,
/// <summary>
/// Tampering detected on the platform.
/// </summary>
[pbr::OriginalName("PLATFORM_TAMPERED")] PlatformTampered = 1,
/// <summary>
/// The platform has been verified by means of software.
/// </summary>
[pbr::OriginalName("PLATFORM_SOFTWARE_VERIFIED")] PlatformSoftwareVerified = 2,
/// <summary>
/// The platform has been verified by means of hardware (e.g. secure boot).
/// </summary>
[pbr::OriginalName("PLATFORM_HARDWARE_VERIFIED")] PlatformHardwareVerified = 3,
/// <summary>
/// Platform verification was not performed.
/// </summary>
[pbr::OriginalName("PLATFORM_NO_VERIFICATION")] PlatformNoVerification = 4,
/// <summary>
/// Platform and secure storage capability have been verified by means of
/// software.
/// </summary>
[pbr::OriginalName("PLATFORM_SECURE_STORAGE_SOFTWARE_VERIFIED")] PlatformSecureStorageSoftwareVerified = 5,
}

internal enum ProtocolVersion {
[pbr::OriginalName("VERSION_2_0")] Version20 = 20,
[pbr::OriginalName("VERSION_2_1")] Version21 = 21,
[pbr::OriginalName("VERSION_2_2")] Version22 = 22,
}

internal enum HashAlgorithmProto {
/// <summary>
/// Unspecified hash algorithm: SHA_256 shall be used for ECC based algorithms
/// and SHA_1 shall be used otherwise.
/// </summary>
[pbr::OriginalName("HASH_ALGORITHM_UNSPECIFIED")] HashAlgorithmUnspecified = 0,
[pbr::OriginalName("HASH_ALGORITHM_SHA_1")] HashAlgorithmSha1 = 1,
[pbr::OriginalName("HASH_ALGORITHM_SHA_256")] HashAlgorithmSha256 = 2,
[pbr::OriginalName("HASH_ALGORITHM_SHA_384")] HashAlgorithmSha384 = 3,
}

#endregion

#region Messages
/// <summary>
/// LicenseIdentification is propagated from LicenseRequest to License,
/// incrementing version with each iteration.
/// </summary>
[global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
internal sealed partial class LicenseIdentification : pb::IMessage<LicenseIdentification>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  , pb::IBufferMessage
#endif
{
private static readonly pb::MessageParser<LicenseIdentification> _parser = new pb::MessageParser<LicenseIdentification>(() => new LicenseIdentification());
private pb::UnknownFieldSet _unknownFields;
private int _hasBits0;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pb::MessageParser<LicenseIdentification> Parser { get { return _parser; } }

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pbr::MessageDescriptor Descriptor {
  get { return global::AudibleUtilities.Widevine.LicenseProtocolReflection.Descriptor.MessageTypes[0]; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
pbr::MessageDescriptor pb::IMessage.Descriptor {
  get { return Descriptor; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public LicenseIdentification() {
  OnConstruction();
}

partial void OnConstruction();

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public LicenseIdentification(LicenseIdentification other) : this() {
  _hasBits0 = other._hasBits0;
  requestId_ = other.requestId_;
  sessionId_ = other.sessionId_;
  purchaseId_ = other.purchaseId_;
  type_ = other.type_;
  version_ = other.version_;
  providerSessionToken_ = other.providerSessionToken_;
  _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public LicenseIdentification Clone() {
  return new LicenseIdentification(this);
}

/// <summary>Field number for the "request_id" field.</summary>
public const int RequestIdFieldNumber = 1;
private readonly static pb::ByteString RequestIdDefaultValue = pb::ByteString.Empty;

private pb::ByteString requestId_;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString RequestId {
  get { return requestId_ ?? RequestIdDefaultValue; }
  set {
    requestId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "request_id" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasRequestId {
  get { return requestId_ != null; }
}
/// <summary>Clears the value of the "request_id" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearRequestId() {
  requestId_ = null;
}

/// <summary>Field number for the "session_id" field.</summary>
public const int SessionIdFieldNumber = 2;
private readonly static pb::ByteString SessionIdDefaultValue = pb::ByteString.Empty;

private pb::ByteString sessionId_;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString SessionId {
  get { return sessionId_ ?? SessionIdDefaultValue; }
  set {
    sessionId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "session_id" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasSessionId {
  get { return sessionId_ != null; }
}
/// <summary>Clears the value of the "session_id" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearSessionId() {
  sessionId_ = null;
}

/// <summary>Field number for the "purchase_id" field.</summary>
public const int PurchaseIdFieldNumber = 3;
private readonly static pb::ByteString PurchaseIdDefaultValue = pb::ByteString.Empty;

private pb::ByteString purchaseId_;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString PurchaseId {
  get { return purchaseId_ ?? PurchaseIdDefaultValue; }
  set {
    purchaseId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "purchase_id" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasPurchaseId {
  get { return purchaseId_ != null; }
}
/// <summary>Clears the value of the "purchase_id" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearPurchaseId() {
  purchaseId_ = null;
}

/// <summary>Field number for the "type" field.</summary>
public const int TypeFieldNumber = 4;
private readonly static global::AudibleUtilities.Widevine.LicenseType TypeDefaultValue = global::AudibleUtilities.Widevine.LicenseType.Streaming;

private global::AudibleUtilities.Widevine.LicenseType type_;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public global::AudibleUtilities.Widevine.LicenseType Type {
  get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
  set {
    _hasBits0 |= 1;
    type_ = value;
  }
}
/// <summary>Gets whether the "type" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasType {
  get { return (_hasBits0 & 1) != 0; }
}
/// <summary>Clears the value of the "type" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearType() {
  _hasBits0 &= ~1;
}

/// <summary>Field number for the "version" field.</summary>
public const int VersionFieldNumber = 5;
private readonly static int VersionDefaultValue = 0;

private int version_;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public int Version {
  get { if ((_hasBits0 & 2) != 0) { return version_; } else { return VersionDefaultValue; } }
  set {
    _hasBits0 |= 2;
    version_ = value;
  }
}
/// <summary>Gets whether the "version" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasVersion {
  get { return (_hasBits0 & 2) != 0; }
}
/// <summary>Clears the value of the "version" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearVersion() {
  _hasBits0 &= ~2;
}

/// <summary>Field number for the "provider_session_token" field.</summary>
public const int ProviderSessionTokenFieldNumber = 6;
private readonly static pb::ByteString ProviderSessionTokenDefaultValue = pb::ByteString.Empty;

private pb::ByteString providerSessionToken_;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString ProviderSessionToken {
  get { return providerSessionToken_ ?? ProviderSessionTokenDefaultValue; }
  set {
    providerSessionToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "provider_session_token" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasProviderSessionToken {
  get { return providerSessionToken_ != null; }
}
/// <summary>Clears the value of the "provider_session_token" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearProviderSessionToken() {
  providerSessionToken_ = null;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override bool Equals(object other) {
  return Equals(other as LicenseIdentification);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool Equals(LicenseIdentification other) {
  if (ReferenceEquals(other, null)) {
    return false;
  }
  if (ReferenceEquals(other, this)) {
    return true;
  }
  if (RequestId != other.RequestId) return false;
  if (SessionId != other.SessionId) return false;
  if (PurchaseId != other.PurchaseId) return false;
  if (Type != other.Type) return false;
  if (Version != other.Version) return false;
  if (ProviderSessionToken != other.ProviderSessionToken) return false;
  return Equals(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override int GetHashCode() {
  int hash = 1;
  if (HasRequestId) hash ^= RequestId.GetHashCode();
  if (HasSessionId) hash ^= SessionId.GetHashCode();
  if (HasPurchaseId) hash ^= PurchaseId.GetHashCode();
  if (HasType) hash ^= Type.GetHashCode();
  if (HasVersion) hash ^= Version.GetHashCode();
  if (HasProviderSessionToken) hash ^= ProviderSessionToken.GetHashCode();
  if (_unknownFields != null) {
    hash ^= _unknownFields.GetHashCode();
  }
  return hash;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override string ToString() {
  return pb::JsonFormatter.ToDiagnosticString(this);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void WriteTo(pb::CodedOutputStream output) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  output.WriteRawMessage(this);
#else
  if (HasRequestId) {
    output.WriteRawTag(10);
    output.WriteBytes(RequestId);
  }
  if (HasSessionId) {
    output.WriteRawTag(18);
    output.WriteBytes(SessionId);
  }
  if (HasPurchaseId) {
    output.WriteRawTag(26);
    output.WriteBytes(PurchaseId);
  }
  if (HasType) {
    output.WriteRawTag(32);
    output.WriteEnum((int) Type);
  }
  if (HasVersion) {
    output.WriteRawTag(40);
    output.WriteInt32(Version);
  }
  if (HasProviderSessionToken) {
    output.WriteRawTag(50);
    output.WriteBytes(ProviderSessionToken);
  }
  if (_unknownFields != null) {
    _unknownFields.WriteTo(output);
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
  if (HasRequestId) {
    output.WriteRawTag(10);
    output.WriteBytes(RequestId);
  }
  if (HasSessionId) {
    output.WriteRawTag(18);
    output.WriteBytes(SessionId);
  }
  if (HasPurchaseId) {
    output.WriteRawTag(26);
    output.WriteBytes(PurchaseId);
  }
  if (HasType) {
    output.WriteRawTag(32);
    output.WriteEnum((int) Type);
  }
  if (HasVersion) {
    output.WriteRawTag(40);
    output.WriteInt32(Version);
  }
  if (HasProviderSessionToken) {
    output.WriteRawTag(50);
    output.WriteBytes(ProviderSessionToken);
  }
  if (_unknownFields != null) {
    _unknownFields.WriteTo(ref output);
  }
}
#endif

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public int CalculateSize() {
  int size = 0;
  if (HasRequestId) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(RequestId);
  }
  if (HasSessionId) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(SessionId);
  }
  if (HasPurchaseId) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(PurchaseId);
  }
  if (HasType) {
    size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
  }
  if (HasVersion) {
    size += 1 + pb::CodedOutputStream.ComputeInt32Size(Version);
  }
  if (HasProviderSessionToken) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(ProviderSessionToken);
  }
  if (_unknownFields != null) {
    size += _unknownFields.CalculateSize();
  }
  return size;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(LicenseIdentification other) {
  if (other == null) {
    return;
  }
  if (other.HasRequestId) {
    RequestId = other.RequestId;
  }
  if (other.HasSessionId) {
    SessionId = other.SessionId;
  }
  if (other.HasPurchaseId) {
    PurchaseId = other.PurchaseId;
  }
  if (other.HasType) {
    Type = other.Type;
  }
  if (other.HasVersion) {
    Version = other.Version;
  }
  if (other.HasProviderSessionToken) {
    ProviderSessionToken = other.ProviderSessionToken;
  }
  _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(pb::CodedInputStream input) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  input.ReadRawMessage(this);
#else
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
        break;
      case 10: {
        RequestId = input.ReadBytes();
        break;
      }
      case 18: {
        SessionId = input.ReadBytes();
        break;
      }
      case 26: {
        PurchaseId = input.ReadBytes();
        break;
      }
      case 32: {
        Type = (global::AudibleUtilities.Widevine.LicenseType) input.ReadEnum();
        break;
      }
      case 40: {
        Version = input.ReadInt32();
        break;
      }
      case 50: {
        ProviderSessionToken = input.ReadBytes();
        break;
      }
    }
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
        break;
      case 10: {
        RequestId = input.ReadBytes();
        break;
      }
      case 18: {
        SessionId = input.ReadBytes();
        break;
      }
      case 26: {
        PurchaseId = input.ReadBytes();
        break;
      }
      case 32: {
        Type = (global::AudibleUtilities.Widevine.LicenseType) input.ReadEnum();
        break;
      }
      case 40: {
        Version = input.ReadInt32();
        break;
      }
      case 50: {
        ProviderSessionToken = input.ReadBytes();
        break;
      }
    }
  }
}
#endif

}

[global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
internal sealed partial class License : pb::IMessage<License>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  , pb::IBufferMessage
#endif
{
private static readonly pb::MessageParser<License> _parser = new pb::MessageParser<License>(() => new License());
private pb::UnknownFieldSet _unknownFields;
private int _hasBits0;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pb::MessageParser<License> Parser { get { return _parser; } }

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pbr::MessageDescriptor Descriptor {
  get { return global::AudibleUtilities.Widevine.LicenseProtocolReflection.Descriptor.MessageTypes[1]; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
pbr::MessageDescriptor pb::IMessage.Descriptor {
  get { return Descriptor; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public License() {
  OnConstruction();
}

partial void OnConstruction();

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public License(License other) : this() {
  _hasBits0 = other._hasBits0;
  id_ = other.id_ != null ? other.id_.Clone() : null;
  policy_ = other.policy_ != null ? other.policy_.Clone() : null;
  key_ = other.key_.Clone();
  licenseStartTime_ = other.licenseStartTime_;
  remoteAttestationVerified_ = other.remoteAttestationVerified_;
  providerClientToken_ = other.providerClientToken_;
  protectionScheme_ = other.protectionScheme_;
  srmRequirement_ = other.srmRequirement_;
  srmUpdate_ = other.srmUpdate_;
  platformVerificationStatus_ = other.platformVerificationStatus_;
  groupIds_ = other.groupIds_.Clone();
  _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public License Clone() {
  return new License(this);
}

/// <summary>Field number for the "id" field.</summary>
public const int IdFieldNumber = 1;
private global::AudibleUtilities.Widevine.LicenseIdentification id_;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public global::AudibleUtilities.Widevine.LicenseIdentification Id {
  get { return id_; }
  set {
    id_ = value;
  }
}

/// <summary>Field number for the "policy" field.</summary>
public const int PolicyFieldNumber = 2;
private global::AudibleUtilities.Widevine.License.Types.Policy policy_;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public global::AudibleUtilities.Widevine.License.Types.Policy Policy {
  get { return policy_; }
  set {
    policy_ = value;
  }
}

/// <summary>Field number for the "key" field.</summary>
public const int KeyFieldNumber = 3;
private static readonly pb::FieldCodec<global::AudibleUtilities.Widevine.License.Types.KeyContainer> _repeated_key_codec
    = pb::FieldCodec.ForMessage(26, global::AudibleUtilities.Widevine.License.Types.KeyContainer.Parser);
private readonly pbc::RepeatedField<global::AudibleUtilities.Widevine.License.Types.KeyContainer> key_ = new pbc::RepeatedField<global::AudibleUtilities.Widevine.License.Types.KeyContainer>();
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pbc::RepeatedField<global::AudibleUtilities.Widevine.License.Types.KeyContainer> Key {
  get { return key_; }
}

/// <summary>Field number for the "license_start_time" field.</summary>
public const int LicenseStartTimeFieldNumber = 4;
private readonly static long LicenseStartTimeDefaultValue = 0L;

private long licenseStartTime_;
/// <summary>
/// Time of the request in seconds (UTC) as set in
/// LicenseRequest.request_time.  If this time is not set in the request,
/// the local time at the license service is used in this field.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public long LicenseStartTime {
  get { if ((_hasBits0 & 1) != 0) { return licenseStartTime_; } else { return LicenseStartTimeDefaultValue; } }
  set {
    _hasBits0 |= 1;
    licenseStartTime_ = value;
  }
}
/// <summary>Gets whether the "license_start_time" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasLicenseStartTime {
  get { return (_hasBits0 & 1) != 0; }
}
/// <summary>Clears the value of the "license_start_time" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearLicenseStartTime() {
  _hasBits0 &= ~1;
}

/// <summary>Field number for the "remote_attestation_verified" field.</summary>
public const int RemoteAttestationVerifiedFieldNumber = 5;
private readonly static bool RemoteAttestationVerifiedDefaultValue = false;

private bool remoteAttestationVerified_;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool RemoteAttestationVerified {
  get { if ((_hasBits0 & 2) != 0) { return remoteAttestationVerified_; } else { return RemoteAttestationVerifiedDefaultValue; } }
  set {
    _hasBits0 |= 2;
    remoteAttestationVerified_ = value;
  }
}
/// <summary>Gets whether the "remote_attestation_verified" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasRemoteAttestationVerified {
  get { return (_hasBits0 & 2) != 0; }
}
/// <summary>Clears the value of the "remote_attestation_verified" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearRemoteAttestationVerified() {
  _hasBits0 &= ~2;
}

/// <summary>Field number for the "provider_client_token" field.</summary>
public const int ProviderClientTokenFieldNumber = 6;
private readonly static pb::ByteString ProviderClientTokenDefaultValue = pb::ByteString.Empty;

private pb::ByteString providerClientToken_;
/// <summary>
/// Client token generated by the content provider. Optional.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString ProviderClientToken {
  get { return providerClientToken_ ?? ProviderClientTokenDefaultValue; }
  set {
    providerClientToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "provider_client_token" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasProviderClientToken {
  get { return providerClientToken_ != null; }
}
/// <summary>Clears the value of the "provider_client_token" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearProviderClientToken() {
  providerClientToken_ = null;
}

/// <summary>Field number for the "protection_scheme" field.</summary>
public const int ProtectionSchemeFieldNumber = 7;
private readonly static uint ProtectionSchemeDefaultValue = 0;

private uint protectionScheme_;
/// <summary>
/// 4cc code specifying the CENC protection scheme as defined in the CENC 3.0
/// specification. Propagated from Widevine PSSH box. Optional.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public uint ProtectionScheme {
  get { if ((_hasBits0 & 4) != 0) { return protectionScheme_; } else { return ProtectionSchemeDefaultValue; } }
  set {
    _hasBits0 |= 4;
    protectionScheme_ = value;
  }
}
/// <summary>Gets whether the "protection_scheme" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasProtectionScheme {
  get { return (_hasBits0 & 4) != 0; }
}
/// <summary>Clears the value of the "protection_scheme" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearProtectionScheme() {
  _hasBits0 &= ~4;
}

/// <summary>Field number for the "srm_requirement" field.</summary>
public const int SrmRequirementFieldNumber = 8;
private readonly static pb::ByteString SrmRequirementDefaultValue = pb::ByteString.Empty;

private pb::ByteString srmRequirement_;
/// <summary>
/// 8 byte verification field "HDCPDATA" followed by unsigned 32 bit minimum
/// HDCP SRM version (whether the version is for HDCP1 SRM or HDCP2 SRM
/// depends on client max_hdcp_version).
/// Additional details can be found in Widevine Modular DRM Security
/// Integration Guide for CENC.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString SrmRequirement {
  get { return srmRequirement_ ?? SrmRequirementDefaultValue; }
  set {
    srmRequirement_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "srm_requirement" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasSrmRequirement {
  get { return srmRequirement_ != null; }
}
/// <summary>Clears the value of the "srm_requirement" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearSrmRequirement() {
  srmRequirement_ = null;
}

/// <summary>Field number for the "srm_update" field.</summary>
public const int SrmUpdateFieldNumber = 9;
private readonly static pb::ByteString SrmUpdateDefaultValue = pb::ByteString.Empty;

private pb::ByteString srmUpdate_;
/// <summary>
/// If present this contains a signed SRM file (either HDCP1 SRM or HDCP2 SRM
/// depending on client max_hdcp_version) that should be installed on the
/// client device.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString SrmUpdate {
  get { return srmUpdate_ ?? SrmUpdateDefaultValue; }
  set {
    srmUpdate_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "srm_update" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasSrmUpdate {
  get { return srmUpdate_ != null; }
}
/// <summary>Clears the value of the "srm_update" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearSrmUpdate() {
  srmUpdate_ = null;
}

/// <summary>Field number for the "platform_verification_status" field.</summary>
public const int PlatformVerificationStatusFieldNumber = 10;
private readonly static global::AudibleUtilities.Widevine.PlatformVerificationStatus PlatformVerificationStatusDefaultValue = global::AudibleUtilities.Widevine.PlatformVerificationStatus.PlatformNoVerification;

private global::AudibleUtilities.Widevine.PlatformVerificationStatus platformVerificationStatus_;
/// <summary>
/// Indicates the status of any type of platform verification performed by the
/// server.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public global::AudibleUtilities.Widevine.PlatformVerificationStatus PlatformVerificationStatus {
  get { if ((_hasBits0 & 8) != 0) { return platformVerificationStatus_; } else { return PlatformVerificationStatusDefaultValue; } }
  set {
    _hasBits0 |= 8;
    platformVerificationStatus_ = value;
  }
}
/// <summary>Gets whether the "platform_verification_status" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasPlatformVerificationStatus {
  get { return (_hasBits0 & 8) != 0; }
}
/// <summary>Clears the value of the "platform_verification_status" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearPlatformVerificationStatus() {
  _hasBits0 &= ~8;
}

/// <summary>Field number for the "group_ids" field.</summary>
public const int GroupIdsFieldNumber = 11;
private static readonly pb::FieldCodec<pb::ByteString> _repeated_groupIds_codec
    = pb::FieldCodec.ForBytes(90);
private readonly pbc::RepeatedField<pb::ByteString> groupIds_ = new pbc::RepeatedField<pb::ByteString>();
/// <summary>
/// IDs of the groups for which keys are delivered in this license, if any.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pbc::RepeatedField<pb::ByteString> GroupIds {
  get { return groupIds_; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override bool Equals(object other) {
  return Equals(other as License);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool Equals(License other) {
  if (ReferenceEquals(other, null)) {
    return false;
  }
  if (ReferenceEquals(other, this)) {
    return true;
  }
  if (!object.Equals(Id, other.Id)) return false;
  if (!object.Equals(Policy, other.Policy)) return false;
  if(!key_.Equals(other.key_)) return false;
  if (LicenseStartTime != other.LicenseStartTime) return false;
  if (RemoteAttestationVerified != other.RemoteAttestationVerified) return false;
  if (ProviderClientToken != other.ProviderClientToken) return false;
  if (ProtectionScheme != other.ProtectionScheme) return false;
  if (SrmRequirement != other.SrmRequirement) return false;
  if (SrmUpdate != other.SrmUpdate) return false;
  if (PlatformVerificationStatus != other.PlatformVerificationStatus) return false;
  if(!groupIds_.Equals(other.groupIds_)) return false;
  return Equals(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override int GetHashCode() {
  int hash = 1;
  if (id_ != null) hash ^= Id.GetHashCode();
  if (policy_ != null) hash ^= Policy.GetHashCode();
  hash ^= key_.GetHashCode();
  if (HasLicenseStartTime) hash ^= LicenseStartTime.GetHashCode();
  if (HasRemoteAttestationVerified) hash ^= RemoteAttestationVerified.GetHashCode();
  if (HasProviderClientToken) hash ^= ProviderClientToken.GetHashCode();
  if (HasProtectionScheme) hash ^= ProtectionScheme.GetHashCode();
  if (HasSrmRequirement) hash ^= SrmRequirement.GetHashCode();
  if (HasSrmUpdate) hash ^= SrmUpdate.GetHashCode();
  if (HasPlatformVerificationStatus) hash ^= PlatformVerificationStatus.GetHashCode();
  hash ^= groupIds_.GetHashCode();
  if (_unknownFields != null) {
    hash ^= _unknownFields.GetHashCode();
  }
  return hash;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override string ToString() {
  return pb::JsonFormatter.ToDiagnosticString(this);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void WriteTo(pb::CodedOutputStream output) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  output.WriteRawMessage(this);
#else
  if (id_ != null) {
    output.WriteRawTag(10);
    output.WriteMessage(Id);
  }
  if (policy_ != null) {
    output.WriteRawTag(18);
    output.WriteMessage(Policy);
  }
  key_.WriteTo(output, _repeated_key_codec);
  if (HasLicenseStartTime) {
    output.WriteRawTag(32);
    output.WriteInt64(LicenseStartTime);
  }
  if (HasRemoteAttestationVerified) {
    output.WriteRawTag(40);
    output.WriteBool(RemoteAttestationVerified);
  }
  if (HasProviderClientToken) {
    output.WriteRawTag(50);
    output.WriteBytes(ProviderClientToken);
  }
  if (HasProtectionScheme) {
    output.WriteRawTag(56);
    output.WriteUInt32(ProtectionScheme);
  }
  if (HasSrmRequirement) {
    output.WriteRawTag(66);
    output.WriteBytes(SrmRequirement);
  }
  if (HasSrmUpdate) {
    output.WriteRawTag(74);
    output.WriteBytes(SrmUpdate);
  }
  if (HasPlatformVerificationStatus) {
    output.WriteRawTag(80);
    output.WriteEnum((int) PlatformVerificationStatus);
  }
  groupIds_.WriteTo(output, _repeated_groupIds_codec);
  if (_unknownFields != null) {
    _unknownFields.WriteTo(output);
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
  if (id_ != null) {
    output.WriteRawTag(10);
    output.WriteMessage(Id);
  }
  if (policy_ != null) {
    output.WriteRawTag(18);
    output.WriteMessage(Policy);
  }
  key_.WriteTo(ref output, _repeated_key_codec);
  if (HasLicenseStartTime) {
    output.WriteRawTag(32);
    output.WriteInt64(LicenseStartTime);
  }
  if (HasRemoteAttestationVerified) {
    output.WriteRawTag(40);
    output.WriteBool(RemoteAttestationVerified);
  }
  if (HasProviderClientToken) {
    output.WriteRawTag(50);
    output.WriteBytes(ProviderClientToken);
  }
  if (HasProtectionScheme) {
    output.WriteRawTag(56);
    output.WriteUInt32(ProtectionScheme);
  }
  if (HasSrmRequirement) {
    output.WriteRawTag(66);
    output.WriteBytes(SrmRequirement);
  }
  if (HasSrmUpdate) {
    output.WriteRawTag(74);
    output.WriteBytes(SrmUpdate);
  }
  if (HasPlatformVerificationStatus) {
    output.WriteRawTag(80);
    output.WriteEnum((int) PlatformVerificationStatus);
  }
  groupIds_.WriteTo(ref output, _repeated_groupIds_codec);
  if (_unknownFields != null) {
    _unknownFields.WriteTo(ref output);
  }
}
#endif

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public int CalculateSize() {
  int size = 0;
  if (id_ != null) {
    size += 1 + pb::CodedOutputStream.ComputeMessageSize(Id);
  }
  if (policy_ != null) {
    size += 1 + pb::CodedOutputStream.ComputeMessageSize(Policy);
  }
  size += key_.CalculateSize(_repeated_key_codec);
  if (HasLicenseStartTime) {
    size += 1 + pb::CodedOutputStream.ComputeInt64Size(LicenseStartTime);
  }
  if (HasRemoteAttestationVerified) {
    size += 1 + 1;
  }
  if (HasProviderClientToken) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(ProviderClientToken);
  }
  if (HasProtectionScheme) {
    size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ProtectionScheme);
  }
  if (HasSrmRequirement) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(SrmRequirement);
  }
  if (HasSrmUpdate) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(SrmUpdate);
  }
  if (HasPlatformVerificationStatus) {
    size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PlatformVerificationStatus);
  }
  size += groupIds_.CalculateSize(_repeated_groupIds_codec);
  if (_unknownFields != null) {
    size += _unknownFields.CalculateSize();
  }
  return size;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(License other) {
  if (other == null) {
    return;
  }
  if (other.id_ != null) {
    if (id_ == null) {
      Id = new global::AudibleUtilities.Widevine.LicenseIdentification();
    }
    Id.MergeFrom(other.Id);
  }
  if (other.policy_ != null) {
    if (policy_ == null) {
      Policy = new global::AudibleUtilities.Widevine.License.Types.Policy();
    }
    Policy.MergeFrom(other.Policy);
  }
  key_.Add(other.key_);
  if (other.HasLicenseStartTime) {
    LicenseStartTime = other.LicenseStartTime;
  }
  if (other.HasRemoteAttestationVerified) {
    RemoteAttestationVerified = other.RemoteAttestationVerified;
  }
  if (other.HasProviderClientToken) {
    ProviderClientToken = other.ProviderClientToken;
  }
  if (other.HasProtectionScheme) {
    ProtectionScheme = other.ProtectionScheme;
  }
  if (other.HasSrmRequirement) {
    SrmRequirement = other.SrmRequirement;
  }
  if (other.HasSrmUpdate) {
    SrmUpdate = other.SrmUpdate;
  }
  if (other.HasPlatformVerificationStatus) {
    PlatformVerificationStatus = other.PlatformVerificationStatus;
  }
  groupIds_.Add(other.groupIds_);
  _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(pb::CodedInputStream input) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  input.ReadRawMessage(this);
#else
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
        break;
      case 10: {
        if (id_ == null) {
          Id = new global::AudibleUtilities.Widevine.LicenseIdentification();
        }
        input.ReadMessage(Id);
        break;
      }
      case 18: {
        if (policy_ == null) {
          Policy = new global::AudibleUtilities.Widevine.License.Types.Policy();
        }
        input.ReadMessage(Policy);
        break;
      }
      case 26: {
        key_.AddEntriesFrom(input, _repeated_key_codec);
        break;
      }
      case 32: {
        LicenseStartTime = input.ReadInt64();
        break;
      }
      case 40: {
        RemoteAttestationVerified = input.ReadBool();
        break;
      }
      case 50: {
        ProviderClientToken = input.ReadBytes();
        break;
      }
      case 56: {
        ProtectionScheme = input.ReadUInt32();
        break;
      }
      case 66: {
        SrmRequirement = input.ReadBytes();
        break;
      }
      case 74: {
        SrmUpdate = input.ReadBytes();
        break;
      }
      case 80: {
        PlatformVerificationStatus = (global::AudibleUtilities.Widevine.PlatformVerificationStatus) input.ReadEnum();
        break;
      }
      case 90: {
        groupIds_.AddEntriesFrom(input, _repeated_groupIds_codec);
        break;
      }
    }
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
        break;
      case 10: {
        if (id_ == null) {
          Id = new global::AudibleUtilities.Widevine.LicenseIdentification();
        }
        input.ReadMessage(Id);
        break;
      }
      case 18: {
        if (policy_ == null) {
          Policy = new global::AudibleUtilities.Widevine.License.Types.Policy();
        }
        input.ReadMessage(Policy);
        break;
      }
      case 26: {
        key_.AddEntriesFrom(ref input, _repeated_key_codec);
        break;
      }
      case 32: {
        LicenseStartTime = input.ReadInt64();
        break;
      }
      case 40: {
        RemoteAttestationVerified = input.ReadBool();
        break;
      }
      case 50: {
        ProviderClientToken = input.ReadBytes();
        break;
      }
      case 56: {
        ProtectionScheme = input.ReadUInt32();
        break;
      }
      case 66: {
        SrmRequirement = input.ReadBytes();
        break;
      }
      case 74: {
        SrmUpdate = input.ReadBytes();
        break;
      }
      case 80: {
        PlatformVerificationStatus = (global::AudibleUtilities.Widevine.PlatformVerificationStatus) input.ReadEnum();
        break;
      }
      case 90: {
        groupIds_.AddEntriesFrom(ref input, _repeated_groupIds_codec);
        break;
      }
    }
  }
}
#endif

#region Nested types
/// <summary>Container for nested types declared in the License message type.</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static partial class Types {
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  internal sealed partial class Policy : pb::IMessage<Policy>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Policy> _parser = new pb::MessageParser<Policy>(() => new Policy());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Policy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AudibleUtilities.Widevine.License.Descriptor.NestedTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Policy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Policy(Policy other) : this() {
      _hasBits0 = other._hasBits0;
      canPlay_ = other.canPlay_;
      canPersist_ = other.canPersist_;
      canRenew_ = other.canRenew_;
      rentalDurationSeconds_ = other.rentalDurationSeconds_;
      playbackDurationSeconds_ = other.playbackDurationSeconds_;
      licenseDurationSeconds_ = other.licenseDurationSeconds_;
      renewalRecoveryDurationSeconds_ = other.renewalRecoveryDurationSeconds_;
      renewalServerUrl_ = other.renewalServerUrl_;
      renewalDelaySeconds_ = other.renewalDelaySeconds_;
      renewalRetryIntervalSeconds_ = other.renewalRetryIntervalSeconds_;
      renewWithUsage_ = other.renewWithUsage_;
      alwaysIncludeClientId_ = other.alwaysIncludeClientId_;
      playStartGracePeriodSeconds_ = other.playStartGracePeriodSeconds_;
      softEnforcePlaybackDuration_ = other.softEnforcePlaybackDuration_;
      softEnforceRentalDuration_ = other.softEnforceRentalDuration_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Policy Clone() {
      return new Policy(this);
    }

    /// <summary>Field number for the "can_play" field.</summary>
    public const int CanPlayFieldNumber = 1;
    private readonly static bool CanPlayDefaultValue = false;

    private bool canPlay_;
    /// <summary>
    /// Indicates that playback of the content is allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool CanPlay {
      get { if ((_hasBits0 & 1) != 0) { return canPlay_; } else { return CanPlayDefaultValue; } }
      set {
        _hasBits0 |= 1;
        canPlay_ = value;
      }
    }
    /// <summary>Gets whether the "can_play" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCanPlay {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "can_play" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCanPlay() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "can_persist" field.</summary>
    public const int CanPersistFieldNumber = 2;
    private readonly static bool CanPersistDefaultValue = false;

    private bool canPersist_;
    /// <summary>
    /// Indicates that the license may be persisted to non-volatile
    /// storage for offline use.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool CanPersist {
      get { if ((_hasBits0 & 2) != 0) { return canPersist_; } else { return CanPersistDefaultValue; } }
      set {
        _hasBits0 |= 2;
        canPersist_ = value;
      }
    }
    /// <summary>Gets whether the "can_persist" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCanPersist {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "can_persist" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCanPersist() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "can_renew" field.</summary>
    public const int CanRenewFieldNumber = 3;
    private readonly static bool CanRenewDefaultValue = false;

    private bool canRenew_;
    /// <summary>
    /// Indicates that renewal of this license is allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool CanRenew {
      get { if ((_hasBits0 & 4) != 0) { return canRenew_; } else { return CanRenewDefaultValue; } }
      set {
        _hasBits0 |= 4;
        canRenew_ = value;
      }
    }
    /// <summary>Gets whether the "can_renew" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCanRenew {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "can_renew" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCanRenew() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "rental_duration_seconds" field.</summary>
    public const int RentalDurationSecondsFieldNumber = 4;
    private readonly static long RentalDurationSecondsDefaultValue = 0L;

    private long rentalDurationSeconds_;
    /// <summary>
    /// Indicates the rental window.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long RentalDurationSeconds {
      get { if ((_hasBits0 & 8) != 0) { return rentalDurationSeconds_; } else { return RentalDurationSecondsDefaultValue; } }
      set {
        _hasBits0 |= 8;
        rentalDurationSeconds_ = value;
      }
    }
    /// <summary>Gets whether the "rental_duration_seconds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRentalDurationSeconds {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "rental_duration_seconds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRentalDurationSeconds() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "playback_duration_seconds" field.</summary>
    public const int PlaybackDurationSecondsFieldNumber = 5;
    private readonly static long PlaybackDurationSecondsDefaultValue = 0L;

    private long playbackDurationSeconds_;
    /// <summary>
    /// Indicates the viewing window, once playback has begun.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long PlaybackDurationSeconds {
      get { if ((_hasBits0 & 16) != 0) { return playbackDurationSeconds_; } else { return PlaybackDurationSecondsDefaultValue; } }
      set {
        _hasBits0 |= 16;
        playbackDurationSeconds_ = value;
      }
    }
    /// <summary>Gets whether the "playback_duration_seconds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPlaybackDurationSeconds {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "playback_duration_seconds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPlaybackDurationSeconds() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "license_duration_seconds" field.</summary>
    public const int LicenseDurationSecondsFieldNumber = 6;
    private readonly static long LicenseDurationSecondsDefaultValue = 0L;

    private long licenseDurationSeconds_;
    /// <summary>
    /// Indicates the time window for this specific license.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long LicenseDurationSeconds {
      get { if ((_hasBits0 & 32) != 0) { return licenseDurationSeconds_; } else { return LicenseDurationSecondsDefaultValue; } }
      set {
        _hasBits0 |= 32;
        licenseDurationSeconds_ = value;
      }
    }
    /// <summary>Gets whether the "license_duration_seconds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLicenseDurationSeconds {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "license_duration_seconds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLicenseDurationSeconds() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "renewal_recovery_duration_seconds" field.</summary>
    public const int RenewalRecoveryDurationSecondsFieldNumber = 7;
    private readonly static long RenewalRecoveryDurationSecondsDefaultValue = 0L;

    private long renewalRecoveryDurationSeconds_;
    /// <summary>
    /// The window of time, in which playback is allowed to continue while
    /// renewal is attempted, yet unsuccessful due to backend problems with
    /// the license server.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long RenewalRecoveryDurationSeconds {
      get { if ((_hasBits0 & 64) != 0) { return renewalRecoveryDurationSeconds_; } else { return RenewalRecoveryDurationSecondsDefaultValue; } }
      set {
        _hasBits0 |= 64;
        renewalRecoveryDurationSeconds_ = value;
      }
    }
    /// <summary>Gets whether the "renewal_recovery_duration_seconds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRenewalRecoveryDurationSeconds {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "renewal_recovery_duration_seconds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRenewalRecoveryDurationSeconds() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "renewal_server_url" field.</summary>
    public const int RenewalServerUrlFieldNumber = 8;
    private readonly static string RenewalServerUrlDefaultValue = "";

    private string renewalServerUrl_;
    /// <summary>
    /// All renewal requests for this license shall be directed to the
    /// specified URL.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RenewalServerUrl {
      get { return renewalServerUrl_ ?? RenewalServerUrlDefaultValue; }
      set {
        renewalServerUrl_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "renewal_server_url" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRenewalServerUrl {
      get { return renewalServerUrl_ != null; }
    }
    /// <summary>Clears the value of the "renewal_server_url" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRenewalServerUrl() {
      renewalServerUrl_ = null;
    }

    /// <summary>Field number for the "renewal_delay_seconds" field.</summary>
    public const int RenewalDelaySecondsFieldNumber = 9;
    private readonly static long RenewalDelaySecondsDefaultValue = 0L;

    private long renewalDelaySeconds_;
    /// <summary>
    /// How many seconds after license_start_time, before renewal is first
    /// attempted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long RenewalDelaySeconds {
      get { if ((_hasBits0 & 128) != 0) { return renewalDelaySeconds_; } else { return RenewalDelaySecondsDefaultValue; } }
      set {
        _hasBits0 |= 128;
        renewalDelaySeconds_ = value;
      }
    }
    /// <summary>Gets whether the "renewal_delay_seconds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRenewalDelaySeconds {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "renewal_delay_seconds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRenewalDelaySeconds() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "renewal_retry_interval_seconds" field.</summary>
    public const int RenewalRetryIntervalSecondsFieldNumber = 10;
    private readonly static long RenewalRetryIntervalSecondsDefaultValue = 0L;

    private long renewalRetryIntervalSeconds_;
    /// <summary>
    /// Specifies the delay in seconds between subsequent license
    /// renewal requests, in case of failure.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long RenewalRetryIntervalSeconds {
      get { if ((_hasBits0 & 256) != 0) { return renewalRetryIntervalSeconds_; } else { return RenewalRetryIntervalSecondsDefaultValue; } }
      set {
        _hasBits0 |= 256;
        renewalRetryIntervalSeconds_ = value;
      }
    }
    /// <summary>Gets whether the "renewal_retry_interval_seconds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRenewalRetryIntervalSeconds {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "renewal_retry_interval_seconds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRenewalRetryIntervalSeconds() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "renew_with_usage" field.</summary>
    public const int RenewWithUsageFieldNumber = 11;
    private readonly static bool RenewWithUsageDefaultValue = false;

    private bool renewWithUsage_;
    /// <summary>
    /// Indicates that the license shall be sent for renewal when usage is
    /// started.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool RenewWithUsage {
      get { if ((_hasBits0 & 512) != 0) { return renewWithUsage_; } else { return RenewWithUsageDefaultValue; } }
      set {
        _hasBits0 |= 512;
        renewWithUsage_ = value;
      }
    }
    /// <summary>Gets whether the "renew_with_usage" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRenewWithUsage {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "renew_with_usage" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRenewWithUsage() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "always_include_client_id" field.</summary>
    public const int AlwaysIncludeClientIdFieldNumber = 12;
    private readonly static bool AlwaysIncludeClientIdDefaultValue = false;

    private bool alwaysIncludeClientId_;
    /// <summary>
    /// Indicates to client that license renewal and release requests ought to
    /// include ClientIdentification (client_id).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AlwaysIncludeClientId {
      get { if ((_hasBits0 & 1024) != 0) { return alwaysIncludeClientId_; } else { return AlwaysIncludeClientIdDefaultValue; } }
      set {
        _hasBits0 |= 1024;
        alwaysIncludeClientId_ = value;
      }
    }
    /// <summary>Gets whether the "always_include_client_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAlwaysIncludeClientId {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "always_include_client_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAlwaysIncludeClientId() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "play_start_grace_period_seconds" field.</summary>
    public const int PlayStartGracePeriodSecondsFieldNumber = 13;
    private readonly static long PlayStartGracePeriodSecondsDefaultValue = 0L;

    private long playStartGracePeriodSeconds_;
    /// <summary>
    /// Duration of grace period before playback_duration_seconds (short window)
    /// goes into effect. Optional.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long PlayStartGracePeriodSeconds {
      get { if ((_hasBits0 & 2048) != 0) { return playStartGracePeriodSeconds_; } else { return PlayStartGracePeriodSecondsDefaultValue; } }
      set {
        _hasBits0 |= 2048;
        playStartGracePeriodSeconds_ = value;
      }
    }
    /// <summary>Gets whether the "play_start_grace_period_seconds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPlayStartGracePeriodSeconds {
      get { return (_hasBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "play_start_grace_period_seconds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPlayStartGracePeriodSeconds() {
      _hasBits0 &= ~2048;
    }

    /// <summary>Field number for the "soft_enforce_playback_duration" field.</summary>
    public const int SoftEnforcePlaybackDurationFieldNumber = 14;
    private readonly static bool SoftEnforcePlaybackDurationDefaultValue = false;

    private bool softEnforcePlaybackDuration_;
    /// <summary>
    /// Enables "soft enforcement" of playback_duration_seconds, letting the user
    /// finish playback even if short window expires. Optional.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SoftEnforcePlaybackDuration {
      get { if ((_hasBits0 & 4096) != 0) { return softEnforcePlaybackDuration_; } else { return SoftEnforcePlaybackDurationDefaultValue; } }
      set {
        _hasBits0 |= 4096;
        softEnforcePlaybackDuration_ = value;
      }
    }
    /// <summary>Gets whether the "soft_enforce_playback_duration" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSoftEnforcePlaybackDuration {
      get { return (_hasBits0 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "soft_enforce_playback_duration" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSoftEnforcePlaybackDuration() {
      _hasBits0 &= ~4096;
    }

    /// <summary>Field number for the "soft_enforce_rental_duration" field.</summary>
    public const int SoftEnforceRentalDurationFieldNumber = 15;
    private readonly static bool SoftEnforceRentalDurationDefaultValue = true;

    private bool softEnforceRentalDuration_;
    /// <summary>
    /// Enables "soft enforcement" of rental_duration_seconds. Initial playback
    /// must always start before rental duration expires.  In order to allow
    /// subsequent playbacks to start after the rental duration expires,
    /// soft_enforce_playback_duration must be true. Otherwise, subsequent
    /// playbacks will not be allowed once rental duration expires. Optional.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SoftEnforceRentalDuration {
      get { if ((_hasBits0 & 8192) != 0) { return softEnforceRentalDuration_; } else { return SoftEnforceRentalDurationDefaultValue; } }
      set {
        _hasBits0 |= 8192;
        softEnforceRentalDuration_ = value;
      }
    }
    /// <summary>Gets whether the "soft_enforce_rental_duration" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSoftEnforceRentalDuration {
      get { return (_hasBits0 & 8192) != 0; }
    }
    /// <summary>Clears the value of the "soft_enforce_rental_duration" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSoftEnforceRentalDuration() {
      _hasBits0 &= ~8192;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Policy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Policy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CanPlay != other.CanPlay) return false;
      if (CanPersist != other.CanPersist) return false;
      if (CanRenew != other.CanRenew) return false;
      if (RentalDurationSeconds != other.RentalDurationSeconds) return false;
      if (PlaybackDurationSeconds != other.PlaybackDurationSeconds) return false;
      if (LicenseDurationSeconds != other.LicenseDurationSeconds) return false;
      if (RenewalRecoveryDurationSeconds != other.RenewalRecoveryDurationSeconds) return false;
      if (RenewalServerUrl != other.RenewalServerUrl) return false;
      if (RenewalDelaySeconds != other.RenewalDelaySeconds) return false;
      if (RenewalRetryIntervalSeconds != other.RenewalRetryIntervalSeconds) return false;
      if (RenewWithUsage != other.RenewWithUsage) return false;
      if (AlwaysIncludeClientId != other.AlwaysIncludeClientId) return false;
      if (PlayStartGracePeriodSeconds != other.PlayStartGracePeriodSeconds) return false;
      if (SoftEnforcePlaybackDuration != other.SoftEnforcePlaybackDuration) return false;
      if (SoftEnforceRentalDuration != other.SoftEnforceRentalDuration) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasCanPlay) hash ^= CanPlay.GetHashCode();
      if (HasCanPersist) hash ^= CanPersist.GetHashCode();
      if (HasCanRenew) hash ^= CanRenew.GetHashCode();
      if (HasRentalDurationSeconds) hash ^= RentalDurationSeconds.GetHashCode();
      if (HasPlaybackDurationSeconds) hash ^= PlaybackDurationSeconds.GetHashCode();
      if (HasLicenseDurationSeconds) hash ^= LicenseDurationSeconds.GetHashCode();
      if (HasRenewalRecoveryDurationSeconds) hash ^= RenewalRecoveryDurationSeconds.GetHashCode();
      if (HasRenewalServerUrl) hash ^= RenewalServerUrl.GetHashCode();
      if (HasRenewalDelaySeconds) hash ^= RenewalDelaySeconds.GetHashCode();
      if (HasRenewalRetryIntervalSeconds) hash ^= RenewalRetryIntervalSeconds.GetHashCode();
      if (HasRenewWithUsage) hash ^= RenewWithUsage.GetHashCode();
      if (HasAlwaysIncludeClientId) hash ^= AlwaysIncludeClientId.GetHashCode();
      if (HasPlayStartGracePeriodSeconds) hash ^= PlayStartGracePeriodSeconds.GetHashCode();
      if (HasSoftEnforcePlaybackDuration) hash ^= SoftEnforcePlaybackDuration.GetHashCode();
      if (HasSoftEnforceRentalDuration) hash ^= SoftEnforceRentalDuration.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasCanPlay) {
        output.WriteRawTag(8);
        output.WriteBool(CanPlay);
      }
      if (HasCanPersist) {
        output.WriteRawTag(16);
        output.WriteBool(CanPersist);
      }
      if (HasCanRenew) {
        output.WriteRawTag(24);
        output.WriteBool(CanRenew);
      }
      if (HasRentalDurationSeconds) {
        output.WriteRawTag(32);
        output.WriteInt64(RentalDurationSeconds);
      }
      if (HasPlaybackDurationSeconds) {
        output.WriteRawTag(40);
        output.WriteInt64(PlaybackDurationSeconds);
      }
      if (HasLicenseDurationSeconds) {
        output.WriteRawTag(48);
        output.WriteInt64(LicenseDurationSeconds);
      }
      if (HasRenewalRecoveryDurationSeconds) {
        output.WriteRawTag(56);
        output.WriteInt64(RenewalRecoveryDurationSeconds);
      }
      if (HasRenewalServerUrl) {
        output.WriteRawTag(66);
        output.WriteString(RenewalServerUrl);
      }
      if (HasRenewalDelaySeconds) {
        output.WriteRawTag(72);
        output.WriteInt64(RenewalDelaySeconds);
      }
      if (HasRenewalRetryIntervalSeconds) {
        output.WriteRawTag(80);
        output.WriteInt64(RenewalRetryIntervalSeconds);
      }
      if (HasRenewWithUsage) {
        output.WriteRawTag(88);
        output.WriteBool(RenewWithUsage);
      }
      if (HasAlwaysIncludeClientId) {
        output.WriteRawTag(96);
        output.WriteBool(AlwaysIncludeClientId);
      }
      if (HasPlayStartGracePeriodSeconds) {
        output.WriteRawTag(104);
        output.WriteInt64(PlayStartGracePeriodSeconds);
      }
      if (HasSoftEnforcePlaybackDuration) {
        output.WriteRawTag(112);
        output.WriteBool(SoftEnforcePlaybackDuration);
      }
      if (HasSoftEnforceRentalDuration) {
        output.WriteRawTag(120);
        output.WriteBool(SoftEnforceRentalDuration);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasCanPlay) {
        output.WriteRawTag(8);
        output.WriteBool(CanPlay);
      }
      if (HasCanPersist) {
        output.WriteRawTag(16);
        output.WriteBool(CanPersist);
      }
      if (HasCanRenew) {
        output.WriteRawTag(24);
        output.WriteBool(CanRenew);
      }
      if (HasRentalDurationSeconds) {
        output.WriteRawTag(32);
        output.WriteInt64(RentalDurationSeconds);
      }
      if (HasPlaybackDurationSeconds) {
        output.WriteRawTag(40);
        output.WriteInt64(PlaybackDurationSeconds);
      }
      if (HasLicenseDurationSeconds) {
        output.WriteRawTag(48);
        output.WriteInt64(LicenseDurationSeconds);
      }
      if (HasRenewalRecoveryDurationSeconds) {
        output.WriteRawTag(56);
        output.WriteInt64(RenewalRecoveryDurationSeconds);
      }
      if (HasRenewalServerUrl) {
        output.WriteRawTag(66);
        output.WriteString(RenewalServerUrl);
      }
      if (HasRenewalDelaySeconds) {
        output.WriteRawTag(72);
        output.WriteInt64(RenewalDelaySeconds);
      }
      if (HasRenewalRetryIntervalSeconds) {
        output.WriteRawTag(80);
        output.WriteInt64(RenewalRetryIntervalSeconds);
      }
      if (HasRenewWithUsage) {
        output.WriteRawTag(88);
        output.WriteBool(RenewWithUsage);
      }
      if (HasAlwaysIncludeClientId) {
        output.WriteRawTag(96);
        output.WriteBool(AlwaysIncludeClientId);
      }
      if (HasPlayStartGracePeriodSeconds) {
        output.WriteRawTag(104);
        output.WriteInt64(PlayStartGracePeriodSeconds);
      }
      if (HasSoftEnforcePlaybackDuration) {
        output.WriteRawTag(112);
        output.WriteBool(SoftEnforcePlaybackDuration);
      }
      if (HasSoftEnforceRentalDuration) {
        output.WriteRawTag(120);
        output.WriteBool(SoftEnforceRentalDuration);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasCanPlay) {
        size += 1 + 1;
      }
      if (HasCanPersist) {
        size += 1 + 1;
      }
      if (HasCanRenew) {
        size += 1 + 1;
      }
      if (HasRentalDurationSeconds) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(RentalDurationSeconds);
      }
      if (HasPlaybackDurationSeconds) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(PlaybackDurationSeconds);
      }
      if (HasLicenseDurationSeconds) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(LicenseDurationSeconds);
      }
      if (HasRenewalRecoveryDurationSeconds) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(RenewalRecoveryDurationSeconds);
      }
      if (HasRenewalServerUrl) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RenewalServerUrl);
      }
      if (HasRenewalDelaySeconds) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(RenewalDelaySeconds);
      }
      if (HasRenewalRetryIntervalSeconds) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(RenewalRetryIntervalSeconds);
      }
      if (HasRenewWithUsage) {
        size += 1 + 1;
      }
      if (HasAlwaysIncludeClientId) {
        size += 1 + 1;
      }
      if (HasPlayStartGracePeriodSeconds) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(PlayStartGracePeriodSeconds);
      }
      if (HasSoftEnforcePlaybackDuration) {
        size += 1 + 1;
      }
      if (HasSoftEnforceRentalDuration) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Policy other) {
      if (other == null) {
        return;
      }
      if (other.HasCanPlay) {
        CanPlay = other.CanPlay;
      }
      if (other.HasCanPersist) {
        CanPersist = other.CanPersist;
      }
      if (other.HasCanRenew) {
        CanRenew = other.CanRenew;
      }
      if (other.HasRentalDurationSeconds) {
        RentalDurationSeconds = other.RentalDurationSeconds;
      }
      if (other.HasPlaybackDurationSeconds) {
        PlaybackDurationSeconds = other.PlaybackDurationSeconds;
      }
      if (other.HasLicenseDurationSeconds) {
        LicenseDurationSeconds = other.LicenseDurationSeconds;
      }
      if (other.HasRenewalRecoveryDurationSeconds) {
        RenewalRecoveryDurationSeconds = other.RenewalRecoveryDurationSeconds;
      }
      if (other.HasRenewalServerUrl) {
        RenewalServerUrl = other.RenewalServerUrl;
      }
      if (other.HasRenewalDelaySeconds) {
        RenewalDelaySeconds = other.RenewalDelaySeconds;
      }
      if (other.HasRenewalRetryIntervalSeconds) {
        RenewalRetryIntervalSeconds = other.RenewalRetryIntervalSeconds;
      }
      if (other.HasRenewWithUsage) {
        RenewWithUsage = other.RenewWithUsage;
      }
      if (other.HasAlwaysIncludeClientId) {
        AlwaysIncludeClientId = other.AlwaysIncludeClientId;
      }
      if (other.HasPlayStartGracePeriodSeconds) {
        PlayStartGracePeriodSeconds = other.PlayStartGracePeriodSeconds;
      }
      if (other.HasSoftEnforcePlaybackDuration) {
        SoftEnforcePlaybackDuration = other.SoftEnforcePlaybackDuration;
      }
      if (other.HasSoftEnforceRentalDuration) {
        SoftEnforceRentalDuration = other.SoftEnforceRentalDuration;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            CanPlay = input.ReadBool();
            break;
          }
          case 16: {
            CanPersist = input.ReadBool();
            break;
          }
          case 24: {
            CanRenew = input.ReadBool();
            break;
          }
          case 32: {
            RentalDurationSeconds = input.ReadInt64();
            break;
          }
          case 40: {
            PlaybackDurationSeconds = input.ReadInt64();
            break;
          }
          case 48: {
            LicenseDurationSeconds = input.ReadInt64();
            break;
          }
          case 56: {
            RenewalRecoveryDurationSeconds = input.ReadInt64();
            break;
          }
          case 66: {
            RenewalServerUrl = input.ReadString();
            break;
          }
          case 72: {
            RenewalDelaySeconds = input.ReadInt64();
            break;
          }
          case 80: {
            RenewalRetryIntervalSeconds = input.ReadInt64();
            break;
          }
          case 88: {
            RenewWithUsage = input.ReadBool();
            break;
          }
          case 96: {
            AlwaysIncludeClientId = input.ReadBool();
            break;
          }
          case 104: {
            PlayStartGracePeriodSeconds = input.ReadInt64();
            break;
          }
          case 112: {
            SoftEnforcePlaybackDuration = input.ReadBool();
            break;
          }
          case 120: {
            SoftEnforceRentalDuration = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            CanPlay = input.ReadBool();
            break;
          }
          case 16: {
            CanPersist = input.ReadBool();
            break;
          }
          case 24: {
            CanRenew = input.ReadBool();
            break;
          }
          case 32: {
            RentalDurationSeconds = input.ReadInt64();
            break;
          }
          case 40: {
            PlaybackDurationSeconds = input.ReadInt64();
            break;
          }
          case 48: {
            LicenseDurationSeconds = input.ReadInt64();
            break;
          }
          case 56: {
            RenewalRecoveryDurationSeconds = input.ReadInt64();
            break;
          }
          case 66: {
            RenewalServerUrl = input.ReadString();
            break;
          }
          case 72: {
            RenewalDelaySeconds = input.ReadInt64();
            break;
          }
          case 80: {
            RenewalRetryIntervalSeconds = input.ReadInt64();
            break;
          }
          case 88: {
            RenewWithUsage = input.ReadBool();
            break;
          }
          case 96: {
            AlwaysIncludeClientId = input.ReadBool();
            break;
          }
          case 104: {
            PlayStartGracePeriodSeconds = input.ReadInt64();
            break;
          }
          case 112: {
            SoftEnforcePlaybackDuration = input.ReadBool();
            break;
          }
          case 120: {
            SoftEnforceRentalDuration = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  internal sealed partial class KeyContainer : pb::IMessage<KeyContainer>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<KeyContainer> _parser = new pb::MessageParser<KeyContainer>(() => new KeyContainer());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<KeyContainer> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AudibleUtilities.Widevine.License.Descriptor.NestedTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyContainer() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyContainer(KeyContainer other) : this() {
      _hasBits0 = other._hasBits0;
      id_ = other.id_;
      iv_ = other.iv_;
      key_ = other.key_;
      type_ = other.type_;
      level_ = other.level_;
      requiredProtection_ = other.requiredProtection_ != null ? other.requiredProtection_.Clone() : null;
      requestedProtection_ = other.requestedProtection_ != null ? other.requestedProtection_.Clone() : null;
      keyControl_ = other.keyControl_ != null ? other.keyControl_.Clone() : null;
      operatorSessionKeyPermissions_ = other.operatorSessionKeyPermissions_ != null ? other.operatorSessionKeyPermissions_.Clone() : null;
      videoResolutionConstraints_ = other.videoResolutionConstraints_.Clone();
      antiRollbackUsageTable_ = other.antiRollbackUsageTable_;
      trackLabel_ = other.trackLabel_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyContainer Clone() {
      return new KeyContainer(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private readonly static pb::ByteString IdDefaultValue = pb::ByteString.Empty;

    private pb::ByteString id_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Id {
      get { return id_ ?? IdDefaultValue; }
      set {
        id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasId {
      get { return id_ != null; }
    }
    /// <summary>Clears the value of the "id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearId() {
      id_ = null;
    }

    /// <summary>Field number for the "iv" field.</summary>
    public const int IvFieldNumber = 2;
    private readonly static pb::ByteString IvDefaultValue = pb::ByteString.Empty;

    private pb::ByteString iv_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Iv {
      get { return iv_ ?? IvDefaultValue; }
      set {
        iv_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "iv" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIv {
      get { return iv_ != null; }
    }
    /// <summary>Clears the value of the "iv" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIv() {
      iv_ = null;
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 3;
    private readonly static pb::ByteString KeyDefaultValue = pb::ByteString.Empty;

    private pb::ByteString key_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Key {
      get { return key_ ?? KeyDefaultValue; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKey {
      get { return key_ != null; }
    }
    /// <summary>Clears the value of the "key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKey() {
      key_ = null;
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 4;
    private readonly static global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.KeyType TypeDefaultValue = global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.KeyType.Signing;

    private global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.KeyType type_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.KeyType Type {
      get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        type_ = value;
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "level" field.</summary>
    public const int LevelFieldNumber = 5;
    private readonly static global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.SecurityLevel LevelDefaultValue = global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.SecurityLevel.SwSecureCrypto;

    private global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.SecurityLevel level_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.SecurityLevel Level {
      get { if ((_hasBits0 & 2) != 0) { return level_; } else { return LevelDefaultValue; } }
      set {
        _hasBits0 |= 2;
        level_ = value;
      }
    }
    /// <summary>Gets whether the "level" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLevel {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "level" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLevel() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "required_protection" field.</summary>
    public const int RequiredProtectionFieldNumber = 6;
    private global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection requiredProtection_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection RequiredProtection {
      get { return requiredProtection_; }
      set {
        requiredProtection_ = value;
      }
    }

    /// <summary>Field number for the "requested_protection" field.</summary>
    public const int RequestedProtectionFieldNumber = 7;
    private global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection requestedProtection_;
    /// <summary>
    /// NOTE: Use of requested_protection is not recommended as it is only
    /// supported on a small number of platforms.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection RequestedProtection {
      get { return requestedProtection_; }
      set {
        requestedProtection_ = value;
      }
    }

    /// <summary>Field number for the "key_control" field.</summary>
    public const int KeyControlFieldNumber = 8;
    private global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.KeyControl keyControl_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.KeyControl KeyControl {
      get { return keyControl_; }
      set {
        keyControl_ = value;
      }
    }

    /// <summary>Field number for the "operator_session_key_permissions" field.</summary>
    public const int OperatorSessionKeyPermissionsFieldNumber = 9;
    private global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OperatorSessionKeyPermissions operatorSessionKeyPermissions_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OperatorSessionKeyPermissions OperatorSessionKeyPermissions {
      get { return operatorSessionKeyPermissions_; }
      set {
        operatorSessionKeyPermissions_ = value;
      }
    }

    /// <summary>Field number for the "video_resolution_constraints" field.</summary>
    public const int VideoResolutionConstraintsFieldNumber = 10;
    private static readonly pb::FieldCodec<global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.VideoResolutionConstraint> _repeated_videoResolutionConstraints_codec
        = pb::FieldCodec.ForMessage(82, global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.VideoResolutionConstraint.Parser);
    private readonly pbc::RepeatedField<global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.VideoResolutionConstraint> videoResolutionConstraints_ = new pbc::RepeatedField<global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.VideoResolutionConstraint>();
    /// <summary>
    /// Optional video resolution constraints. If the video resolution of the
    /// content being decrypted/decoded falls within one of the specified ranges,
    /// the optional required_protections may be applied. Otherwise an error will
    /// be reported.
    /// NOTE: Use of this feature is not recommended, as it is only supported on
    /// a small number of platforms.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.VideoResolutionConstraint> VideoResolutionConstraints {
      get { return videoResolutionConstraints_; }
    }

    /// <summary>Field number for the "anti_rollback_usage_table" field.</summary>
    public const int AntiRollbackUsageTableFieldNumber = 11;
    private readonly static bool AntiRollbackUsageTableDefaultValue = false;

    private bool antiRollbackUsageTable_;
    /// <summary>
    /// Optional flag to indicate the key must only be used if the client
    /// supports anti rollback of the user table.  Content provider can query the
    /// client capabilities to determine if the client support this feature.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AntiRollbackUsageTable {
      get { if ((_hasBits0 & 4) != 0) { return antiRollbackUsageTable_; } else { return AntiRollbackUsageTableDefaultValue; } }
      set {
        _hasBits0 |= 4;
        antiRollbackUsageTable_ = value;
      }
    }
    /// <summary>Gets whether the "anti_rollback_usage_table" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAntiRollbackUsageTable {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "anti_rollback_usage_table" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAntiRollbackUsageTable() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "track_label" field.</summary>
    public const int TrackLabelFieldNumber = 12;
    private readonly static string TrackLabelDefaultValue = "";

    private string trackLabel_;
    /// <summary>
    /// Optional not limited to commonly known track types such as SD, HD.
    /// It can be some provider defined label to identify the track.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TrackLabel {
      get { return trackLabel_ ?? TrackLabelDefaultValue; }
      set {
        trackLabel_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "track_label" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTrackLabel {
      get { return trackLabel_ != null; }
    }
    /// <summary>Clears the value of the "track_label" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTrackLabel() {
      trackLabel_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as KeyContainer);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(KeyContainer other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (Iv != other.Iv) return false;
      if (Key != other.Key) return false;
      if (Type != other.Type) return false;
      if (Level != other.Level) return false;
      if (!object.Equals(RequiredProtection, other.RequiredProtection)) return false;
      if (!object.Equals(RequestedProtection, other.RequestedProtection)) return false;
      if (!object.Equals(KeyControl, other.KeyControl)) return false;
      if (!object.Equals(OperatorSessionKeyPermissions, other.OperatorSessionKeyPermissions)) return false;
      if(!videoResolutionConstraints_.Equals(other.videoResolutionConstraints_)) return false;
      if (AntiRollbackUsageTable != other.AntiRollbackUsageTable) return false;
      if (TrackLabel != other.TrackLabel) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasId) hash ^= Id.GetHashCode();
      if (HasIv) hash ^= Iv.GetHashCode();
      if (HasKey) hash ^= Key.GetHashCode();
      if (HasType) hash ^= Type.GetHashCode();
      if (HasLevel) hash ^= Level.GetHashCode();
      if (requiredProtection_ != null) hash ^= RequiredProtection.GetHashCode();
      if (requestedProtection_ != null) hash ^= RequestedProtection.GetHashCode();
      if (keyControl_ != null) hash ^= KeyControl.GetHashCode();
      if (operatorSessionKeyPermissions_ != null) hash ^= OperatorSessionKeyPermissions.GetHashCode();
      hash ^= videoResolutionConstraints_.GetHashCode();
      if (HasAntiRollbackUsageTable) hash ^= AntiRollbackUsageTable.GetHashCode();
      if (HasTrackLabel) hash ^= TrackLabel.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasId) {
        output.WriteRawTag(10);
        output.WriteBytes(Id);
      }
      if (HasIv) {
        output.WriteRawTag(18);
        output.WriteBytes(Iv);
      }
      if (HasKey) {
        output.WriteRawTag(26);
        output.WriteBytes(Key);
      }
      if (HasType) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Type);
      }
      if (HasLevel) {
        output.WriteRawTag(40);
        output.WriteEnum((int) Level);
      }
      if (requiredProtection_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(RequiredProtection);
      }
      if (requestedProtection_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(RequestedProtection);
      }
      if (keyControl_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(KeyControl);
      }
      if (operatorSessionKeyPermissions_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(OperatorSessionKeyPermissions);
      }
      videoResolutionConstraints_.WriteTo(output, _repeated_videoResolutionConstraints_codec);
      if (HasAntiRollbackUsageTable) {
        output.WriteRawTag(88);
        output.WriteBool(AntiRollbackUsageTable);
      }
      if (HasTrackLabel) {
        output.WriteRawTag(98);
        output.WriteString(TrackLabel);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasId) {
        output.WriteRawTag(10);
        output.WriteBytes(Id);
      }
      if (HasIv) {
        output.WriteRawTag(18);
        output.WriteBytes(Iv);
      }
      if (HasKey) {
        output.WriteRawTag(26);
        output.WriteBytes(Key);
      }
      if (HasType) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Type);
      }
      if (HasLevel) {
        output.WriteRawTag(40);
        output.WriteEnum((int) Level);
      }
      if (requiredProtection_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(RequiredProtection);
      }
      if (requestedProtection_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(RequestedProtection);
      }
      if (keyControl_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(KeyControl);
      }
      if (operatorSessionKeyPermissions_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(OperatorSessionKeyPermissions);
      }
      videoResolutionConstraints_.WriteTo(ref output, _repeated_videoResolutionConstraints_codec);
      if (HasAntiRollbackUsageTable) {
        output.WriteRawTag(88);
        output.WriteBool(AntiRollbackUsageTable);
      }
      if (HasTrackLabel) {
        output.WriteRawTag(98);
        output.WriteString(TrackLabel);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasId) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Id);
      }
      if (HasIv) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Iv);
      }
      if (HasKey) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Key);
      }
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (HasLevel) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Level);
      }
      if (requiredProtection_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RequiredProtection);
      }
      if (requestedProtection_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RequestedProtection);
      }
      if (keyControl_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(KeyControl);
      }
      if (operatorSessionKeyPermissions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OperatorSessionKeyPermissions);
      }
      size += videoResolutionConstraints_.CalculateSize(_repeated_videoResolutionConstraints_codec);
      if (HasAntiRollbackUsageTable) {
        size += 1 + 1;
      }
      if (HasTrackLabel) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TrackLabel);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(KeyContainer other) {
      if (other == null) {
        return;
      }
      if (other.HasId) {
        Id = other.Id;
      }
      if (other.HasIv) {
        Iv = other.Iv;
      }
      if (other.HasKey) {
        Key = other.Key;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasLevel) {
        Level = other.Level;
      }
      if (other.requiredProtection_ != null) {
        if (requiredProtection_ == null) {
          RequiredProtection = new global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection();
        }
        RequiredProtection.MergeFrom(other.RequiredProtection);
      }
      if (other.requestedProtection_ != null) {
        if (requestedProtection_ == null) {
          RequestedProtection = new global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection();
        }
        RequestedProtection.MergeFrom(other.RequestedProtection);
      }
      if (other.keyControl_ != null) {
        if (keyControl_ == null) {
          KeyControl = new global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.KeyControl();
        }
        KeyControl.MergeFrom(other.KeyControl);
      }
      if (other.operatorSessionKeyPermissions_ != null) {
        if (operatorSessionKeyPermissions_ == null) {
          OperatorSessionKeyPermissions = new global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OperatorSessionKeyPermissions();
        }
        OperatorSessionKeyPermissions.MergeFrom(other.OperatorSessionKeyPermissions);
      }
      videoResolutionConstraints_.Add(other.videoResolutionConstraints_);
      if (other.HasAntiRollbackUsageTable) {
        AntiRollbackUsageTable = other.AntiRollbackUsageTable;
      }
      if (other.HasTrackLabel) {
        TrackLabel = other.TrackLabel;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Id = input.ReadBytes();
            break;
          }
          case 18: {
            Iv = input.ReadBytes();
            break;
          }
          case 26: {
            Key = input.ReadBytes();
            break;
          }
          case 32: {
            Type = (global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.KeyType) input.ReadEnum();
            break;
          }
          case 40: {
            Level = (global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.SecurityLevel) input.ReadEnum();
            break;
          }
          case 50: {
            if (requiredProtection_ == null) {
              RequiredProtection = new global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection();
            }
            input.ReadMessage(RequiredProtection);
            break;
          }
          case 58: {
            if (requestedProtection_ == null) {
              RequestedProtection = new global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection();
            }
            input.ReadMessage(RequestedProtection);
            break;
          }
          case 66: {
            if (keyControl_ == null) {
              KeyControl = new global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.KeyControl();
            }
            input.ReadMessage(KeyControl);
            break;
          }
          case 74: {
            if (operatorSessionKeyPermissions_ == null) {
              OperatorSessionKeyPermissions = new global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OperatorSessionKeyPermissions();
            }
            input.ReadMessage(OperatorSessionKeyPermissions);
            break;
          }
          case 82: {
            videoResolutionConstraints_.AddEntriesFrom(input, _repeated_videoResolutionConstraints_codec);
            break;
          }
          case 88: {
            AntiRollbackUsageTable = input.ReadBool();
            break;
          }
          case 98: {
            TrackLabel = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Id = input.ReadBytes();
            break;
          }
          case 18: {
            Iv = input.ReadBytes();
            break;
          }
          case 26: {
            Key = input.ReadBytes();
            break;
          }
          case 32: {
            Type = (global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.KeyType) input.ReadEnum();
            break;
          }
          case 40: {
            Level = (global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.SecurityLevel) input.ReadEnum();
            break;
          }
          case 50: {
            if (requiredProtection_ == null) {
              RequiredProtection = new global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection();
            }
            input.ReadMessage(RequiredProtection);
            break;
          }
          case 58: {
            if (requestedProtection_ == null) {
              RequestedProtection = new global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection();
            }
            input.ReadMessage(RequestedProtection);
            break;
          }
          case 66: {
            if (keyControl_ == null) {
              KeyControl = new global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.KeyControl();
            }
            input.ReadMessage(KeyControl);
            break;
          }
          case 74: {
            if (operatorSessionKeyPermissions_ == null) {
              OperatorSessionKeyPermissions = new global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OperatorSessionKeyPermissions();
            }
            input.ReadMessage(OperatorSessionKeyPermissions);
            break;
          }
          case 82: {
            videoResolutionConstraints_.AddEntriesFrom(ref input, _repeated_videoResolutionConstraints_codec);
            break;
          }
          case 88: {
            AntiRollbackUsageTable = input.ReadBool();
            break;
          }
          case 98: {
            TrackLabel = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the KeyContainer message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      internal enum KeyType {
        /// <summary>
        /// Exactly one key of this type must appear.
        /// </summary>
        [pbr::OriginalName("SIGNING")] Signing = 1,
        /// <summary>
        /// Content key.
        /// </summary>
        [pbr::OriginalName("CONTENT")] Content = 2,
        /// <summary>
        /// Key control block for license renewals. No key.
        /// </summary>
        [pbr::OriginalName("KEY_CONTROL")] KeyControl = 3,
        /// <summary>
        /// wrapped keys for auxiliary crypto operations.
        /// </summary>
        [pbr::OriginalName("OPERATOR_SESSION")] OperatorSession = 4,
        /// <summary>
        /// Entitlement keys.
        /// </summary>
        [pbr::OriginalName("ENTITLEMENT")] Entitlement = 5,
        /// <summary>
        /// Partner-specific content key.
        /// </summary>
        [pbr::OriginalName("OEM_CONTENT")] OemContent = 6,
      }

      /// <summary>
      /// The SecurityLevel enumeration allows the server to communicate the level
      /// of robustness required by the client, in order to use the key.
      /// </summary>
      internal enum SecurityLevel {
        /// <summary>
        /// Software-based whitebox crypto is required.
        /// </summary>
        [pbr::OriginalName("SW_SECURE_CRYPTO")] SwSecureCrypto = 1,
        /// <summary>
        /// Software crypto and an obfuscated decoder is required.
        /// </summary>
        [pbr::OriginalName("SW_SECURE_DECODE")] SwSecureDecode = 2,
        /// <summary>
        /// The key material and crypto operations must be performed within a
        /// hardware backed trusted execution environment.
        /// </summary>
        [pbr::OriginalName("HW_SECURE_CRYPTO")] HwSecureCrypto = 3,
        /// <summary>
        /// The crypto and decoding of content must be performed within a hardware
        /// backed trusted execution environment.
        /// </summary>
        [pbr::OriginalName("HW_SECURE_DECODE")] HwSecureDecode = 4,
        /// <summary>
        /// The crypto, decoding and all handling of the media (compressed and
        /// uncompressed) must be handled within a hardware backed trusted
        /// execution environment.
        /// </summary>
        [pbr::OriginalName("HW_SECURE_ALL")] HwSecureAll = 5,
      }

      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      internal sealed partial class KeyControl : pb::IMessage<KeyControl>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<KeyControl> _parser = new pb::MessageParser<KeyControl>(() => new KeyControl());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<KeyControl> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::AudibleUtilities.Widevine.License.Types.KeyContainer.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public KeyControl() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public KeyControl(KeyControl other) : this() {
          keyControlBlock_ = other.keyControlBlock_;
          iv_ = other.iv_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public KeyControl Clone() {
          return new KeyControl(this);
        }

        /// <summary>Field number for the "key_control_block" field.</summary>
        public const int KeyControlBlockFieldNumber = 1;
        private readonly static pb::ByteString KeyControlBlockDefaultValue = pb::ByteString.Empty;

        private pb::ByteString keyControlBlock_;
        /// <summary>
        /// |key_control| is documented in:
        /// Widevine Modular DRM Security Integration Guide for CENC
        /// If present, the key control must be communicated to the secure
        /// environment prior to any usage. This message is automatically generated
        /// by the Widevine License Server SDK.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pb::ByteString KeyControlBlock {
          get { return keyControlBlock_ ?? KeyControlBlockDefaultValue; }
          set {
            keyControlBlock_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "key_control_block" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasKeyControlBlock {
          get { return keyControlBlock_ != null; }
        }
        /// <summary>Clears the value of the "key_control_block" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearKeyControlBlock() {
          keyControlBlock_ = null;
        }

        /// <summary>Field number for the "iv" field.</summary>
        public const int IvFieldNumber = 2;
        private readonly static pb::ByteString IvDefaultValue = pb::ByteString.Empty;

        private pb::ByteString iv_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pb::ByteString Iv {
          get { return iv_ ?? IvDefaultValue; }
          set {
            iv_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "iv" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasIv {
          get { return iv_ != null; }
        }
        /// <summary>Clears the value of the "iv" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearIv() {
          iv_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as KeyControl);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(KeyControl other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (KeyControlBlock != other.KeyControlBlock) return false;
          if (Iv != other.Iv) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasKeyControlBlock) hash ^= KeyControlBlock.GetHashCode();
          if (HasIv) hash ^= Iv.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasKeyControlBlock) {
            output.WriteRawTag(10);
            output.WriteBytes(KeyControlBlock);
          }
          if (HasIv) {
            output.WriteRawTag(18);
            output.WriteBytes(Iv);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasKeyControlBlock) {
            output.WriteRawTag(10);
            output.WriteBytes(KeyControlBlock);
          }
          if (HasIv) {
            output.WriteRawTag(18);
            output.WriteBytes(Iv);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasKeyControlBlock) {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(KeyControlBlock);
          }
          if (HasIv) {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(Iv);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(KeyControl other) {
          if (other == null) {
            return;
          }
          if (other.HasKeyControlBlock) {
            KeyControlBlock = other.KeyControlBlock;
          }
          if (other.HasIv) {
            Iv = other.Iv;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                KeyControlBlock = input.ReadBytes();
                break;
              }
              case 18: {
                Iv = input.ReadBytes();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                KeyControlBlock = input.ReadBytes();
                break;
              }
              case 18: {
                Iv = input.ReadBytes();
                break;
              }
            }
          }
        }
        #endif

      }

      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      internal sealed partial class OutputProtection : pb::IMessage<OutputProtection>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<OutputProtection> _parser = new pb::MessageParser<OutputProtection>(() => new OutputProtection());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<OutputProtection> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::AudibleUtilities.Widevine.License.Types.KeyContainer.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OutputProtection() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OutputProtection(OutputProtection other) : this() {
          _hasBits0 = other._hasBits0;
          hdcp_ = other.hdcp_;
          cgmsFlags_ = other.cgmsFlags_;
          hdcpSrmRule_ = other.hdcpSrmRule_;
          disableAnalogOutput_ = other.disableAnalogOutput_;
          disableDigitalOutput_ = other.disableDigitalOutput_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OutputProtection Clone() {
          return new OutputProtection(this);
        }

        /// <summary>Field number for the "hdcp" field.</summary>
        public const int HdcpFieldNumber = 1;
        private readonly static global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection.Types.HDCP HdcpDefaultValue = global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection.Types.HDCP.None;

        private global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection.Types.HDCP hdcp_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection.Types.HDCP Hdcp {
          get { if ((_hasBits0 & 1) != 0) { return hdcp_; } else { return HdcpDefaultValue; } }
          set {
            _hasBits0 |= 1;
            hdcp_ = value;
          }
        }
        /// <summary>Gets whether the "hdcp" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasHdcp {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "hdcp" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearHdcp() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "cgms_flags" field.</summary>
        public const int CgmsFlagsFieldNumber = 2;
        private readonly static global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection.Types.CGMS CgmsFlagsDefaultValue = global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection.Types.CGMS.None;

        private global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection.Types.CGMS cgmsFlags_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection.Types.CGMS CgmsFlags {
          get { if ((_hasBits0 & 2) != 0) { return cgmsFlags_; } else { return CgmsFlagsDefaultValue; } }
          set {
            _hasBits0 |= 2;
            cgmsFlags_ = value;
          }
        }
        /// <summary>Gets whether the "cgms_flags" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasCgmsFlags {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "cgms_flags" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearCgmsFlags() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "hdcp_srm_rule" field.</summary>
        public const int HdcpSrmRuleFieldNumber = 3;
        private readonly static global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection.Types.HdcpSrmRule HdcpSrmRuleDefaultValue = global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection.Types.HdcpSrmRule.None;

        private global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection.Types.HdcpSrmRule hdcpSrmRule_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection.Types.HdcpSrmRule HdcpSrmRule {
          get { if ((_hasBits0 & 4) != 0) { return hdcpSrmRule_; } else { return HdcpSrmRuleDefaultValue; } }
          set {
            _hasBits0 |= 4;
            hdcpSrmRule_ = value;
          }
        }
        /// <summary>Gets whether the "hdcp_srm_rule" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasHdcpSrmRule {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "hdcp_srm_rule" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearHdcpSrmRule() {
          _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "disable_analog_output" field.</summary>
        public const int DisableAnalogOutputFieldNumber = 4;
        private readonly static bool DisableAnalogOutputDefaultValue = false;

        private bool disableAnalogOutput_;
        /// <summary>
        /// Optional requirement to indicate analog output is not allowed.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool DisableAnalogOutput {
          get { if ((_hasBits0 & 8) != 0) { return disableAnalogOutput_; } else { return DisableAnalogOutputDefaultValue; } }
          set {
            _hasBits0 |= 8;
            disableAnalogOutput_ = value;
          }
        }
        /// <summary>Gets whether the "disable_analog_output" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasDisableAnalogOutput {
          get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "disable_analog_output" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearDisableAnalogOutput() {
          _hasBits0 &= ~8;
        }

        /// <summary>Field number for the "disable_digital_output" field.</summary>
        public const int DisableDigitalOutputFieldNumber = 5;
        private readonly static bool DisableDigitalOutputDefaultValue = false;

        private bool disableDigitalOutput_;
        /// <summary>
        /// Optional requirement to indicate digital output is not allowed.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool DisableDigitalOutput {
          get { if ((_hasBits0 & 16) != 0) { return disableDigitalOutput_; } else { return DisableDigitalOutputDefaultValue; } }
          set {
            _hasBits0 |= 16;
            disableDigitalOutput_ = value;
          }
        }
        /// <summary>Gets whether the "disable_digital_output" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasDisableDigitalOutput {
          get { return (_hasBits0 & 16) != 0; }
        }
        /// <summary>Clears the value of the "disable_digital_output" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearDisableDigitalOutput() {
          _hasBits0 &= ~16;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as OutputProtection);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(OutputProtection other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Hdcp != other.Hdcp) return false;
          if (CgmsFlags != other.CgmsFlags) return false;
          if (HdcpSrmRule != other.HdcpSrmRule) return false;
          if (DisableAnalogOutput != other.DisableAnalogOutput) return false;
          if (DisableDigitalOutput != other.DisableDigitalOutput) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasHdcp) hash ^= Hdcp.GetHashCode();
          if (HasCgmsFlags) hash ^= CgmsFlags.GetHashCode();
          if (HasHdcpSrmRule) hash ^= HdcpSrmRule.GetHashCode();
          if (HasDisableAnalogOutput) hash ^= DisableAnalogOutput.GetHashCode();
          if (HasDisableDigitalOutput) hash ^= DisableDigitalOutput.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasHdcp) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Hdcp);
          }
          if (HasCgmsFlags) {
            output.WriteRawTag(16);
            output.WriteEnum((int) CgmsFlags);
          }
          if (HasHdcpSrmRule) {
            output.WriteRawTag(24);
            output.WriteEnum((int) HdcpSrmRule);
          }
          if (HasDisableAnalogOutput) {
            output.WriteRawTag(32);
            output.WriteBool(DisableAnalogOutput);
          }
          if (HasDisableDigitalOutput) {
            output.WriteRawTag(40);
            output.WriteBool(DisableDigitalOutput);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasHdcp) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Hdcp);
          }
          if (HasCgmsFlags) {
            output.WriteRawTag(16);
            output.WriteEnum((int) CgmsFlags);
          }
          if (HasHdcpSrmRule) {
            output.WriteRawTag(24);
            output.WriteEnum((int) HdcpSrmRule);
          }
          if (HasDisableAnalogOutput) {
            output.WriteRawTag(32);
            output.WriteBool(DisableAnalogOutput);
          }
          if (HasDisableDigitalOutput) {
            output.WriteRawTag(40);
            output.WriteBool(DisableDigitalOutput);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasHdcp) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Hdcp);
          }
          if (HasCgmsFlags) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CgmsFlags);
          }
          if (HasHdcpSrmRule) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) HdcpSrmRule);
          }
          if (HasDisableAnalogOutput) {
            size += 1 + 1;
          }
          if (HasDisableDigitalOutput) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(OutputProtection other) {
          if (other == null) {
            return;
          }
          if (other.HasHdcp) {
            Hdcp = other.Hdcp;
          }
          if (other.HasCgmsFlags) {
            CgmsFlags = other.CgmsFlags;
          }
          if (other.HasHdcpSrmRule) {
            HdcpSrmRule = other.HdcpSrmRule;
          }
          if (other.HasDisableAnalogOutput) {
            DisableAnalogOutput = other.DisableAnalogOutput;
          }
          if (other.HasDisableDigitalOutput) {
            DisableDigitalOutput = other.DisableDigitalOutput;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Hdcp = (global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection.Types.HDCP) input.ReadEnum();
                break;
              }
              case 16: {
                CgmsFlags = (global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection.Types.CGMS) input.ReadEnum();
                break;
              }
              case 24: {
                HdcpSrmRule = (global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection.Types.HdcpSrmRule) input.ReadEnum();
                break;
              }
              case 32: {
                DisableAnalogOutput = input.ReadBool();
                break;
              }
              case 40: {
                DisableDigitalOutput = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Hdcp = (global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection.Types.HDCP) input.ReadEnum();
                break;
              }
              case 16: {
                CgmsFlags = (global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection.Types.CGMS) input.ReadEnum();
                break;
              }
              case 24: {
                HdcpSrmRule = (global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection.Types.HdcpSrmRule) input.ReadEnum();
                break;
              }
              case 32: {
                DisableAnalogOutput = input.ReadBool();
                break;
              }
              case 40: {
                DisableDigitalOutput = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the OutputProtection message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// Indicates whether HDCP is required on digital outputs, and which
          /// version should be used.
          /// </summary>
          internal enum HDCP {
            [pbr::OriginalName("HDCP_NONE")] None = 0,
            [pbr::OriginalName("HDCP_V1")] V1 = 1,
            [pbr::OriginalName("HDCP_V2")] V2 = 2,
            [pbr::OriginalName("HDCP_V2_1")] V21 = 3,
            [pbr::OriginalName("HDCP_V2_2")] V22 = 4,
            [pbr::OriginalName("HDCP_V2_3")] V23 = 5,
            [pbr::OriginalName("HDCP_NO_DIGITAL_OUTPUT")] NoDigitalOutput = 255,
          }

          /// <summary>
          /// Indicate the CGMS setting to be inserted on analog output.
          /// </summary>
          internal enum CGMS {
            [pbr::OriginalName("CGMS_NONE")] None = 42,
            [pbr::OriginalName("COPY_FREE")] CopyFree = 0,
            [pbr::OriginalName("COPY_ONCE")] CopyOnce = 2,
            [pbr::OriginalName("COPY_NEVER")] CopyNever = 3,
          }

          internal enum HdcpSrmRule {
            [pbr::OriginalName("HDCP_SRM_RULE_NONE")] None = 0,
            /// <summary>
            /// In 'required_protection', this means most current SRM is required.
            /// Update the SRM on the device. If update cannot happen,
            /// do not allow the key.
            /// In 'requested_protection', this means most current SRM is requested.
            /// Update the SRM on the device. If update cannot happen,
            /// allow use of the key anyway.
            /// </summary>
            [pbr::OriginalName("CURRENT_SRM")] CurrentSrm = 1,
          }

        }
        #endregion

      }

      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      internal sealed partial class VideoResolutionConstraint : pb::IMessage<VideoResolutionConstraint>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<VideoResolutionConstraint> _parser = new pb::MessageParser<VideoResolutionConstraint>(() => new VideoResolutionConstraint());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<VideoResolutionConstraint> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::AudibleUtilities.Widevine.License.Types.KeyContainer.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VideoResolutionConstraint() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VideoResolutionConstraint(VideoResolutionConstraint other) : this() {
          _hasBits0 = other._hasBits0;
          minResolutionPixels_ = other.minResolutionPixels_;
          maxResolutionPixels_ = other.maxResolutionPixels_;
          requiredProtection_ = other.requiredProtection_ != null ? other.requiredProtection_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VideoResolutionConstraint Clone() {
          return new VideoResolutionConstraint(this);
        }

        /// <summary>Field number for the "min_resolution_pixels" field.</summary>
        public const int MinResolutionPixelsFieldNumber = 1;
        private readonly static uint MinResolutionPixelsDefaultValue = 0;

        private uint minResolutionPixels_;
        /// <summary>
        /// Minimum and maximum video resolutions in the range (height x width).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint MinResolutionPixels {
          get { if ((_hasBits0 & 1) != 0) { return minResolutionPixels_; } else { return MinResolutionPixelsDefaultValue; } }
          set {
            _hasBits0 |= 1;
            minResolutionPixels_ = value;
          }
        }
        /// <summary>Gets whether the "min_resolution_pixels" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMinResolutionPixels {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "min_resolution_pixels" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMinResolutionPixels() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "max_resolution_pixels" field.</summary>
        public const int MaxResolutionPixelsFieldNumber = 2;
        private readonly static uint MaxResolutionPixelsDefaultValue = 0;

        private uint maxResolutionPixels_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint MaxResolutionPixels {
          get { if ((_hasBits0 & 2) != 0) { return maxResolutionPixels_; } else { return MaxResolutionPixelsDefaultValue; } }
          set {
            _hasBits0 |= 2;
            maxResolutionPixels_ = value;
          }
        }
        /// <summary>Gets whether the "max_resolution_pixels" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMaxResolutionPixels {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "max_resolution_pixels" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMaxResolutionPixels() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "required_protection" field.</summary>
        public const int RequiredProtectionFieldNumber = 3;
        private global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection requiredProtection_;
        /// <summary>
        /// Optional output protection requirements for this range. If not
        /// specified, the OutputProtection in the KeyContainer applies.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection RequiredProtection {
          get { return requiredProtection_; }
          set {
            requiredProtection_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as VideoResolutionConstraint);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(VideoResolutionConstraint other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (MinResolutionPixels != other.MinResolutionPixels) return false;
          if (MaxResolutionPixels != other.MaxResolutionPixels) return false;
          if (!object.Equals(RequiredProtection, other.RequiredProtection)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasMinResolutionPixels) hash ^= MinResolutionPixels.GetHashCode();
          if (HasMaxResolutionPixels) hash ^= MaxResolutionPixels.GetHashCode();
          if (requiredProtection_ != null) hash ^= RequiredProtection.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasMinResolutionPixels) {
            output.WriteRawTag(8);
            output.WriteUInt32(MinResolutionPixels);
          }
          if (HasMaxResolutionPixels) {
            output.WriteRawTag(16);
            output.WriteUInt32(MaxResolutionPixels);
          }
          if (requiredProtection_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(RequiredProtection);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasMinResolutionPixels) {
            output.WriteRawTag(8);
            output.WriteUInt32(MinResolutionPixels);
          }
          if (HasMaxResolutionPixels) {
            output.WriteRawTag(16);
            output.WriteUInt32(MaxResolutionPixels);
          }
          if (requiredProtection_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(RequiredProtection);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasMinResolutionPixels) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MinResolutionPixels);
          }
          if (HasMaxResolutionPixels) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MaxResolutionPixels);
          }
          if (requiredProtection_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(RequiredProtection);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(VideoResolutionConstraint other) {
          if (other == null) {
            return;
          }
          if (other.HasMinResolutionPixels) {
            MinResolutionPixels = other.MinResolutionPixels;
          }
          if (other.HasMaxResolutionPixels) {
            MaxResolutionPixels = other.MaxResolutionPixels;
          }
          if (other.requiredProtection_ != null) {
            if (requiredProtection_ == null) {
              RequiredProtection = new global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection();
            }
            RequiredProtection.MergeFrom(other.RequiredProtection);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                MinResolutionPixels = input.ReadUInt32();
                break;
              }
              case 16: {
                MaxResolutionPixels = input.ReadUInt32();
                break;
              }
              case 26: {
                if (requiredProtection_ == null) {
                  RequiredProtection = new global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection();
                }
                input.ReadMessage(RequiredProtection);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                MinResolutionPixels = input.ReadUInt32();
                break;
              }
              case 16: {
                MaxResolutionPixels = input.ReadUInt32();
                break;
              }
              case 26: {
                if (requiredProtection_ == null) {
                  RequiredProtection = new global::AudibleUtilities.Widevine.License.Types.KeyContainer.Types.OutputProtection();
                }
                input.ReadMessage(RequiredProtection);
                break;
              }
            }
          }
        }
        #endif

      }

      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      internal sealed partial class OperatorSessionKeyPermissions : pb::IMessage<OperatorSessionKeyPermissions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<OperatorSessionKeyPermissions> _parser = new pb::MessageParser<OperatorSessionKeyPermissions>(() => new OperatorSessionKeyPermissions());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<OperatorSessionKeyPermissions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::AudibleUtilities.Widevine.License.Types.KeyContainer.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OperatorSessionKeyPermissions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OperatorSessionKeyPermissions(OperatorSessionKeyPermissions other) : this() {
          _hasBits0 = other._hasBits0;
          allowEncrypt_ = other.allowEncrypt_;
          allowDecrypt_ = other.allowDecrypt_;
          allowSign_ = other.allowSign_;
          allowSignatureVerify_ = other.allowSignatureVerify_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OperatorSessionKeyPermissions Clone() {
          return new OperatorSessionKeyPermissions(this);
        }

        /// <summary>Field number for the "allow_encrypt" field.</summary>
        public const int AllowEncryptFieldNumber = 1;
        private readonly static bool AllowEncryptDefaultValue = false;

        private bool allowEncrypt_;
        /// <summary>
        /// Permissions/key usage flags for operator service keys
        /// (type = OPERATOR_SESSION).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool AllowEncrypt {
          get { if ((_hasBits0 & 1) != 0) { return allowEncrypt_; } else { return AllowEncryptDefaultValue; } }
          set {
            _hasBits0 |= 1;
            allowEncrypt_ = value;
          }
        }
        /// <summary>Gets whether the "allow_encrypt" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasAllowEncrypt {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "allow_encrypt" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearAllowEncrypt() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "allow_decrypt" field.</summary>
        public const int AllowDecryptFieldNumber = 2;
        private readonly static bool AllowDecryptDefaultValue = false;

        private bool allowDecrypt_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool AllowDecrypt {
          get { if ((_hasBits0 & 2) != 0) { return allowDecrypt_; } else { return AllowDecryptDefaultValue; } }
          set {
            _hasBits0 |= 2;
            allowDecrypt_ = value;
          }
        }
        /// <summary>Gets whether the "allow_decrypt" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasAllowDecrypt {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "allow_decrypt" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearAllowDecrypt() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "allow_sign" field.</summary>
        public const int AllowSignFieldNumber = 3;
        private readonly static bool AllowSignDefaultValue = false;

        private bool allowSign_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool AllowSign {
          get { if ((_hasBits0 & 4) != 0) { return allowSign_; } else { return AllowSignDefaultValue; } }
          set {
            _hasBits0 |= 4;
            allowSign_ = value;
          }
        }
        /// <summary>Gets whether the "allow_sign" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasAllowSign {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "allow_sign" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearAllowSign() {
          _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "allow_signature_verify" field.</summary>
        public const int AllowSignatureVerifyFieldNumber = 4;
        private readonly static bool AllowSignatureVerifyDefaultValue = false;

        private bool allowSignatureVerify_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool AllowSignatureVerify {
          get { if ((_hasBits0 & 8) != 0) { return allowSignatureVerify_; } else { return AllowSignatureVerifyDefaultValue; } }
          set {
            _hasBits0 |= 8;
            allowSignatureVerify_ = value;
          }
        }
        /// <summary>Gets whether the "allow_signature_verify" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasAllowSignatureVerify {
          get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "allow_signature_verify" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearAllowSignatureVerify() {
          _hasBits0 &= ~8;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as OperatorSessionKeyPermissions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(OperatorSessionKeyPermissions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (AllowEncrypt != other.AllowEncrypt) return false;
          if (AllowDecrypt != other.AllowDecrypt) return false;
          if (AllowSign != other.AllowSign) return false;
          if (AllowSignatureVerify != other.AllowSignatureVerify) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasAllowEncrypt) hash ^= AllowEncrypt.GetHashCode();
          if (HasAllowDecrypt) hash ^= AllowDecrypt.GetHashCode();
          if (HasAllowSign) hash ^= AllowSign.GetHashCode();
          if (HasAllowSignatureVerify) hash ^= AllowSignatureVerify.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasAllowEncrypt) {
            output.WriteRawTag(8);
            output.WriteBool(AllowEncrypt);
          }
          if (HasAllowDecrypt) {
            output.WriteRawTag(16);
            output.WriteBool(AllowDecrypt);
          }
          if (HasAllowSign) {
            output.WriteRawTag(24);
            output.WriteBool(AllowSign);
          }
          if (HasAllowSignatureVerify) {
            output.WriteRawTag(32);
            output.WriteBool(AllowSignatureVerify);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasAllowEncrypt) {
            output.WriteRawTag(8);
            output.WriteBool(AllowEncrypt);
          }
          if (HasAllowDecrypt) {
            output.WriteRawTag(16);
            output.WriteBool(AllowDecrypt);
          }
          if (HasAllowSign) {
            output.WriteRawTag(24);
            output.WriteBool(AllowSign);
          }
          if (HasAllowSignatureVerify) {
            output.WriteRawTag(32);
            output.WriteBool(AllowSignatureVerify);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasAllowEncrypt) {
            size += 1 + 1;
          }
          if (HasAllowDecrypt) {
            size += 1 + 1;
          }
          if (HasAllowSign) {
            size += 1 + 1;
          }
          if (HasAllowSignatureVerify) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(OperatorSessionKeyPermissions other) {
          if (other == null) {
            return;
          }
          if (other.HasAllowEncrypt) {
            AllowEncrypt = other.AllowEncrypt;
          }
          if (other.HasAllowDecrypt) {
            AllowDecrypt = other.AllowDecrypt;
          }
          if (other.HasAllowSign) {
            AllowSign = other.AllowSign;
          }
          if (other.HasAllowSignatureVerify) {
            AllowSignatureVerify = other.AllowSignatureVerify;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                AllowEncrypt = input.ReadBool();
                break;
              }
              case 16: {
                AllowDecrypt = input.ReadBool();
                break;
              }
              case 24: {
                AllowSign = input.ReadBool();
                break;
              }
              case 32: {
                AllowSignatureVerify = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                AllowEncrypt = input.ReadBool();
                break;
              }
              case 16: {
                AllowDecrypt = input.ReadBool();
                break;
              }
              case 24: {
                AllowSign = input.ReadBool();
                break;
              }
              case 32: {
                AllowSignatureVerify = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

}
#endregion

}

[global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
internal sealed partial class LicenseRequest : pb::IMessage<LicenseRequest>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  , pb::IBufferMessage
#endif
{
private static readonly pb::MessageParser<LicenseRequest> _parser = new pb::MessageParser<LicenseRequest>(() => new LicenseRequest());
private pb::UnknownFieldSet _unknownFields;
private int _hasBits0;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pb::MessageParser<LicenseRequest> Parser { get { return _parser; } }

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pbr::MessageDescriptor Descriptor {
  get { return global::AudibleUtilities.Widevine.LicenseProtocolReflection.Descriptor.MessageTypes[2]; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
pbr::MessageDescriptor pb::IMessage.Descriptor {
  get { return Descriptor; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public LicenseRequest() {
  OnConstruction();
}

partial void OnConstruction();

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public LicenseRequest(LicenseRequest other) : this() {
  _hasBits0 = other._hasBits0;
  clientId_ = other.clientId_ != null ? other.clientId_.Clone() : null;
  contentId_ = other.contentId_ != null ? other.contentId_.Clone() : null;
  type_ = other.type_;
  requestTime_ = other.requestTime_;
  keyControlNonceDeprecated_ = other.keyControlNonceDeprecated_;
  protocolVersion_ = other.protocolVersion_;
  keyControlNonce_ = other.keyControlNonce_;
  encryptedClientId_ = other.encryptedClientId_ != null ? other.encryptedClientId_.Clone() : null;
  _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public LicenseRequest Clone() {
  return new LicenseRequest(this);
}

/// <summary>Field number for the "client_id" field.</summary>
public const int ClientIdFieldNumber = 1;
private global::AudibleUtilities.Widevine.ClientIdentification clientId_;
/// <summary>
/// The client_id provides information authenticating the calling device.  It
/// contains the Widevine keybox token that was installed on the device at the
/// factory.  This field or encrypted_client_id below is required for a valid
/// license request, but both should never be present in the same request.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public global::AudibleUtilities.Widevine.ClientIdentification ClientId {
  get { return clientId_; }
  set {
    clientId_ = value;
  }
}

/// <summary>Field number for the "content_id" field.</summary>
public const int ContentIdFieldNumber = 2;
private global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification contentId_;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification ContentId {
  get { return contentId_; }
  set {
    contentId_ = value;
  }
}

/// <summary>Field number for the "type" field.</summary>
public const int TypeFieldNumber = 3;
private readonly static global::AudibleUtilities.Widevine.LicenseRequest.Types.RequestType TypeDefaultValue = global::AudibleUtilities.Widevine.LicenseRequest.Types.RequestType.New;

private global::AudibleUtilities.Widevine.LicenseRequest.Types.RequestType type_;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public global::AudibleUtilities.Widevine.LicenseRequest.Types.RequestType Type {
  get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
  set {
    _hasBits0 |= 1;
    type_ = value;
  }
}
/// <summary>Gets whether the "type" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasType {
  get { return (_hasBits0 & 1) != 0; }
}
/// <summary>Clears the value of the "type" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearType() {
  _hasBits0 &= ~1;
}

/// <summary>Field number for the "request_time" field.</summary>
public const int RequestTimeFieldNumber = 4;
private readonly static long RequestTimeDefaultValue = 0L;

private long requestTime_;
/// <summary>
/// Time of the request in seconds (UTC) as set by the client.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public long RequestTime {
  get { if ((_hasBits0 & 2) != 0) { return requestTime_; } else { return RequestTimeDefaultValue; } }
  set {
    _hasBits0 |= 2;
    requestTime_ = value;
  }
}
/// <summary>Gets whether the "request_time" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasRequestTime {
  get { return (_hasBits0 & 2) != 0; }
}
/// <summary>Clears the value of the "request_time" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearRequestTime() {
  _hasBits0 &= ~2;
}

/// <summary>Field number for the "key_control_nonce_deprecated" field.</summary>
public const int KeyControlNonceDeprecatedFieldNumber = 5;
private readonly static pb::ByteString KeyControlNonceDeprecatedDefaultValue = pb::ByteString.Empty;

private pb::ByteString keyControlNonceDeprecated_;
/// <summary>
/// Old-style decimal-encoded string key control nonce.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString KeyControlNonceDeprecated {
  get { return keyControlNonceDeprecated_ ?? KeyControlNonceDeprecatedDefaultValue; }
  set {
    keyControlNonceDeprecated_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "key_control_nonce_deprecated" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasKeyControlNonceDeprecated {
  get { return keyControlNonceDeprecated_ != null; }
}
/// <summary>Clears the value of the "key_control_nonce_deprecated" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearKeyControlNonceDeprecated() {
  keyControlNonceDeprecated_ = null;
}

/// <summary>Field number for the "protocol_version" field.</summary>
public const int ProtocolVersionFieldNumber = 6;
private readonly static global::AudibleUtilities.Widevine.ProtocolVersion ProtocolVersionDefaultValue = global::AudibleUtilities.Widevine.ProtocolVersion.Version20;

private global::AudibleUtilities.Widevine.ProtocolVersion protocolVersion_;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public global::AudibleUtilities.Widevine.ProtocolVersion ProtocolVersion {
  get { if ((_hasBits0 & 4) != 0) { return protocolVersion_; } else { return ProtocolVersionDefaultValue; } }
  set {
    _hasBits0 |= 4;
    protocolVersion_ = value;
  }
}
/// <summary>Gets whether the "protocol_version" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasProtocolVersion {
  get { return (_hasBits0 & 4) != 0; }
}
/// <summary>Clears the value of the "protocol_version" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearProtocolVersion() {
  _hasBits0 &= ~4;
}

/// <summary>Field number for the "key_control_nonce" field.</summary>
public const int KeyControlNonceFieldNumber = 7;
private readonly static uint KeyControlNonceDefaultValue = 0;

private uint keyControlNonce_;
/// <summary>
/// New-style uint32 key control nonce, please use instead of
/// key_control_nonce_deprecated.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public uint KeyControlNonce {
  get { if ((_hasBits0 & 8) != 0) { return keyControlNonce_; } else { return KeyControlNonceDefaultValue; } }
  set {
    _hasBits0 |= 8;
    keyControlNonce_ = value;
  }
}
/// <summary>Gets whether the "key_control_nonce" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasKeyControlNonce {
  get { return (_hasBits0 & 8) != 0; }
}
/// <summary>Clears the value of the "key_control_nonce" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearKeyControlNonce() {
  _hasBits0 &= ~8;
}

/// <summary>Field number for the "encrypted_client_id" field.</summary>
public const int EncryptedClientIdFieldNumber = 8;
private global::AudibleUtilities.Widevine.EncryptedClientIdentification encryptedClientId_;
/// <summary>
/// Encrypted ClientIdentification message, used for privacy purposes.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public global::AudibleUtilities.Widevine.EncryptedClientIdentification EncryptedClientId {
  get { return encryptedClientId_; }
  set {
    encryptedClientId_ = value;
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override bool Equals(object other) {
  return Equals(other as LicenseRequest);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool Equals(LicenseRequest other) {
  if (ReferenceEquals(other, null)) {
    return false;
  }
  if (ReferenceEquals(other, this)) {
    return true;
  }
  if (!object.Equals(ClientId, other.ClientId)) return false;
  if (!object.Equals(ContentId, other.ContentId)) return false;
  if (Type != other.Type) return false;
  if (RequestTime != other.RequestTime) return false;
  if (KeyControlNonceDeprecated != other.KeyControlNonceDeprecated) return false;
  if (ProtocolVersion != other.ProtocolVersion) return false;
  if (KeyControlNonce != other.KeyControlNonce) return false;
  if (!object.Equals(EncryptedClientId, other.EncryptedClientId)) return false;
  return Equals(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override int GetHashCode() {
  int hash = 1;
  if (clientId_ != null) hash ^= ClientId.GetHashCode();
  if (contentId_ != null) hash ^= ContentId.GetHashCode();
  if (HasType) hash ^= Type.GetHashCode();
  if (HasRequestTime) hash ^= RequestTime.GetHashCode();
  if (HasKeyControlNonceDeprecated) hash ^= KeyControlNonceDeprecated.GetHashCode();
  if (HasProtocolVersion) hash ^= ProtocolVersion.GetHashCode();
  if (HasKeyControlNonce) hash ^= KeyControlNonce.GetHashCode();
  if (encryptedClientId_ != null) hash ^= EncryptedClientId.GetHashCode();
  if (_unknownFields != null) {
    hash ^= _unknownFields.GetHashCode();
  }
  return hash;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override string ToString() {
  return pb::JsonFormatter.ToDiagnosticString(this);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void WriteTo(pb::CodedOutputStream output) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  output.WriteRawMessage(this);
#else
  if (clientId_ != null) {
    output.WriteRawTag(10);
    output.WriteMessage(ClientId);
  }
  if (contentId_ != null) {
    output.WriteRawTag(18);
    output.WriteMessage(ContentId);
  }
  if (HasType) {
    output.WriteRawTag(24);
    output.WriteEnum((int) Type);
  }
  if (HasRequestTime) {
    output.WriteRawTag(32);
    output.WriteInt64(RequestTime);
  }
  if (HasKeyControlNonceDeprecated) {
    output.WriteRawTag(42);
    output.WriteBytes(KeyControlNonceDeprecated);
  }
  if (HasProtocolVersion) {
    output.WriteRawTag(48);
    output.WriteEnum((int) ProtocolVersion);
  }
  if (HasKeyControlNonce) {
    output.WriteRawTag(56);
    output.WriteUInt32(KeyControlNonce);
  }
  if (encryptedClientId_ != null) {
    output.WriteRawTag(66);
    output.WriteMessage(EncryptedClientId);
  }
  if (_unknownFields != null) {
    _unknownFields.WriteTo(output);
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
  if (clientId_ != null) {
    output.WriteRawTag(10);
    output.WriteMessage(ClientId);
  }
  if (contentId_ != null) {
    output.WriteRawTag(18);
    output.WriteMessage(ContentId);
  }
  if (HasType) {
    output.WriteRawTag(24);
    output.WriteEnum((int) Type);
  }
  if (HasRequestTime) {
    output.WriteRawTag(32);
    output.WriteInt64(RequestTime);
  }
  if (HasKeyControlNonceDeprecated) {
    output.WriteRawTag(42);
    output.WriteBytes(KeyControlNonceDeprecated);
  }
  if (HasProtocolVersion) {
    output.WriteRawTag(48);
    output.WriteEnum((int) ProtocolVersion);
  }
  if (HasKeyControlNonce) {
    output.WriteRawTag(56);
    output.WriteUInt32(KeyControlNonce);
  }
  if (encryptedClientId_ != null) {
    output.WriteRawTag(66);
    output.WriteMessage(EncryptedClientId);
  }
  if (_unknownFields != null) {
    _unknownFields.WriteTo(ref output);
  }
}
#endif

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public int CalculateSize() {
  int size = 0;
  if (clientId_ != null) {
    size += 1 + pb::CodedOutputStream.ComputeMessageSize(ClientId);
  }
  if (contentId_ != null) {
    size += 1 + pb::CodedOutputStream.ComputeMessageSize(ContentId);
  }
  if (HasType) {
    size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
  }
  if (HasRequestTime) {
    size += 1 + pb::CodedOutputStream.ComputeInt64Size(RequestTime);
  }
  if (HasKeyControlNonceDeprecated) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(KeyControlNonceDeprecated);
  }
  if (HasProtocolVersion) {
    size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ProtocolVersion);
  }
  if (HasKeyControlNonce) {
    size += 1 + pb::CodedOutputStream.ComputeUInt32Size(KeyControlNonce);
  }
  if (encryptedClientId_ != null) {
    size += 1 + pb::CodedOutputStream.ComputeMessageSize(EncryptedClientId);
  }
  if (_unknownFields != null) {
    size += _unknownFields.CalculateSize();
  }
  return size;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(LicenseRequest other) {
  if (other == null) {
    return;
  }
  if (other.clientId_ != null) {
    if (clientId_ == null) {
      ClientId = new global::AudibleUtilities.Widevine.ClientIdentification();
    }
    ClientId.MergeFrom(other.ClientId);
  }
  if (other.contentId_ != null) {
    if (contentId_ == null) {
      ContentId = new global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification();
    }
    ContentId.MergeFrom(other.ContentId);
  }
  if (other.HasType) {
    Type = other.Type;
  }
  if (other.HasRequestTime) {
    RequestTime = other.RequestTime;
  }
  if (other.HasKeyControlNonceDeprecated) {
    KeyControlNonceDeprecated = other.KeyControlNonceDeprecated;
  }
  if (other.HasProtocolVersion) {
    ProtocolVersion = other.ProtocolVersion;
  }
  if (other.HasKeyControlNonce) {
    KeyControlNonce = other.KeyControlNonce;
  }
  if (other.encryptedClientId_ != null) {
    if (encryptedClientId_ == null) {
      EncryptedClientId = new global::AudibleUtilities.Widevine.EncryptedClientIdentification();
    }
    EncryptedClientId.MergeFrom(other.EncryptedClientId);
  }
  _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(pb::CodedInputStream input) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  input.ReadRawMessage(this);
#else
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
        break;
      case 10: {
        if (clientId_ == null) {
          ClientId = new global::AudibleUtilities.Widevine.ClientIdentification();
        }
        input.ReadMessage(ClientId);
        break;
      }
      case 18: {
        if (contentId_ == null) {
          ContentId = new global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification();
        }
        input.ReadMessage(ContentId);
        break;
      }
      case 24: {
        Type = (global::AudibleUtilities.Widevine.LicenseRequest.Types.RequestType) input.ReadEnum();
        break;
      }
      case 32: {
        RequestTime = input.ReadInt64();
        break;
      }
      case 42: {
        KeyControlNonceDeprecated = input.ReadBytes();
        break;
      }
      case 48: {
        ProtocolVersion = (global::AudibleUtilities.Widevine.ProtocolVersion) input.ReadEnum();
        break;
      }
      case 56: {
        KeyControlNonce = input.ReadUInt32();
        break;
      }
      case 66: {
        if (encryptedClientId_ == null) {
          EncryptedClientId = new global::AudibleUtilities.Widevine.EncryptedClientIdentification();
        }
        input.ReadMessage(EncryptedClientId);
        break;
      }
    }
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
        break;
      case 10: {
        if (clientId_ == null) {
          ClientId = new global::AudibleUtilities.Widevine.ClientIdentification();
        }
        input.ReadMessage(ClientId);
        break;
      }
      case 18: {
        if (contentId_ == null) {
          ContentId = new global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification();
        }
        input.ReadMessage(ContentId);
        break;
      }
      case 24: {
        Type = (global::AudibleUtilities.Widevine.LicenseRequest.Types.RequestType) input.ReadEnum();
        break;
      }
      case 32: {
        RequestTime = input.ReadInt64();
        break;
      }
      case 42: {
        KeyControlNonceDeprecated = input.ReadBytes();
        break;
      }
      case 48: {
        ProtocolVersion = (global::AudibleUtilities.Widevine.ProtocolVersion) input.ReadEnum();
        break;
      }
      case 56: {
        KeyControlNonce = input.ReadUInt32();
        break;
      }
      case 66: {
        if (encryptedClientId_ == null) {
          EncryptedClientId = new global::AudibleUtilities.Widevine.EncryptedClientIdentification();
        }
        input.ReadMessage(EncryptedClientId);
        break;
      }
    }
  }
}
#endif

#region Nested types
/// <summary>Container for nested types declared in the LicenseRequest message type.</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static partial class Types {
  internal enum RequestType {
    [pbr::OriginalName("NEW")] New = 1,
    [pbr::OriginalName("RENEWAL")] Renewal = 2,
    [pbr::OriginalName("RELEASE")] Release = 3,
  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  internal sealed partial class ContentIdentification : pb::IMessage<ContentIdentification>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ContentIdentification> _parser = new pb::MessageParser<ContentIdentification>(() => new ContentIdentification());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ContentIdentification> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AudibleUtilities.Widevine.LicenseRequest.Descriptor.NestedTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContentIdentification() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContentIdentification(ContentIdentification other) : this() {
      switch (other.ContentIdVariantCase) {
        case ContentIdVariantOneofCase.WidevinePsshData:
          WidevinePsshData = other.WidevinePsshData.Clone();
          break;
        case ContentIdVariantOneofCase.WebmKeyId:
          WebmKeyId = other.WebmKeyId.Clone();
          break;
        case ContentIdVariantOneofCase.ExistingLicense:
          ExistingLicense = other.ExistingLicense.Clone();
          break;
        case ContentIdVariantOneofCase.InitData:
          InitData = other.InitData.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContentIdentification Clone() {
      return new ContentIdentification(this);
    }

    /// <summary>Field number for the "widevine_pssh_data" field.</summary>
    public const int WidevinePsshDataFieldNumber = 1;
    /// <summary>
    /// Exactly one of these must be present.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.WidevinePsshData WidevinePsshData {
      get { return contentIdVariantCase_ == ContentIdVariantOneofCase.WidevinePsshData ? (global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.WidevinePsshData) contentIdVariant_ : null; }
      set {
        contentIdVariant_ = value;
        contentIdVariantCase_ = value == null ? ContentIdVariantOneofCase.None : ContentIdVariantOneofCase.WidevinePsshData;
      }
    }

    /// <summary>Field number for the "webm_key_id" field.</summary>
    public const int WebmKeyIdFieldNumber = 2;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.WebmKeyId WebmKeyId {
      get { return contentIdVariantCase_ == ContentIdVariantOneofCase.WebmKeyId ? (global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.WebmKeyId) contentIdVariant_ : null; }
      set {
        contentIdVariant_ = value;
        contentIdVariantCase_ = value == null ? ContentIdVariantOneofCase.None : ContentIdVariantOneofCase.WebmKeyId;
      }
    }

    /// <summary>Field number for the "existing_license" field.</summary>
    public const int ExistingLicenseFieldNumber = 3;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.ExistingLicense ExistingLicense {
      get { return contentIdVariantCase_ == ContentIdVariantOneofCase.ExistingLicense ? (global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.ExistingLicense) contentIdVariant_ : null; }
      set {
        contentIdVariant_ = value;
        contentIdVariantCase_ = value == null ? ContentIdVariantOneofCase.None : ContentIdVariantOneofCase.ExistingLicense;
      }
    }

    /// <summary>Field number for the "init_data" field.</summary>
    public const int InitDataFieldNumber = 4;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.InitData InitData {
      get { return contentIdVariantCase_ == ContentIdVariantOneofCase.InitData ? (global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.InitData) contentIdVariant_ : null; }
      set {
        contentIdVariant_ = value;
        contentIdVariantCase_ = value == null ? ContentIdVariantOneofCase.None : ContentIdVariantOneofCase.InitData;
      }
    }

    private object contentIdVariant_;
    /// <summary>Enum of possible cases for the "content_id_variant" oneof.</summary>
    public enum ContentIdVariantOneofCase {
      None = 0,
      WidevinePsshData = 1,
      WebmKeyId = 2,
      ExistingLicense = 3,
      InitData = 4,
    }
    private ContentIdVariantOneofCase contentIdVariantCase_ = ContentIdVariantOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContentIdVariantOneofCase ContentIdVariantCase {
      get { return contentIdVariantCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearContentIdVariant() {
      contentIdVariantCase_ = ContentIdVariantOneofCase.None;
      contentIdVariant_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ContentIdentification);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ContentIdentification other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(WidevinePsshData, other.WidevinePsshData)) return false;
      if (!object.Equals(WebmKeyId, other.WebmKeyId)) return false;
      if (!object.Equals(ExistingLicense, other.ExistingLicense)) return false;
      if (!object.Equals(InitData, other.InitData)) return false;
      if (ContentIdVariantCase != other.ContentIdVariantCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (contentIdVariantCase_ == ContentIdVariantOneofCase.WidevinePsshData) hash ^= WidevinePsshData.GetHashCode();
      if (contentIdVariantCase_ == ContentIdVariantOneofCase.WebmKeyId) hash ^= WebmKeyId.GetHashCode();
      if (contentIdVariantCase_ == ContentIdVariantOneofCase.ExistingLicense) hash ^= ExistingLicense.GetHashCode();
      if (contentIdVariantCase_ == ContentIdVariantOneofCase.InitData) hash ^= InitData.GetHashCode();
      hash ^= (int) contentIdVariantCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (contentIdVariantCase_ == ContentIdVariantOneofCase.WidevinePsshData) {
        output.WriteRawTag(10);
        output.WriteMessage(WidevinePsshData);
      }
      if (contentIdVariantCase_ == ContentIdVariantOneofCase.WebmKeyId) {
        output.WriteRawTag(18);
        output.WriteMessage(WebmKeyId);
      }
      if (contentIdVariantCase_ == ContentIdVariantOneofCase.ExistingLicense) {
        output.WriteRawTag(26);
        output.WriteMessage(ExistingLicense);
      }
      if (contentIdVariantCase_ == ContentIdVariantOneofCase.InitData) {
        output.WriteRawTag(34);
        output.WriteMessage(InitData);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (contentIdVariantCase_ == ContentIdVariantOneofCase.WidevinePsshData) {
        output.WriteRawTag(10);
        output.WriteMessage(WidevinePsshData);
      }
      if (contentIdVariantCase_ == ContentIdVariantOneofCase.WebmKeyId) {
        output.WriteRawTag(18);
        output.WriteMessage(WebmKeyId);
      }
      if (contentIdVariantCase_ == ContentIdVariantOneofCase.ExistingLicense) {
        output.WriteRawTag(26);
        output.WriteMessage(ExistingLicense);
      }
      if (contentIdVariantCase_ == ContentIdVariantOneofCase.InitData) {
        output.WriteRawTag(34);
        output.WriteMessage(InitData);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (contentIdVariantCase_ == ContentIdVariantOneofCase.WidevinePsshData) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WidevinePsshData);
      }
      if (contentIdVariantCase_ == ContentIdVariantOneofCase.WebmKeyId) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WebmKeyId);
      }
      if (contentIdVariantCase_ == ContentIdVariantOneofCase.ExistingLicense) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExistingLicense);
      }
      if (contentIdVariantCase_ == ContentIdVariantOneofCase.InitData) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(InitData);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ContentIdentification other) {
      if (other == null) {
        return;
      }
      switch (other.ContentIdVariantCase) {
        case ContentIdVariantOneofCase.WidevinePsshData:
          if (WidevinePsshData == null) {
            WidevinePsshData = new global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.WidevinePsshData();
          }
          WidevinePsshData.MergeFrom(other.WidevinePsshData);
          break;
        case ContentIdVariantOneofCase.WebmKeyId:
          if (WebmKeyId == null) {
            WebmKeyId = new global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.WebmKeyId();
          }
          WebmKeyId.MergeFrom(other.WebmKeyId);
          break;
        case ContentIdVariantOneofCase.ExistingLicense:
          if (ExistingLicense == null) {
            ExistingLicense = new global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.ExistingLicense();
          }
          ExistingLicense.MergeFrom(other.ExistingLicense);
          break;
        case ContentIdVariantOneofCase.InitData:
          if (InitData == null) {
            InitData = new global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.InitData();
          }
          InitData.MergeFrom(other.InitData);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.WidevinePsshData subBuilder = new global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.WidevinePsshData();
            if (contentIdVariantCase_ == ContentIdVariantOneofCase.WidevinePsshData) {
              subBuilder.MergeFrom(WidevinePsshData);
            }
            input.ReadMessage(subBuilder);
            WidevinePsshData = subBuilder;
            break;
          }
          case 18: {
            global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.WebmKeyId subBuilder = new global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.WebmKeyId();
            if (contentIdVariantCase_ == ContentIdVariantOneofCase.WebmKeyId) {
              subBuilder.MergeFrom(WebmKeyId);
            }
            input.ReadMessage(subBuilder);
            WebmKeyId = subBuilder;
            break;
          }
          case 26: {
            global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.ExistingLicense subBuilder = new global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.ExistingLicense();
            if (contentIdVariantCase_ == ContentIdVariantOneofCase.ExistingLicense) {
              subBuilder.MergeFrom(ExistingLicense);
            }
            input.ReadMessage(subBuilder);
            ExistingLicense = subBuilder;
            break;
          }
          case 34: {
            global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.InitData subBuilder = new global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.InitData();
            if (contentIdVariantCase_ == ContentIdVariantOneofCase.InitData) {
              subBuilder.MergeFrom(InitData);
            }
            input.ReadMessage(subBuilder);
            InitData = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.WidevinePsshData subBuilder = new global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.WidevinePsshData();
            if (contentIdVariantCase_ == ContentIdVariantOneofCase.WidevinePsshData) {
              subBuilder.MergeFrom(WidevinePsshData);
            }
            input.ReadMessage(subBuilder);
            WidevinePsshData = subBuilder;
            break;
          }
          case 18: {
            global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.WebmKeyId subBuilder = new global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.WebmKeyId();
            if (contentIdVariantCase_ == ContentIdVariantOneofCase.WebmKeyId) {
              subBuilder.MergeFrom(WebmKeyId);
            }
            input.ReadMessage(subBuilder);
            WebmKeyId = subBuilder;
            break;
          }
          case 26: {
            global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.ExistingLicense subBuilder = new global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.ExistingLicense();
            if (contentIdVariantCase_ == ContentIdVariantOneofCase.ExistingLicense) {
              subBuilder.MergeFrom(ExistingLicense);
            }
            input.ReadMessage(subBuilder);
            ExistingLicense = subBuilder;
            break;
          }
          case 34: {
            global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.InitData subBuilder = new global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.InitData();
            if (contentIdVariantCase_ == ContentIdVariantOneofCase.InitData) {
              subBuilder.MergeFrom(InitData);
            }
            input.ReadMessage(subBuilder);
            InitData = subBuilder;
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ContentIdentification message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      internal sealed partial class WidevinePsshData : pb::IMessage<WidevinePsshData>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<WidevinePsshData> _parser = new pb::MessageParser<WidevinePsshData>(() => new WidevinePsshData());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<WidevinePsshData> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public WidevinePsshData() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public WidevinePsshData(WidevinePsshData other) : this() {
          _hasBits0 = other._hasBits0;
          psshData_ = other.psshData_.Clone();
          licenseType_ = other.licenseType_;
          requestId_ = other.requestId_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public WidevinePsshData Clone() {
          return new WidevinePsshData(this);
        }

        /// <summary>Field number for the "pssh_data" field.</summary>
        public const int PsshDataFieldNumber = 1;
        private static readonly pb::FieldCodec<pb::ByteString> _repeated_psshData_codec
            = pb::FieldCodec.ForBytes(10);
        private readonly pbc::RepeatedField<pb::ByteString> psshData_ = new pbc::RepeatedField<pb::ByteString>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<pb::ByteString> PsshData {
          get { return psshData_; }
        }

        /// <summary>Field number for the "license_type" field.</summary>
        public const int LicenseTypeFieldNumber = 2;
        private readonly static global::AudibleUtilities.Widevine.LicenseType LicenseTypeDefaultValue = global::AudibleUtilities.Widevine.LicenseType.Streaming;

        private global::AudibleUtilities.Widevine.LicenseType licenseType_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::AudibleUtilities.Widevine.LicenseType LicenseType {
          get { if ((_hasBits0 & 1) != 0) { return licenseType_; } else { return LicenseTypeDefaultValue; } }
          set {
            _hasBits0 |= 1;
            licenseType_ = value;
          }
        }
        /// <summary>Gets whether the "license_type" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasLicenseType {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "license_type" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLicenseType() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "request_id" field.</summary>
        public const int RequestIdFieldNumber = 3;
        private readonly static pb::ByteString RequestIdDefaultValue = pb::ByteString.Empty;

        private pb::ByteString requestId_;
        /// <summary>
        /// Opaque, client-specified.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pb::ByteString RequestId {
          get { return requestId_ ?? RequestIdDefaultValue; }
          set {
            requestId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "request_id" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasRequestId {
          get { return requestId_ != null; }
        }
        /// <summary>Clears the value of the "request_id" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearRequestId() {
          requestId_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as WidevinePsshData);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(WidevinePsshData other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!psshData_.Equals(other.psshData_)) return false;
          if (LicenseType != other.LicenseType) return false;
          if (RequestId != other.RequestId) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= psshData_.GetHashCode();
          if (HasLicenseType) hash ^= LicenseType.GetHashCode();
          if (HasRequestId) hash ^= RequestId.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          psshData_.WriteTo(output, _repeated_psshData_codec);
          if (HasLicenseType) {
            output.WriteRawTag(16);
            output.WriteEnum((int) LicenseType);
          }
          if (HasRequestId) {
            output.WriteRawTag(26);
            output.WriteBytes(RequestId);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          psshData_.WriteTo(ref output, _repeated_psshData_codec);
          if (HasLicenseType) {
            output.WriteRawTag(16);
            output.WriteEnum((int) LicenseType);
          }
          if (HasRequestId) {
            output.WriteRawTag(26);
            output.WriteBytes(RequestId);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          size += psshData_.CalculateSize(_repeated_psshData_codec);
          if (HasLicenseType) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LicenseType);
          }
          if (HasRequestId) {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(RequestId);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(WidevinePsshData other) {
          if (other == null) {
            return;
          }
          psshData_.Add(other.psshData_);
          if (other.HasLicenseType) {
            LicenseType = other.LicenseType;
          }
          if (other.HasRequestId) {
            RequestId = other.RequestId;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                psshData_.AddEntriesFrom(input, _repeated_psshData_codec);
                break;
              }
              case 16: {
                LicenseType = (global::AudibleUtilities.Widevine.LicenseType) input.ReadEnum();
                break;
              }
              case 26: {
                RequestId = input.ReadBytes();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                psshData_.AddEntriesFrom(ref input, _repeated_psshData_codec);
                break;
              }
              case 16: {
                LicenseType = (global::AudibleUtilities.Widevine.LicenseType) input.ReadEnum();
                break;
              }
              case 26: {
                RequestId = input.ReadBytes();
                break;
              }
            }
          }
        }
        #endif

      }

      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      internal sealed partial class WebmKeyId : pb::IMessage<WebmKeyId>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<WebmKeyId> _parser = new pb::MessageParser<WebmKeyId>(() => new WebmKeyId());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<WebmKeyId> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public WebmKeyId() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public WebmKeyId(WebmKeyId other) : this() {
          _hasBits0 = other._hasBits0;
          header_ = other.header_;
          licenseType_ = other.licenseType_;
          requestId_ = other.requestId_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public WebmKeyId Clone() {
          return new WebmKeyId(this);
        }

        /// <summary>Field number for the "header" field.</summary>
        public const int HeaderFieldNumber = 1;
        private readonly static pb::ByteString HeaderDefaultValue = pb::ByteString.Empty;

        private pb::ByteString header_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pb::ByteString Header {
          get { return header_ ?? HeaderDefaultValue; }
          set {
            header_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "header" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasHeader {
          get { return header_ != null; }
        }
        /// <summary>Clears the value of the "header" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearHeader() {
          header_ = null;
        }

        /// <summary>Field number for the "license_type" field.</summary>
        public const int LicenseTypeFieldNumber = 2;
        private readonly static global::AudibleUtilities.Widevine.LicenseType LicenseTypeDefaultValue = global::AudibleUtilities.Widevine.LicenseType.Streaming;

        private global::AudibleUtilities.Widevine.LicenseType licenseType_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::AudibleUtilities.Widevine.LicenseType LicenseType {
          get { if ((_hasBits0 & 1) != 0) { return licenseType_; } else { return LicenseTypeDefaultValue; } }
          set {
            _hasBits0 |= 1;
            licenseType_ = value;
          }
        }
        /// <summary>Gets whether the "license_type" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasLicenseType {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "license_type" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLicenseType() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "request_id" field.</summary>
        public const int RequestIdFieldNumber = 3;
        private readonly static pb::ByteString RequestIdDefaultValue = pb::ByteString.Empty;

        private pb::ByteString requestId_;
        /// <summary>
        /// Opaque, client-specified.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pb::ByteString RequestId {
          get { return requestId_ ?? RequestIdDefaultValue; }
          set {
            requestId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "request_id" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasRequestId {
          get { return requestId_ != null; }
        }
        /// <summary>Clears the value of the "request_id" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearRequestId() {
          requestId_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as WebmKeyId);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(WebmKeyId other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Header != other.Header) return false;
          if (LicenseType != other.LicenseType) return false;
          if (RequestId != other.RequestId) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasHeader) hash ^= Header.GetHashCode();
          if (HasLicenseType) hash ^= LicenseType.GetHashCode();
          if (HasRequestId) hash ^= RequestId.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasHeader) {
            output.WriteRawTag(10);
            output.WriteBytes(Header);
          }
          if (HasLicenseType) {
            output.WriteRawTag(16);
            output.WriteEnum((int) LicenseType);
          }
          if (HasRequestId) {
            output.WriteRawTag(26);
            output.WriteBytes(RequestId);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasHeader) {
            output.WriteRawTag(10);
            output.WriteBytes(Header);
          }
          if (HasLicenseType) {
            output.WriteRawTag(16);
            output.WriteEnum((int) LicenseType);
          }
          if (HasRequestId) {
            output.WriteRawTag(26);
            output.WriteBytes(RequestId);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasHeader) {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(Header);
          }
          if (HasLicenseType) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LicenseType);
          }
          if (HasRequestId) {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(RequestId);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(WebmKeyId other) {
          if (other == null) {
            return;
          }
          if (other.HasHeader) {
            Header = other.Header;
          }
          if (other.HasLicenseType) {
            LicenseType = other.LicenseType;
          }
          if (other.HasRequestId) {
            RequestId = other.RequestId;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Header = input.ReadBytes();
                break;
              }
              case 16: {
                LicenseType = (global::AudibleUtilities.Widevine.LicenseType) input.ReadEnum();
                break;
              }
              case 26: {
                RequestId = input.ReadBytes();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Header = input.ReadBytes();
                break;
              }
              case 16: {
                LicenseType = (global::AudibleUtilities.Widevine.LicenseType) input.ReadEnum();
                break;
              }
              case 26: {
                RequestId = input.ReadBytes();
                break;
              }
            }
          }
        }
        #endif

      }

      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      internal sealed partial class ExistingLicense : pb::IMessage<ExistingLicense>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ExistingLicense> _parser = new pb::MessageParser<ExistingLicense>(() => new ExistingLicense());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<ExistingLicense> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ExistingLicense() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ExistingLicense(ExistingLicense other) : this() {
          _hasBits0 = other._hasBits0;
          licenseId_ = other.licenseId_ != null ? other.licenseId_.Clone() : null;
          secondsSinceStarted_ = other.secondsSinceStarted_;
          secondsSinceLastPlayed_ = other.secondsSinceLastPlayed_;
          sessionUsageTableEntry_ = other.sessionUsageTableEntry_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ExistingLicense Clone() {
          return new ExistingLicense(this);
        }

        /// <summary>Field number for the "license_id" field.</summary>
        public const int LicenseIdFieldNumber = 1;
        private global::AudibleUtilities.Widevine.LicenseIdentification licenseId_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::AudibleUtilities.Widevine.LicenseIdentification LicenseId {
          get { return licenseId_; }
          set {
            licenseId_ = value;
          }
        }

        /// <summary>Field number for the "seconds_since_started" field.</summary>
        public const int SecondsSinceStartedFieldNumber = 2;
        private readonly static long SecondsSinceStartedDefaultValue = 0L;

        private long secondsSinceStarted_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public long SecondsSinceStarted {
          get { if ((_hasBits0 & 1) != 0) { return secondsSinceStarted_; } else { return SecondsSinceStartedDefaultValue; } }
          set {
            _hasBits0 |= 1;
            secondsSinceStarted_ = value;
          }
        }
        /// <summary>Gets whether the "seconds_since_started" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasSecondsSinceStarted {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "seconds_since_started" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearSecondsSinceStarted() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "seconds_since_last_played" field.</summary>
        public const int SecondsSinceLastPlayedFieldNumber = 3;
        private readonly static long SecondsSinceLastPlayedDefaultValue = 0L;

        private long secondsSinceLastPlayed_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public long SecondsSinceLastPlayed {
          get { if ((_hasBits0 & 2) != 0) { return secondsSinceLastPlayed_; } else { return SecondsSinceLastPlayedDefaultValue; } }
          set {
            _hasBits0 |= 2;
            secondsSinceLastPlayed_ = value;
          }
        }
        /// <summary>Gets whether the "seconds_since_last_played" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasSecondsSinceLastPlayed {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "seconds_since_last_played" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearSecondsSinceLastPlayed() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "session_usage_table_entry" field.</summary>
        public const int SessionUsageTableEntryFieldNumber = 4;
        private readonly static pb::ByteString SessionUsageTableEntryDefaultValue = pb::ByteString.Empty;

        private pb::ByteString sessionUsageTableEntry_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pb::ByteString SessionUsageTableEntry {
          get { return sessionUsageTableEntry_ ?? SessionUsageTableEntryDefaultValue; }
          set {
            sessionUsageTableEntry_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "session_usage_table_entry" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasSessionUsageTableEntry {
          get { return sessionUsageTableEntry_ != null; }
        }
        /// <summary>Clears the value of the "session_usage_table_entry" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearSessionUsageTableEntry() {
          sessionUsageTableEntry_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as ExistingLicense);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(ExistingLicense other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(LicenseId, other.LicenseId)) return false;
          if (SecondsSinceStarted != other.SecondsSinceStarted) return false;
          if (SecondsSinceLastPlayed != other.SecondsSinceLastPlayed) return false;
          if (SessionUsageTableEntry != other.SessionUsageTableEntry) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (licenseId_ != null) hash ^= LicenseId.GetHashCode();
          if (HasSecondsSinceStarted) hash ^= SecondsSinceStarted.GetHashCode();
          if (HasSecondsSinceLastPlayed) hash ^= SecondsSinceLastPlayed.GetHashCode();
          if (HasSessionUsageTableEntry) hash ^= SessionUsageTableEntry.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (licenseId_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(LicenseId);
          }
          if (HasSecondsSinceStarted) {
            output.WriteRawTag(16);
            output.WriteInt64(SecondsSinceStarted);
          }
          if (HasSecondsSinceLastPlayed) {
            output.WriteRawTag(24);
            output.WriteInt64(SecondsSinceLastPlayed);
          }
          if (HasSessionUsageTableEntry) {
            output.WriteRawTag(34);
            output.WriteBytes(SessionUsageTableEntry);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (licenseId_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(LicenseId);
          }
          if (HasSecondsSinceStarted) {
            output.WriteRawTag(16);
            output.WriteInt64(SecondsSinceStarted);
          }
          if (HasSecondsSinceLastPlayed) {
            output.WriteRawTag(24);
            output.WriteInt64(SecondsSinceLastPlayed);
          }
          if (HasSessionUsageTableEntry) {
            output.WriteRawTag(34);
            output.WriteBytes(SessionUsageTableEntry);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (licenseId_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(LicenseId);
          }
          if (HasSecondsSinceStarted) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(SecondsSinceStarted);
          }
          if (HasSecondsSinceLastPlayed) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(SecondsSinceLastPlayed);
          }
          if (HasSessionUsageTableEntry) {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(SessionUsageTableEntry);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(ExistingLicense other) {
          if (other == null) {
            return;
          }
          if (other.licenseId_ != null) {
            if (licenseId_ == null) {
              LicenseId = new global::AudibleUtilities.Widevine.LicenseIdentification();
            }
            LicenseId.MergeFrom(other.LicenseId);
          }
          if (other.HasSecondsSinceStarted) {
            SecondsSinceStarted = other.SecondsSinceStarted;
          }
          if (other.HasSecondsSinceLastPlayed) {
            SecondsSinceLastPlayed = other.SecondsSinceLastPlayed;
          }
          if (other.HasSessionUsageTableEntry) {
            SessionUsageTableEntry = other.SessionUsageTableEntry;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (licenseId_ == null) {
                  LicenseId = new global::AudibleUtilities.Widevine.LicenseIdentification();
                }
                input.ReadMessage(LicenseId);
                break;
              }
              case 16: {
                SecondsSinceStarted = input.ReadInt64();
                break;
              }
              case 24: {
                SecondsSinceLastPlayed = input.ReadInt64();
                break;
              }
              case 34: {
                SessionUsageTableEntry = input.ReadBytes();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (licenseId_ == null) {
                  LicenseId = new global::AudibleUtilities.Widevine.LicenseIdentification();
                }
                input.ReadMessage(LicenseId);
                break;
              }
              case 16: {
                SecondsSinceStarted = input.ReadInt64();
                break;
              }
              case 24: {
                SecondsSinceLastPlayed = input.ReadInt64();
                break;
              }
              case 34: {
                SessionUsageTableEntry = input.ReadBytes();
                break;
              }
            }
          }
        }
        #endif

      }

      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      internal sealed partial class InitData : pb::IMessage<InitData>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<InitData> _parser = new pb::MessageParser<InitData>(() => new InitData());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<InitData> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InitData() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InitData(InitData other) : this() {
          _hasBits0 = other._hasBits0;
          initDataType_ = other.initDataType_;
          initData_ = other.initData_;
          licenseType_ = other.licenseType_;
          requestId_ = other.requestId_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InitData Clone() {
          return new InitData(this);
        }

        /// <summary>Field number for the "init_data_type" field.</summary>
        public const int InitDataTypeFieldNumber = 1;
        private readonly static global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.InitData.Types.InitDataType InitDataTypeDefaultValue = global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.InitData.Types.InitDataType.Cenc;

        private global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.InitData.Types.InitDataType initDataType_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.InitData.Types.InitDataType InitDataType {
          get { if ((_hasBits0 & 1) != 0) { return initDataType_; } else { return InitDataTypeDefaultValue; } }
          set {
            _hasBits0 |= 1;
            initDataType_ = value;
          }
        }
        /// <summary>Gets whether the "init_data_type" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasInitDataType {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "init_data_type" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearInitDataType() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "init_data" field.</summary>
        public const int InitData_FieldNumber = 2;
        private readonly static pb::ByteString InitData_DefaultValue = pb::ByteString.Empty;

        private pb::ByteString initData_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pb::ByteString InitData_ {
          get { return initData_ ?? InitData_DefaultValue; }
          set {
            initData_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "init_data" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasInitData_ {
          get { return initData_ != null; }
        }
        /// <summary>Clears the value of the "init_data" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearInitData_() {
          initData_ = null;
        }

        /// <summary>Field number for the "license_type" field.</summary>
        public const int LicenseTypeFieldNumber = 3;
        private readonly static global::AudibleUtilities.Widevine.LicenseType LicenseTypeDefaultValue = global::AudibleUtilities.Widevine.LicenseType.Streaming;

        private global::AudibleUtilities.Widevine.LicenseType licenseType_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::AudibleUtilities.Widevine.LicenseType LicenseType {
          get { if ((_hasBits0 & 2) != 0) { return licenseType_; } else { return LicenseTypeDefaultValue; } }
          set {
            _hasBits0 |= 2;
            licenseType_ = value;
          }
        }
        /// <summary>Gets whether the "license_type" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasLicenseType {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "license_type" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLicenseType() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "request_id" field.</summary>
        public const int RequestIdFieldNumber = 4;
        private readonly static pb::ByteString RequestIdDefaultValue = pb::ByteString.Empty;

        private pb::ByteString requestId_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pb::ByteString RequestId {
          get { return requestId_ ?? RequestIdDefaultValue; }
          set {
            requestId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "request_id" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasRequestId {
          get { return requestId_ != null; }
        }
        /// <summary>Clears the value of the "request_id" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearRequestId() {
          requestId_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as InitData);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(InitData other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (InitDataType != other.InitDataType) return false;
          if (InitData_ != other.InitData_) return false;
          if (LicenseType != other.LicenseType) return false;
          if (RequestId != other.RequestId) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasInitDataType) hash ^= InitDataType.GetHashCode();
          if (HasInitData_) hash ^= InitData_.GetHashCode();
          if (HasLicenseType) hash ^= LicenseType.GetHashCode();
          if (HasRequestId) hash ^= RequestId.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasInitDataType) {
            output.WriteRawTag(8);
            output.WriteEnum((int) InitDataType);
          }
          if (HasInitData_) {
            output.WriteRawTag(18);
            output.WriteBytes(InitData_);
          }
          if (HasLicenseType) {
            output.WriteRawTag(24);
            output.WriteEnum((int) LicenseType);
          }
          if (HasRequestId) {
            output.WriteRawTag(34);
            output.WriteBytes(RequestId);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasInitDataType) {
            output.WriteRawTag(8);
            output.WriteEnum((int) InitDataType);
          }
          if (HasInitData_) {
            output.WriteRawTag(18);
            output.WriteBytes(InitData_);
          }
          if (HasLicenseType) {
            output.WriteRawTag(24);
            output.WriteEnum((int) LicenseType);
          }
          if (HasRequestId) {
            output.WriteRawTag(34);
            output.WriteBytes(RequestId);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasInitDataType) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) InitDataType);
          }
          if (HasInitData_) {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(InitData_);
          }
          if (HasLicenseType) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LicenseType);
          }
          if (HasRequestId) {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(RequestId);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(InitData other) {
          if (other == null) {
            return;
          }
          if (other.HasInitDataType) {
            InitDataType = other.InitDataType;
          }
          if (other.HasInitData_) {
            InitData_ = other.InitData_;
          }
          if (other.HasLicenseType) {
            LicenseType = other.LicenseType;
          }
          if (other.HasRequestId) {
            RequestId = other.RequestId;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                InitDataType = (global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.InitData.Types.InitDataType) input.ReadEnum();
                break;
              }
              case 18: {
                InitData_ = input.ReadBytes();
                break;
              }
              case 24: {
                LicenseType = (global::AudibleUtilities.Widevine.LicenseType) input.ReadEnum();
                break;
              }
              case 34: {
                RequestId = input.ReadBytes();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                InitDataType = (global::AudibleUtilities.Widevine.LicenseRequest.Types.ContentIdentification.Types.InitData.Types.InitDataType) input.ReadEnum();
                break;
              }
              case 18: {
                InitData_ = input.ReadBytes();
                break;
              }
              case 24: {
                LicenseType = (global::AudibleUtilities.Widevine.LicenseType) input.ReadEnum();
                break;
              }
              case 34: {
                RequestId = input.ReadBytes();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the InitData message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          internal enum InitDataType {
            [pbr::OriginalName("CENC")] Cenc = 1,
            [pbr::OriginalName("WEBM")] Webm = 2,
          }

        }
        #endregion

      }

    }
    #endregion

  }

}
#endregion

}

[global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
internal sealed partial class MetricData : pb::IMessage<MetricData>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  , pb::IBufferMessage
#endif
{
private static readonly pb::MessageParser<MetricData> _parser = new pb::MessageParser<MetricData>(() => new MetricData());
private pb::UnknownFieldSet _unknownFields;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pb::MessageParser<MetricData> Parser { get { return _parser; } }

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pbr::MessageDescriptor Descriptor {
  get { return global::AudibleUtilities.Widevine.LicenseProtocolReflection.Descriptor.MessageTypes[3]; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
pbr::MessageDescriptor pb::IMessage.Descriptor {
  get { return Descriptor; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public MetricData() {
  OnConstruction();
}

partial void OnConstruction();

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public MetricData(MetricData other) : this() {
  stageName_ = other.stageName_;
  metricData_ = other.metricData_.Clone();
  _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public MetricData Clone() {
  return new MetricData(this);
}

/// <summary>Field number for the "stage_name" field.</summary>
public const int StageNameFieldNumber = 1;
private readonly static string StageNameDefaultValue = "";

private string stageName_;
/// <summary>
/// 'stage' that is currently processing the SignedMessage.  Required.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public string StageName {
  get { return stageName_ ?? StageNameDefaultValue; }
  set {
    stageName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "stage_name" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasStageName {
  get { return stageName_ != null; }
}
/// <summary>Clears the value of the "stage_name" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearStageName() {
  stageName_ = null;
}

/// <summary>Field number for the "metric_data" field.</summary>
public const int MetricData_FieldNumber = 2;
private static readonly pb::FieldCodec<global::AudibleUtilities.Widevine.MetricData.Types.TypeValue> _repeated_metricData_codec
    = pb::FieldCodec.ForMessage(18, global::AudibleUtilities.Widevine.MetricData.Types.TypeValue.Parser);
private readonly pbc::RepeatedField<global::AudibleUtilities.Widevine.MetricData.Types.TypeValue> metricData_ = new pbc::RepeatedField<global::AudibleUtilities.Widevine.MetricData.Types.TypeValue>();
/// <summary>
/// metric and associated value.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pbc::RepeatedField<global::AudibleUtilities.Widevine.MetricData.Types.TypeValue> MetricData_ {
  get { return metricData_; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override bool Equals(object other) {
  return Equals(other as MetricData);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool Equals(MetricData other) {
  if (ReferenceEquals(other, null)) {
    return false;
  }
  if (ReferenceEquals(other, this)) {
    return true;
  }
  if (StageName != other.StageName) return false;
  if(!metricData_.Equals(other.metricData_)) return false;
  return Equals(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override int GetHashCode() {
  int hash = 1;
  if (HasStageName) hash ^= StageName.GetHashCode();
  hash ^= metricData_.GetHashCode();
  if (_unknownFields != null) {
    hash ^= _unknownFields.GetHashCode();
  }
  return hash;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override string ToString() {
  return pb::JsonFormatter.ToDiagnosticString(this);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void WriteTo(pb::CodedOutputStream output) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  output.WriteRawMessage(this);
#else
  if (HasStageName) {
    output.WriteRawTag(10);
    output.WriteString(StageName);
  }
  metricData_.WriteTo(output, _repeated_metricData_codec);
  if (_unknownFields != null) {
    _unknownFields.WriteTo(output);
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
  if (HasStageName) {
    output.WriteRawTag(10);
    output.WriteString(StageName);
  }
  metricData_.WriteTo(ref output, _repeated_metricData_codec);
  if (_unknownFields != null) {
    _unknownFields.WriteTo(ref output);
  }
}
#endif

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public int CalculateSize() {
  int size = 0;
  if (HasStageName) {
    size += 1 + pb::CodedOutputStream.ComputeStringSize(StageName);
  }
  size += metricData_.CalculateSize(_repeated_metricData_codec);
  if (_unknownFields != null) {
    size += _unknownFields.CalculateSize();
  }
  return size;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(MetricData other) {
  if (other == null) {
    return;
  }
  if (other.HasStageName) {
    StageName = other.StageName;
  }
  metricData_.Add(other.metricData_);
  _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(pb::CodedInputStream input) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  input.ReadRawMessage(this);
#else
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
        break;
      case 10: {
        StageName = input.ReadString();
        break;
      }
      case 18: {
        metricData_.AddEntriesFrom(input, _repeated_metricData_codec);
        break;
      }
    }
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
        break;
      case 10: {
        StageName = input.ReadString();
        break;
      }
      case 18: {
        metricData_.AddEntriesFrom(ref input, _repeated_metricData_codec);
        break;
      }
    }
  }
}
#endif

#region Nested types
/// <summary>Container for nested types declared in the MetricData message type.</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static partial class Types {
  internal enum MetricType {
    /// <summary>
    /// The time spent in the 'stage', specified in microseconds.
    /// </summary>
    [pbr::OriginalName("LATENCY")] Latency = 1,
    /// <summary>
    /// The UNIX epoch timestamp at which the 'stage' was first accessed in
    /// microseconds.
    /// </summary>
    [pbr::OriginalName("TIMESTAMP")] Timestamp = 2,
  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  internal sealed partial class TypeValue : pb::IMessage<TypeValue>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TypeValue> _parser = new pb::MessageParser<TypeValue>(() => new TypeValue());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TypeValue> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AudibleUtilities.Widevine.MetricData.Descriptor.NestedTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TypeValue() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TypeValue(TypeValue other) : this() {
      _hasBits0 = other._hasBits0;
      type_ = other.type_;
      value_ = other.value_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TypeValue Clone() {
      return new TypeValue(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private readonly static global::AudibleUtilities.Widevine.MetricData.Types.MetricType TypeDefaultValue = global::AudibleUtilities.Widevine.MetricData.Types.MetricType.Latency;

    private global::AudibleUtilities.Widevine.MetricData.Types.MetricType type_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AudibleUtilities.Widevine.MetricData.Types.MetricType Type {
      get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        type_ = value;
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private readonly static long ValueDefaultValue = 0L;

    private long value_;
    /// <summary>
    /// The value associated with 'type'.  For example if type == LATENCY, the
    /// value would be the time in microseconds spent in this 'stage'.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Value {
      get { if ((_hasBits0 & 2) != 0) { return value_; } else { return ValueDefaultValue; } }
      set {
        _hasBits0 |= 2;
        value_ = value;
      }
    }
    /// <summary>Gets whether the "value" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasValue {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "value" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearValue() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TypeValue);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TypeValue other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (Value != other.Value) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasType) hash ^= Type.GetHashCode();
      if (HasValue) hash ^= Value.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (HasValue) {
        output.WriteRawTag(16);
        output.WriteInt64(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (HasValue) {
        output.WriteRawTag(16);
        output.WriteInt64(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (HasValue) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Value);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TypeValue other) {
      if (other == null) {
        return;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasValue) {
        Value = other.Value;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Type = (global::AudibleUtilities.Widevine.MetricData.Types.MetricType) input.ReadEnum();
            break;
          }
          case 16: {
            Value = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Type = (global::AudibleUtilities.Widevine.MetricData.Types.MetricType) input.ReadEnum();
            break;
          }
          case 16: {
            Value = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

}
#endregion

}

[global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
internal sealed partial class VersionInfo : pb::IMessage<VersionInfo>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  , pb::IBufferMessage
#endif
{
private static readonly pb::MessageParser<VersionInfo> _parser = new pb::MessageParser<VersionInfo>(() => new VersionInfo());
private pb::UnknownFieldSet _unknownFields;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pb::MessageParser<VersionInfo> Parser { get { return _parser; } }

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pbr::MessageDescriptor Descriptor {
  get { return global::AudibleUtilities.Widevine.LicenseProtocolReflection.Descriptor.MessageTypes[4]; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
pbr::MessageDescriptor pb::IMessage.Descriptor {
  get { return Descriptor; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public VersionInfo() {
  OnConstruction();
}

partial void OnConstruction();

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public VersionInfo(VersionInfo other) : this() {
  licenseSdkVersion_ = other.licenseSdkVersion_;
  licenseServiceVersion_ = other.licenseServiceVersion_;
  _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public VersionInfo Clone() {
  return new VersionInfo(this);
}

/// <summary>Field number for the "license_sdk_version" field.</summary>
public const int LicenseSdkVersionFieldNumber = 1;
private readonly static string LicenseSdkVersionDefaultValue = "";

private string licenseSdkVersion_;
/// <summary>
/// License SDK version reported by the Widevine License SDK. This field
/// is populated automatically by the SDK.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public string LicenseSdkVersion {
  get { return licenseSdkVersion_ ?? LicenseSdkVersionDefaultValue; }
  set {
    licenseSdkVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "license_sdk_version" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasLicenseSdkVersion {
  get { return licenseSdkVersion_ != null; }
}
/// <summary>Clears the value of the "license_sdk_version" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearLicenseSdkVersion() {
  licenseSdkVersion_ = null;
}

/// <summary>Field number for the "license_service_version" field.</summary>
public const int LicenseServiceVersionFieldNumber = 2;
private readonly static string LicenseServiceVersionDefaultValue = "";

private string licenseServiceVersion_;
/// <summary>
/// Version of the service hosting the license SDK. This field is optional.
/// It may be provided by the hosting service.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public string LicenseServiceVersion {
  get { return licenseServiceVersion_ ?? LicenseServiceVersionDefaultValue; }
  set {
    licenseServiceVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "license_service_version" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasLicenseServiceVersion {
  get { return licenseServiceVersion_ != null; }
}
/// <summary>Clears the value of the "license_service_version" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearLicenseServiceVersion() {
  licenseServiceVersion_ = null;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override bool Equals(object other) {
  return Equals(other as VersionInfo);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool Equals(VersionInfo other) {
  if (ReferenceEquals(other, null)) {
    return false;
  }
  if (ReferenceEquals(other, this)) {
    return true;
  }
  if (LicenseSdkVersion != other.LicenseSdkVersion) return false;
  if (LicenseServiceVersion != other.LicenseServiceVersion) return false;
  return Equals(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override int GetHashCode() {
  int hash = 1;
  if (HasLicenseSdkVersion) hash ^= LicenseSdkVersion.GetHashCode();
  if (HasLicenseServiceVersion) hash ^= LicenseServiceVersion.GetHashCode();
  if (_unknownFields != null) {
    hash ^= _unknownFields.GetHashCode();
  }
  return hash;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override string ToString() {
  return pb::JsonFormatter.ToDiagnosticString(this);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void WriteTo(pb::CodedOutputStream output) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  output.WriteRawMessage(this);
#else
  if (HasLicenseSdkVersion) {
    output.WriteRawTag(10);
    output.WriteString(LicenseSdkVersion);
  }
  if (HasLicenseServiceVersion) {
    output.WriteRawTag(18);
    output.WriteString(LicenseServiceVersion);
  }
  if (_unknownFields != null) {
    _unknownFields.WriteTo(output);
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
  if (HasLicenseSdkVersion) {
    output.WriteRawTag(10);
    output.WriteString(LicenseSdkVersion);
  }
  if (HasLicenseServiceVersion) {
    output.WriteRawTag(18);
    output.WriteString(LicenseServiceVersion);
  }
  if (_unknownFields != null) {
    _unknownFields.WriteTo(ref output);
  }
}
#endif

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public int CalculateSize() {
  int size = 0;
  if (HasLicenseSdkVersion) {
    size += 1 + pb::CodedOutputStream.ComputeStringSize(LicenseSdkVersion);
  }
  if (HasLicenseServiceVersion) {
    size += 1 + pb::CodedOutputStream.ComputeStringSize(LicenseServiceVersion);
  }
  if (_unknownFields != null) {
    size += _unknownFields.CalculateSize();
  }
  return size;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(VersionInfo other) {
  if (other == null) {
    return;
  }
  if (other.HasLicenseSdkVersion) {
    LicenseSdkVersion = other.LicenseSdkVersion;
  }
  if (other.HasLicenseServiceVersion) {
    LicenseServiceVersion = other.LicenseServiceVersion;
  }
  _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(pb::CodedInputStream input) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  input.ReadRawMessage(this);
#else
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
        break;
      case 10: {
        LicenseSdkVersion = input.ReadString();
        break;
      }
      case 18: {
        LicenseServiceVersion = input.ReadString();
        break;
      }
    }
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
        break;
      case 10: {
        LicenseSdkVersion = input.ReadString();
        break;
      }
      case 18: {
        LicenseServiceVersion = input.ReadString();
        break;
      }
    }
  }
}
#endif

}

[global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
internal sealed partial class SignedMessage : pb::IMessage<SignedMessage>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  , pb::IBufferMessage
#endif
{
private static readonly pb::MessageParser<SignedMessage> _parser = new pb::MessageParser<SignedMessage>(() => new SignedMessage());
private pb::UnknownFieldSet _unknownFields;
private int _hasBits0;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pb::MessageParser<SignedMessage> Parser { get { return _parser; } }

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pbr::MessageDescriptor Descriptor {
  get { return global::AudibleUtilities.Widevine.LicenseProtocolReflection.Descriptor.MessageTypes[5]; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
pbr::MessageDescriptor pb::IMessage.Descriptor {
  get { return Descriptor; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public SignedMessage() {
  OnConstruction();
}

partial void OnConstruction();

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public SignedMessage(SignedMessage other) : this() {
  _hasBits0 = other._hasBits0;
  type_ = other.type_;
  msg_ = other.msg_;
  signature_ = other.signature_;
  sessionKey_ = other.sessionKey_;
  remoteAttestation_ = other.remoteAttestation_;
  metricData_ = other.metricData_.Clone();
  serviceVersionInfo_ = other.serviceVersionInfo_ != null ? other.serviceVersionInfo_.Clone() : null;
  sessionKeyType_ = other.sessionKeyType_;
  oemcryptoCoreMessage_ = other.oemcryptoCoreMessage_;
  _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public SignedMessage Clone() {
  return new SignedMessage(this);
}

/// <summary>Field number for the "type" field.</summary>
public const int TypeFieldNumber = 1;
private readonly static global::AudibleUtilities.Widevine.SignedMessage.Types.MessageType TypeDefaultValue = global::AudibleUtilities.Widevine.SignedMessage.Types.MessageType.LicenseRequest;

private global::AudibleUtilities.Widevine.SignedMessage.Types.MessageType type_;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public global::AudibleUtilities.Widevine.SignedMessage.Types.MessageType Type {
  get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
  set {
    _hasBits0 |= 1;
    type_ = value;
  }
}
/// <summary>Gets whether the "type" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasType {
  get { return (_hasBits0 & 1) != 0; }
}
/// <summary>Clears the value of the "type" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearType() {
  _hasBits0 &= ~1;
}

/// <summary>Field number for the "msg" field.</summary>
public const int MsgFieldNumber = 2;
private readonly static pb::ByteString MsgDefaultValue = pb::ByteString.Empty;

private pb::ByteString msg_;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString Msg {
  get { return msg_ ?? MsgDefaultValue; }
  set {
    msg_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "msg" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasMsg {
  get { return msg_ != null; }
}
/// <summary>Clears the value of the "msg" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearMsg() {
  msg_ = null;
}

/// <summary>Field number for the "signature" field.</summary>
public const int SignatureFieldNumber = 3;
private readonly static pb::ByteString SignatureDefaultValue = pb::ByteString.Empty;

private pb::ByteString signature_;
/// <summary>
/// Required field that contains the signature of the bytes of msg.
/// For license requests, the signing algorithm is determined by the
/// certificate contained in the request.
/// For license responses, the signing algorithm is HMAC with signing key based
/// on |session_key|.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString Signature {
  get { return signature_ ?? SignatureDefaultValue; }
  set {
    signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "signature" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasSignature {
  get { return signature_ != null; }
}
/// <summary>Clears the value of the "signature" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearSignature() {
  signature_ = null;
}

/// <summary>Field number for the "session_key" field.</summary>
public const int SessionKeyFieldNumber = 4;
private readonly static pb::ByteString SessionKeyDefaultValue = pb::ByteString.Empty;

private pb::ByteString sessionKey_;
/// <summary>
/// If populated, the contents of this field will be signaled by the
/// |session_key_type| type. If the |session_key_type| is WRAPPED_AES_KEY the
/// key is the bytes of an encrypted AES key. If the |session_key_type| is
/// EPHERMERAL_ECC_PUBLIC_KEY the field contains the bytes of an RFC5208 ASN1
/// serialized ECC public key.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString SessionKey {
  get { return sessionKey_ ?? SessionKeyDefaultValue; }
  set {
    sessionKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "session_key" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasSessionKey {
  get { return sessionKey_ != null; }
}
/// <summary>Clears the value of the "session_key" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearSessionKey() {
  sessionKey_ = null;
}

/// <summary>Field number for the "remote_attestation" field.</summary>
public const int RemoteAttestationFieldNumber = 5;
private readonly static pb::ByteString RemoteAttestationDefaultValue = pb::ByteString.Empty;

private pb::ByteString remoteAttestation_;
/// <summary>
/// Remote attestation data which will be present in the initial license
/// request for ChromeOS client devices operating in verified mode. Remote
/// attestation challenge data is |msg| field above. Optional.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString RemoteAttestation {
  get { return remoteAttestation_ ?? RemoteAttestationDefaultValue; }
  set {
    remoteAttestation_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "remote_attestation" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasRemoteAttestation {
  get { return remoteAttestation_ != null; }
}
/// <summary>Clears the value of the "remote_attestation" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearRemoteAttestation() {
  remoteAttestation_ = null;
}

/// <summary>Field number for the "metric_data" field.</summary>
public const int MetricDataFieldNumber = 6;
private static readonly pb::FieldCodec<global::AudibleUtilities.Widevine.MetricData> _repeated_metricData_codec
    = pb::FieldCodec.ForMessage(50, global::AudibleUtilities.Widevine.MetricData.Parser);
private readonly pbc::RepeatedField<global::AudibleUtilities.Widevine.MetricData> metricData_ = new pbc::RepeatedField<global::AudibleUtilities.Widevine.MetricData>();
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pbc::RepeatedField<global::AudibleUtilities.Widevine.MetricData> MetricData {
  get { return metricData_; }
}

/// <summary>Field number for the "service_version_info" field.</summary>
public const int ServiceVersionInfoFieldNumber = 7;
private global::AudibleUtilities.Widevine.VersionInfo serviceVersionInfo_;
/// <summary>
/// Version information from the SDK and license service. This information is
/// provided in the license response.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public global::AudibleUtilities.Widevine.VersionInfo ServiceVersionInfo {
  get { return serviceVersionInfo_; }
  set {
    serviceVersionInfo_ = value;
  }
}

/// <summary>Field number for the "session_key_type" field.</summary>
public const int SessionKeyTypeFieldNumber = 8;
private readonly static global::AudibleUtilities.Widevine.SignedMessage.Types.SessionKeyType SessionKeyTypeDefaultValue = global::AudibleUtilities.Widevine.SignedMessage.Types.SessionKeyType.WrappedAesKey;

private global::AudibleUtilities.Widevine.SignedMessage.Types.SessionKeyType sessionKeyType_;
/// <summary>
/// Optional field that contains the algorithm type used to generate the
/// session_key and signature in a LICENSE message.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public global::AudibleUtilities.Widevine.SignedMessage.Types.SessionKeyType SessionKeyType {
  get { if ((_hasBits0 & 2) != 0) { return sessionKeyType_; } else { return SessionKeyTypeDefaultValue; } }
  set {
    _hasBits0 |= 2;
    sessionKeyType_ = value;
  }
}
/// <summary>Gets whether the "session_key_type" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasSessionKeyType {
  get { return (_hasBits0 & 2) != 0; }
}
/// <summary>Clears the value of the "session_key_type" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearSessionKeyType() {
  _hasBits0 &= ~2;
}

/// <summary>Field number for the "oemcrypto_core_message" field.</summary>
public const int OemcryptoCoreMessageFieldNumber = 9;
private readonly static pb::ByteString OemcryptoCoreMessageDefaultValue = pb::ByteString.Empty;

private pb::ByteString oemcryptoCoreMessage_;
/// <summary>
/// The core message is the simple serialization of fields used by OEMCrypto.
/// This field was introduced in OEMCrypto API v16.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString OemcryptoCoreMessage {
  get { return oemcryptoCoreMessage_ ?? OemcryptoCoreMessageDefaultValue; }
  set {
    oemcryptoCoreMessage_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "oemcrypto_core_message" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasOemcryptoCoreMessage {
  get { return oemcryptoCoreMessage_ != null; }
}
/// <summary>Clears the value of the "oemcrypto_core_message" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearOemcryptoCoreMessage() {
  oemcryptoCoreMessage_ = null;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override bool Equals(object other) {
  return Equals(other as SignedMessage);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool Equals(SignedMessage other) {
  if (ReferenceEquals(other, null)) {
    return false;
  }
  if (ReferenceEquals(other, this)) {
    return true;
  }
  if (Type != other.Type) return false;
  if (Msg != other.Msg) return false;
  if (Signature != other.Signature) return false;
  if (SessionKey != other.SessionKey) return false;
  if (RemoteAttestation != other.RemoteAttestation) return false;
  if(!metricData_.Equals(other.metricData_)) return false;
  if (!object.Equals(ServiceVersionInfo, other.ServiceVersionInfo)) return false;
  if (SessionKeyType != other.SessionKeyType) return false;
  if (OemcryptoCoreMessage != other.OemcryptoCoreMessage) return false;
  return Equals(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override int GetHashCode() {
  int hash = 1;
  if (HasType) hash ^= Type.GetHashCode();
  if (HasMsg) hash ^= Msg.GetHashCode();
  if (HasSignature) hash ^= Signature.GetHashCode();
  if (HasSessionKey) hash ^= SessionKey.GetHashCode();
  if (HasRemoteAttestation) hash ^= RemoteAttestation.GetHashCode();
  hash ^= metricData_.GetHashCode();
  if (serviceVersionInfo_ != null) hash ^= ServiceVersionInfo.GetHashCode();
  if (HasSessionKeyType) hash ^= SessionKeyType.GetHashCode();
  if (HasOemcryptoCoreMessage) hash ^= OemcryptoCoreMessage.GetHashCode();
  if (_unknownFields != null) {
    hash ^= _unknownFields.GetHashCode();
  }
  return hash;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override string ToString() {
  return pb::JsonFormatter.ToDiagnosticString(this);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void WriteTo(pb::CodedOutputStream output) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  output.WriteRawMessage(this);
#else
  if (HasType) {
    output.WriteRawTag(8);
    output.WriteEnum((int) Type);
  }
  if (HasMsg) {
    output.WriteRawTag(18);
    output.WriteBytes(Msg);
  }
  if (HasSignature) {
    output.WriteRawTag(26);
    output.WriteBytes(Signature);
  }
  if (HasSessionKey) {
    output.WriteRawTag(34);
    output.WriteBytes(SessionKey);
  }
  if (HasRemoteAttestation) {
    output.WriteRawTag(42);
    output.WriteBytes(RemoteAttestation);
  }
  metricData_.WriteTo(output, _repeated_metricData_codec);
  if (serviceVersionInfo_ != null) {
    output.WriteRawTag(58);
    output.WriteMessage(ServiceVersionInfo);
  }
  if (HasSessionKeyType) {
    output.WriteRawTag(64);
    output.WriteEnum((int) SessionKeyType);
  }
  if (HasOemcryptoCoreMessage) {
    output.WriteRawTag(74);
    output.WriteBytes(OemcryptoCoreMessage);
  }
  if (_unknownFields != null) {
    _unknownFields.WriteTo(output);
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
  if (HasType) {
    output.WriteRawTag(8);
    output.WriteEnum((int) Type);
  }
  if (HasMsg) {
    output.WriteRawTag(18);
    output.WriteBytes(Msg);
  }
  if (HasSignature) {
    output.WriteRawTag(26);
    output.WriteBytes(Signature);
  }
  if (HasSessionKey) {
    output.WriteRawTag(34);
    output.WriteBytes(SessionKey);
  }
  if (HasRemoteAttestation) {
    output.WriteRawTag(42);
    output.WriteBytes(RemoteAttestation);
  }
  metricData_.WriteTo(ref output, _repeated_metricData_codec);
  if (serviceVersionInfo_ != null) {
    output.WriteRawTag(58);
    output.WriteMessage(ServiceVersionInfo);
  }
  if (HasSessionKeyType) {
    output.WriteRawTag(64);
    output.WriteEnum((int) SessionKeyType);
  }
  if (HasOemcryptoCoreMessage) {
    output.WriteRawTag(74);
    output.WriteBytes(OemcryptoCoreMessage);
  }
  if (_unknownFields != null) {
    _unknownFields.WriteTo(ref output);
  }
}
#endif

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public int CalculateSize() {
  int size = 0;
  if (HasType) {
    size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
  }
  if (HasMsg) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(Msg);
  }
  if (HasSignature) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(Signature);
  }
  if (HasSessionKey) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(SessionKey);
  }
  if (HasRemoteAttestation) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(RemoteAttestation);
  }
  size += metricData_.CalculateSize(_repeated_metricData_codec);
  if (serviceVersionInfo_ != null) {
    size += 1 + pb::CodedOutputStream.ComputeMessageSize(ServiceVersionInfo);
  }
  if (HasSessionKeyType) {
    size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SessionKeyType);
  }
  if (HasOemcryptoCoreMessage) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(OemcryptoCoreMessage);
  }
  if (_unknownFields != null) {
    size += _unknownFields.CalculateSize();
  }
  return size;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(SignedMessage other) {
  if (other == null) {
    return;
  }
  if (other.HasType) {
    Type = other.Type;
  }
  if (other.HasMsg) {
    Msg = other.Msg;
  }
  if (other.HasSignature) {
    Signature = other.Signature;
  }
  if (other.HasSessionKey) {
    SessionKey = other.SessionKey;
  }
  if (other.HasRemoteAttestation) {
    RemoteAttestation = other.RemoteAttestation;
  }
  metricData_.Add(other.metricData_);
  if (other.serviceVersionInfo_ != null) {
    if (serviceVersionInfo_ == null) {
      ServiceVersionInfo = new global::AudibleUtilities.Widevine.VersionInfo();
    }
    ServiceVersionInfo.MergeFrom(other.ServiceVersionInfo);
  }
  if (other.HasSessionKeyType) {
    SessionKeyType = other.SessionKeyType;
  }
  if (other.HasOemcryptoCoreMessage) {
    OemcryptoCoreMessage = other.OemcryptoCoreMessage;
  }
  _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(pb::CodedInputStream input) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  input.ReadRawMessage(this);
#else
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
        break;
      case 8: {
        Type = (global::AudibleUtilities.Widevine.SignedMessage.Types.MessageType) input.ReadEnum();
        break;
      }
      case 18: {
        Msg = input.ReadBytes();
        break;
      }
      case 26: {
        Signature = input.ReadBytes();
        break;
      }
      case 34: {
        SessionKey = input.ReadBytes();
        break;
      }
      case 42: {
        RemoteAttestation = input.ReadBytes();
        break;
      }
      case 50: {
        metricData_.AddEntriesFrom(input, _repeated_metricData_codec);
        break;
      }
      case 58: {
        if (serviceVersionInfo_ == null) {
          ServiceVersionInfo = new global::AudibleUtilities.Widevine.VersionInfo();
        }
        input.ReadMessage(ServiceVersionInfo);
        break;
      }
      case 64: {
        SessionKeyType = (global::AudibleUtilities.Widevine.SignedMessage.Types.SessionKeyType) input.ReadEnum();
        break;
      }
      case 74: {
        OemcryptoCoreMessage = input.ReadBytes();
        break;
      }
    }
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
        break;
      case 8: {
        Type = (global::AudibleUtilities.Widevine.SignedMessage.Types.MessageType) input.ReadEnum();
        break;
      }
      case 18: {
        Msg = input.ReadBytes();
        break;
      }
      case 26: {
        Signature = input.ReadBytes();
        break;
      }
      case 34: {
        SessionKey = input.ReadBytes();
        break;
      }
      case 42: {
        RemoteAttestation = input.ReadBytes();
        break;
      }
      case 50: {
        metricData_.AddEntriesFrom(ref input, _repeated_metricData_codec);
        break;
      }
      case 58: {
        if (serviceVersionInfo_ == null) {
          ServiceVersionInfo = new global::AudibleUtilities.Widevine.VersionInfo();
        }
        input.ReadMessage(ServiceVersionInfo);
        break;
      }
      case 64: {
        SessionKeyType = (global::AudibleUtilities.Widevine.SignedMessage.Types.SessionKeyType) input.ReadEnum();
        break;
      }
      case 74: {
        OemcryptoCoreMessage = input.ReadBytes();
        break;
      }
    }
  }
}
#endif

#region Nested types
/// <summary>Container for nested types declared in the SignedMessage message type.</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static partial class Types {
  internal enum MessageType {
    [pbr::OriginalName("LICENSE_REQUEST")] LicenseRequest = 1,
    [pbr::OriginalName("LICENSE")] License = 2,
    [pbr::OriginalName("ERROR_RESPONSE")] ErrorResponse = 3,
    [pbr::OriginalName("SERVICE_CERTIFICATE_REQUEST")] ServiceCertificateRequest = 4,
    [pbr::OriginalName("SERVICE_CERTIFICATE")] ServiceCertificate = 5,
    [pbr::OriginalName("SUB_LICENSE")] SubLicense = 6,
    [pbr::OriginalName("CAS_LICENSE_REQUEST")] CasLicenseRequest = 7,
    [pbr::OriginalName("CAS_LICENSE")] CasLicense = 8,
    [pbr::OriginalName("EXTERNAL_LICENSE_REQUEST")] ExternalLicenseRequest = 9,
    [pbr::OriginalName("EXTERNAL_LICENSE")] ExternalLicense = 10,
  }

  internal enum SessionKeyType {
    [pbr::OriginalName("UNDEFINED")] Undefined = 0,
    [pbr::OriginalName("WRAPPED_AES_KEY")] WrappedAesKey = 1,
    [pbr::OriginalName("EPHERMERAL_ECC_PUBLIC_KEY")] EphermeralEccPublicKey = 2,
  }

}
#endregion

}

/// <summary>
/// ClientIdentification message used to authenticate the client device.
/// </summary>
[global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
internal sealed partial class ClientIdentification : pb::IMessage<ClientIdentification>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  , pb::IBufferMessage
#endif
{
private static readonly pb::MessageParser<ClientIdentification> _parser = new pb::MessageParser<ClientIdentification>(() => new ClientIdentification());
private pb::UnknownFieldSet _unknownFields;
private int _hasBits0;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pb::MessageParser<ClientIdentification> Parser { get { return _parser; } }

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pbr::MessageDescriptor Descriptor {
  get { return global::AudibleUtilities.Widevine.LicenseProtocolReflection.Descriptor.MessageTypes[6]; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
pbr::MessageDescriptor pb::IMessage.Descriptor {
  get { return Descriptor; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public ClientIdentification() {
  OnConstruction();
}

partial void OnConstruction();

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public ClientIdentification(ClientIdentification other) : this() {
  _hasBits0 = other._hasBits0;
  type_ = other.type_;
  token_ = other.token_;
  clientInfo_ = other.clientInfo_.Clone();
  providerClientToken_ = other.providerClientToken_;
  licenseCounter_ = other.licenseCounter_;
  clientCapabilities_ = other.clientCapabilities_ != null ? other.clientCapabilities_.Clone() : null;
  vmpData_ = other.vmpData_;
  deviceCredentials_ = other.deviceCredentials_.Clone();
  _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public ClientIdentification Clone() {
  return new ClientIdentification(this);
}

/// <summary>Field number for the "type" field.</summary>
public const int TypeFieldNumber = 1;
private readonly static global::AudibleUtilities.Widevine.ClientIdentification.Types.TokenType TypeDefaultValue = global::AudibleUtilities.Widevine.ClientIdentification.Types.TokenType.Keybox;

private global::AudibleUtilities.Widevine.ClientIdentification.Types.TokenType type_;
/// <summary>
/// Type of factory-provisioned device root of trust. Optional.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public global::AudibleUtilities.Widevine.ClientIdentification.Types.TokenType Type {
  get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
  set {
    _hasBits0 |= 1;
    type_ = value;
  }
}
/// <summary>Gets whether the "type" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasType {
  get { return (_hasBits0 & 1) != 0; }
}
/// <summary>Clears the value of the "type" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearType() {
  _hasBits0 &= ~1;
}

/// <summary>Field number for the "token" field.</summary>
public const int TokenFieldNumber = 2;
private readonly static pb::ByteString TokenDefaultValue = pb::ByteString.Empty;

private pb::ByteString token_;
/// <summary>
/// Factory-provisioned device root of trust. Required.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString Token {
  get { return token_ ?? TokenDefaultValue; }
  set {
    token_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "token" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasToken {
  get { return token_ != null; }
}
/// <summary>Clears the value of the "token" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearToken() {
  token_ = null;
}

/// <summary>Field number for the "client_info" field.</summary>
public const int ClientInfoFieldNumber = 3;
private static readonly pb::FieldCodec<global::AudibleUtilities.Widevine.ClientIdentification.Types.NameValue> _repeated_clientInfo_codec
    = pb::FieldCodec.ForMessage(26, global::AudibleUtilities.Widevine.ClientIdentification.Types.NameValue.Parser);
private readonly pbc::RepeatedField<global::AudibleUtilities.Widevine.ClientIdentification.Types.NameValue> clientInfo_ = new pbc::RepeatedField<global::AudibleUtilities.Widevine.ClientIdentification.Types.NameValue>();
/// <summary>
/// Optional client information name/value pairs.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pbc::RepeatedField<global::AudibleUtilities.Widevine.ClientIdentification.Types.NameValue> ClientInfo {
  get { return clientInfo_; }
}

/// <summary>Field number for the "provider_client_token" field.</summary>
public const int ProviderClientTokenFieldNumber = 4;
private readonly static pb::ByteString ProviderClientTokenDefaultValue = pb::ByteString.Empty;

private pb::ByteString providerClientToken_;
/// <summary>
/// Client token generated by the content provider. Optional.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString ProviderClientToken {
  get { return providerClientToken_ ?? ProviderClientTokenDefaultValue; }
  set {
    providerClientToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "provider_client_token" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasProviderClientToken {
  get { return providerClientToken_ != null; }
}
/// <summary>Clears the value of the "provider_client_token" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearProviderClientToken() {
  providerClientToken_ = null;
}

/// <summary>Field number for the "license_counter" field.</summary>
public const int LicenseCounterFieldNumber = 5;
private readonly static uint LicenseCounterDefaultValue = 0;

private uint licenseCounter_;
/// <summary>
/// Number of licenses received by the client to which the token above belongs.
/// Only present if client_token is specified.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public uint LicenseCounter {
  get { if ((_hasBits0 & 2) != 0) { return licenseCounter_; } else { return LicenseCounterDefaultValue; } }
  set {
    _hasBits0 |= 2;
    licenseCounter_ = value;
  }
}
/// <summary>Gets whether the "license_counter" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasLicenseCounter {
  get { return (_hasBits0 & 2) != 0; }
}
/// <summary>Clears the value of the "license_counter" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearLicenseCounter() {
  _hasBits0 &= ~2;
}

/// <summary>Field number for the "client_capabilities" field.</summary>
public const int ClientCapabilitiesFieldNumber = 6;
private global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities clientCapabilities_;
/// <summary>
/// List of non-baseline client capabilities.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities ClientCapabilities {
  get { return clientCapabilities_; }
  set {
    clientCapabilities_ = value;
  }
}

/// <summary>Field number for the "vmp_data" field.</summary>
public const int VmpDataFieldNumber = 7;
private readonly static pb::ByteString VmpDataDefaultValue = pb::ByteString.Empty;

private pb::ByteString vmpData_;
/// <summary>
/// Serialized VmpData message. Optional.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString VmpData {
  get { return vmpData_ ?? VmpDataDefaultValue; }
  set {
    vmpData_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "vmp_data" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasVmpData {
  get { return vmpData_ != null; }
}
/// <summary>Clears the value of the "vmp_data" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearVmpData() {
  vmpData_ = null;
}

/// <summary>Field number for the "device_credentials" field.</summary>
public const int DeviceCredentialsFieldNumber = 8;
private static readonly pb::FieldCodec<global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCredentials> _repeated_deviceCredentials_codec
    = pb::FieldCodec.ForMessage(66, global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCredentials.Parser);
private readonly pbc::RepeatedField<global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCredentials> deviceCredentials_ = new pbc::RepeatedField<global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCredentials>();
/// <summary>
/// Optional field that may contain additional provisioning credentials.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pbc::RepeatedField<global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCredentials> DeviceCredentials {
  get { return deviceCredentials_; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override bool Equals(object other) {
  return Equals(other as ClientIdentification);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool Equals(ClientIdentification other) {
  if (ReferenceEquals(other, null)) {
    return false;
  }
  if (ReferenceEquals(other, this)) {
    return true;
  }
  if (Type != other.Type) return false;
  if (Token != other.Token) return false;
  if(!clientInfo_.Equals(other.clientInfo_)) return false;
  if (ProviderClientToken != other.ProviderClientToken) return false;
  if (LicenseCounter != other.LicenseCounter) return false;
  if (!object.Equals(ClientCapabilities, other.ClientCapabilities)) return false;
  if (VmpData != other.VmpData) return false;
  if(!deviceCredentials_.Equals(other.deviceCredentials_)) return false;
  return Equals(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override int GetHashCode() {
  int hash = 1;
  if (HasType) hash ^= Type.GetHashCode();
  if (HasToken) hash ^= Token.GetHashCode();
  hash ^= clientInfo_.GetHashCode();
  if (HasProviderClientToken) hash ^= ProviderClientToken.GetHashCode();
  if (HasLicenseCounter) hash ^= LicenseCounter.GetHashCode();
  if (clientCapabilities_ != null) hash ^= ClientCapabilities.GetHashCode();
  if (HasVmpData) hash ^= VmpData.GetHashCode();
  hash ^= deviceCredentials_.GetHashCode();
  if (_unknownFields != null) {
    hash ^= _unknownFields.GetHashCode();
  }
  return hash;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override string ToString() {
  return pb::JsonFormatter.ToDiagnosticString(this);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void WriteTo(pb::CodedOutputStream output) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  output.WriteRawMessage(this);
#else
  if (HasType) {
    output.WriteRawTag(8);
    output.WriteEnum((int) Type);
  }
  if (HasToken) {
    output.WriteRawTag(18);
    output.WriteBytes(Token);
  }
  clientInfo_.WriteTo(output, _repeated_clientInfo_codec);
  if (HasProviderClientToken) {
    output.WriteRawTag(34);
    output.WriteBytes(ProviderClientToken);
  }
  if (HasLicenseCounter) {
    output.WriteRawTag(40);
    output.WriteUInt32(LicenseCounter);
  }
  if (clientCapabilities_ != null) {
    output.WriteRawTag(50);
    output.WriteMessage(ClientCapabilities);
  }
  if (HasVmpData) {
    output.WriteRawTag(58);
    output.WriteBytes(VmpData);
  }
  deviceCredentials_.WriteTo(output, _repeated_deviceCredentials_codec);
  if (_unknownFields != null) {
    _unknownFields.WriteTo(output);
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
  if (HasType) {
    output.WriteRawTag(8);
    output.WriteEnum((int) Type);
  }
  if (HasToken) {
    output.WriteRawTag(18);
    output.WriteBytes(Token);
  }
  clientInfo_.WriteTo(ref output, _repeated_clientInfo_codec);
  if (HasProviderClientToken) {
    output.WriteRawTag(34);
    output.WriteBytes(ProviderClientToken);
  }
  if (HasLicenseCounter) {
    output.WriteRawTag(40);
    output.WriteUInt32(LicenseCounter);
  }
  if (clientCapabilities_ != null) {
    output.WriteRawTag(50);
    output.WriteMessage(ClientCapabilities);
  }
  if (HasVmpData) {
    output.WriteRawTag(58);
    output.WriteBytes(VmpData);
  }
  deviceCredentials_.WriteTo(ref output, _repeated_deviceCredentials_codec);
  if (_unknownFields != null) {
    _unknownFields.WriteTo(ref output);
  }
}
#endif

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public int CalculateSize() {
  int size = 0;
  if (HasType) {
    size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
  }
  if (HasToken) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(Token);
  }
  size += clientInfo_.CalculateSize(_repeated_clientInfo_codec);
  if (HasProviderClientToken) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(ProviderClientToken);
  }
  if (HasLicenseCounter) {
    size += 1 + pb::CodedOutputStream.ComputeUInt32Size(LicenseCounter);
  }
  if (clientCapabilities_ != null) {
    size += 1 + pb::CodedOutputStream.ComputeMessageSize(ClientCapabilities);
  }
  if (HasVmpData) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(VmpData);
  }
  size += deviceCredentials_.CalculateSize(_repeated_deviceCredentials_codec);
  if (_unknownFields != null) {
    size += _unknownFields.CalculateSize();
  }
  return size;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(ClientIdentification other) {
  if (other == null) {
    return;
  }
  if (other.HasType) {
    Type = other.Type;
  }
  if (other.HasToken) {
    Token = other.Token;
  }
  clientInfo_.Add(other.clientInfo_);
  if (other.HasProviderClientToken) {
    ProviderClientToken = other.ProviderClientToken;
  }
  if (other.HasLicenseCounter) {
    LicenseCounter = other.LicenseCounter;
  }
  if (other.clientCapabilities_ != null) {
    if (clientCapabilities_ == null) {
      ClientCapabilities = new global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities();
    }
    ClientCapabilities.MergeFrom(other.ClientCapabilities);
  }
  if (other.HasVmpData) {
    VmpData = other.VmpData;
  }
  deviceCredentials_.Add(other.deviceCredentials_);
  _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(pb::CodedInputStream input) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  input.ReadRawMessage(this);
#else
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
        break;
      case 8: {
        Type = (global::AudibleUtilities.Widevine.ClientIdentification.Types.TokenType) input.ReadEnum();
        break;
      }
      case 18: {
        Token = input.ReadBytes();
        break;
      }
      case 26: {
        clientInfo_.AddEntriesFrom(input, _repeated_clientInfo_codec);
        break;
      }
      case 34: {
        ProviderClientToken = input.ReadBytes();
        break;
      }
      case 40: {
        LicenseCounter = input.ReadUInt32();
        break;
      }
      case 50: {
        if (clientCapabilities_ == null) {
          ClientCapabilities = new global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities();
        }
        input.ReadMessage(ClientCapabilities);
        break;
      }
      case 58: {
        VmpData = input.ReadBytes();
        break;
      }
      case 66: {
        deviceCredentials_.AddEntriesFrom(input, _repeated_deviceCredentials_codec);
        break;
      }
    }
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
        break;
      case 8: {
        Type = (global::AudibleUtilities.Widevine.ClientIdentification.Types.TokenType) input.ReadEnum();
        break;
      }
      case 18: {
        Token = input.ReadBytes();
        break;
      }
      case 26: {
        clientInfo_.AddEntriesFrom(ref input, _repeated_clientInfo_codec);
        break;
      }
      case 34: {
        ProviderClientToken = input.ReadBytes();
        break;
      }
      case 40: {
        LicenseCounter = input.ReadUInt32();
        break;
      }
      case 50: {
        if (clientCapabilities_ == null) {
          ClientCapabilities = new global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities();
        }
        input.ReadMessage(ClientCapabilities);
        break;
      }
      case 58: {
        VmpData = input.ReadBytes();
        break;
      }
      case 66: {
        deviceCredentials_.AddEntriesFrom(ref input, _repeated_deviceCredentials_codec);
        break;
      }
    }
  }
}
#endif

#region Nested types
/// <summary>Container for nested types declared in the ClientIdentification message type.</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static partial class Types {
  internal enum TokenType {
    [pbr::OriginalName("KEYBOX")] Keybox = 0,
    [pbr::OriginalName("DRM_DEVICE_CERTIFICATE")] DrmDeviceCertificate = 1,
    [pbr::OriginalName("REMOTE_ATTESTATION_CERTIFICATE")] RemoteAttestationCertificate = 2,
    [pbr::OriginalName("OEM_DEVICE_CERTIFICATE")] OemDeviceCertificate = 3,
  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  internal sealed partial class NameValue : pb::IMessage<NameValue>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NameValue> _parser = new pb::MessageParser<NameValue>(() => new NameValue());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NameValue> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AudibleUtilities.Widevine.ClientIdentification.Descriptor.NestedTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NameValue() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NameValue(NameValue other) : this() {
      name_ = other.name_;
      value_ = other.value_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NameValue Clone() {
      return new NameValue(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private readonly static string ValueDefaultValue = "";

    private string value_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Value {
      get { return value_ ?? ValueDefaultValue; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "value" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasValue {
      get { return value_ != null; }
    }
    /// <summary>Clears the value of the "value" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearValue() {
      value_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NameValue);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NameValue other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Value != other.Value) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (HasValue) hash ^= Value.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasValue) {
        output.WriteRawTag(18);
        output.WriteString(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasValue) {
        output.WriteRawTag(18);
        output.WriteString(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasValue) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NameValue other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasValue) {
        Value = other.Value;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Value = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Value = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Capabilities which not all clients may support. Used for the license
  /// exchange protocol only.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  internal sealed partial class ClientCapabilities : pb::IMessage<ClientCapabilities>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ClientCapabilities> _parser = new pb::MessageParser<ClientCapabilities>(() => new ClientCapabilities());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ClientCapabilities> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AudibleUtilities.Widevine.ClientIdentification.Descriptor.NestedTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ClientCapabilities() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ClientCapabilities(ClientCapabilities other) : this() {
      _hasBits0 = other._hasBits0;
      clientToken_ = other.clientToken_;
      sessionToken_ = other.sessionToken_;
      videoResolutionConstraints_ = other.videoResolutionConstraints_;
      maxHdcpVersion_ = other.maxHdcpVersion_;
      oemCryptoApiVersion_ = other.oemCryptoApiVersion_;
      antiRollbackUsageTable_ = other.antiRollbackUsageTable_;
      srmVersion_ = other.srmVersion_;
      canUpdateSrm_ = other.canUpdateSrm_;
      supportedCertificateKeyType_ = other.supportedCertificateKeyType_.Clone();
      analogOutputCapabilities_ = other.analogOutputCapabilities_;
      canDisableAnalogOutput_ = other.canDisableAnalogOutput_;
      resourceRatingTier_ = other.resourceRatingTier_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ClientCapabilities Clone() {
      return new ClientCapabilities(this);
    }

    /// <summary>Field number for the "client_token" field.</summary>
    public const int ClientTokenFieldNumber = 1;
    private readonly static bool ClientTokenDefaultValue = false;

    private bool clientToken_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ClientToken {
      get { if ((_hasBits0 & 1) != 0) { return clientToken_; } else { return ClientTokenDefaultValue; } }
      set {
        _hasBits0 |= 1;
        clientToken_ = value;
      }
    }
    /// <summary>Gets whether the "client_token" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasClientToken {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "client_token" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearClientToken() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "session_token" field.</summary>
    public const int SessionTokenFieldNumber = 2;
    private readonly static bool SessionTokenDefaultValue = false;

    private bool sessionToken_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SessionToken {
      get { if ((_hasBits0 & 2) != 0) { return sessionToken_; } else { return SessionTokenDefaultValue; } }
      set {
        _hasBits0 |= 2;
        sessionToken_ = value;
      }
    }
    /// <summary>Gets whether the "session_token" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSessionToken {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "session_token" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSessionToken() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "video_resolution_constraints" field.</summary>
    public const int VideoResolutionConstraintsFieldNumber = 3;
    private readonly static bool VideoResolutionConstraintsDefaultValue = false;

    private bool videoResolutionConstraints_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool VideoResolutionConstraints {
      get { if ((_hasBits0 & 4) != 0) { return videoResolutionConstraints_; } else { return VideoResolutionConstraintsDefaultValue; } }
      set {
        _hasBits0 |= 4;
        videoResolutionConstraints_ = value;
      }
    }
    /// <summary>Gets whether the "video_resolution_constraints" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVideoResolutionConstraints {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "video_resolution_constraints" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVideoResolutionConstraints() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "max_hdcp_version" field.</summary>
    public const int MaxHdcpVersionFieldNumber = 4;
    private readonly static global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities.Types.HdcpVersion MaxHdcpVersionDefaultValue = global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities.Types.HdcpVersion.HdcpNone;

    private global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities.Types.HdcpVersion maxHdcpVersion_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities.Types.HdcpVersion MaxHdcpVersion {
      get { if ((_hasBits0 & 8) != 0) { return maxHdcpVersion_; } else { return MaxHdcpVersionDefaultValue; } }
      set {
        _hasBits0 |= 8;
        maxHdcpVersion_ = value;
      }
    }
    /// <summary>Gets whether the "max_hdcp_version" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxHdcpVersion {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "max_hdcp_version" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxHdcpVersion() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "oem_crypto_api_version" field.</summary>
    public const int OemCryptoApiVersionFieldNumber = 5;
    private readonly static uint OemCryptoApiVersionDefaultValue = 0;

    private uint oemCryptoApiVersion_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint OemCryptoApiVersion {
      get { if ((_hasBits0 & 16) != 0) { return oemCryptoApiVersion_; } else { return OemCryptoApiVersionDefaultValue; } }
      set {
        _hasBits0 |= 16;
        oemCryptoApiVersion_ = value;
      }
    }
    /// <summary>Gets whether the "oem_crypto_api_version" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOemCryptoApiVersion {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "oem_crypto_api_version" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOemCryptoApiVersion() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "anti_rollback_usage_table" field.</summary>
    public const int AntiRollbackUsageTableFieldNumber = 6;
    private readonly static bool AntiRollbackUsageTableDefaultValue = false;

    private bool antiRollbackUsageTable_;
    /// <summary>
    /// Client has hardware support for protecting the usage table, such as
    /// storing the generation number in secure memory.  For Details, see:
    /// Widevine Modular DRM Security Integration Guide for CENC
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AntiRollbackUsageTable {
      get { if ((_hasBits0 & 32) != 0) { return antiRollbackUsageTable_; } else { return AntiRollbackUsageTableDefaultValue; } }
      set {
        _hasBits0 |= 32;
        antiRollbackUsageTable_ = value;
      }
    }
    /// <summary>Gets whether the "anti_rollback_usage_table" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAntiRollbackUsageTable {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "anti_rollback_usage_table" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAntiRollbackUsageTable() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "srm_version" field.</summary>
    public const int SrmVersionFieldNumber = 7;
    private readonly static uint SrmVersionDefaultValue = 0;

    private uint srmVersion_;
    /// <summary>
    /// The client shall report |srm_version| if available.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint SrmVersion {
      get { if ((_hasBits0 & 64) != 0) { return srmVersion_; } else { return SrmVersionDefaultValue; } }
      set {
        _hasBits0 |= 64;
        srmVersion_ = value;
      }
    }
    /// <summary>Gets whether the "srm_version" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSrmVersion {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "srm_version" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSrmVersion() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "can_update_srm" field.</summary>
    public const int CanUpdateSrmFieldNumber = 8;
    private readonly static bool CanUpdateSrmDefaultValue = false;

    private bool canUpdateSrm_;
    /// <summary>
    /// A device may have SRM data, and report a version, but may not be capable
    /// of updating SRM data.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool CanUpdateSrm {
      get { if ((_hasBits0 & 128) != 0) { return canUpdateSrm_; } else { return CanUpdateSrmDefaultValue; } }
      set {
        _hasBits0 |= 128;
        canUpdateSrm_ = value;
      }
    }
    /// <summary>Gets whether the "can_update_srm" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCanUpdateSrm {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "can_update_srm" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCanUpdateSrm() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "supported_certificate_key_type" field.</summary>
    public const int SupportedCertificateKeyTypeFieldNumber = 9;
    private static readonly pb::FieldCodec<global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities.Types.CertificateKeyType> _repeated_supportedCertificateKeyType_codec
        = pb::FieldCodec.ForEnum(72, x => (int) x, x => (global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities.Types.CertificateKeyType) x);
    private readonly pbc::RepeatedField<global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities.Types.CertificateKeyType> supportedCertificateKeyType_ = new pbc::RepeatedField<global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities.Types.CertificateKeyType>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities.Types.CertificateKeyType> SupportedCertificateKeyType {
      get { return supportedCertificateKeyType_; }
    }

    /// <summary>Field number for the "analog_output_capabilities" field.</summary>
    public const int AnalogOutputCapabilitiesFieldNumber = 10;
    private readonly static global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities.Types.AnalogOutputCapabilities AnalogOutputCapabilitiesDefaultValue = global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities.Types.AnalogOutputCapabilities.AnalogOutputUnknown;

    private global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities.Types.AnalogOutputCapabilities analogOutputCapabilities_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities.Types.AnalogOutputCapabilities AnalogOutputCapabilities {
      get { if ((_hasBits0 & 256) != 0) { return analogOutputCapabilities_; } else { return AnalogOutputCapabilitiesDefaultValue; } }
      set {
        _hasBits0 |= 256;
        analogOutputCapabilities_ = value;
      }
    }
    /// <summary>Gets whether the "analog_output_capabilities" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAnalogOutputCapabilities {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "analog_output_capabilities" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAnalogOutputCapabilities() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "can_disable_analog_output" field.</summary>
    public const int CanDisableAnalogOutputFieldNumber = 11;
    private readonly static bool CanDisableAnalogOutputDefaultValue = false;

    private bool canDisableAnalogOutput_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool CanDisableAnalogOutput {
      get { if ((_hasBits0 & 512) != 0) { return canDisableAnalogOutput_; } else { return CanDisableAnalogOutputDefaultValue; } }
      set {
        _hasBits0 |= 512;
        canDisableAnalogOutput_ = value;
      }
    }
    /// <summary>Gets whether the "can_disable_analog_output" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCanDisableAnalogOutput {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "can_disable_analog_output" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCanDisableAnalogOutput() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "resource_rating_tier" field.</summary>
    public const int ResourceRatingTierFieldNumber = 12;
    private readonly static uint ResourceRatingTierDefaultValue = 0;

    private uint resourceRatingTier_;
    /// <summary>
    /// Clients can indicate a performance level supported by OEMCrypto.
    /// This will allow applications and providers to choose an appropriate
    /// quality of content to serve. Currently defined tiers are
    /// 1 (low), 2 (medium) and 3 (high). Any other value indicates that
    /// the resource rating is unavailable or reporting erroneous values
    /// for that device. For details see,
    /// Widevine Modular DRM Security Integration Guide for CENC
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint ResourceRatingTier {
      get { if ((_hasBits0 & 1024) != 0) { return resourceRatingTier_; } else { return ResourceRatingTierDefaultValue; } }
      set {
        _hasBits0 |= 1024;
        resourceRatingTier_ = value;
      }
    }
    /// <summary>Gets whether the "resource_rating_tier" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasResourceRatingTier {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "resource_rating_tier" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearResourceRatingTier() {
      _hasBits0 &= ~1024;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ClientCapabilities);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ClientCapabilities other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ClientToken != other.ClientToken) return false;
      if (SessionToken != other.SessionToken) return false;
      if (VideoResolutionConstraints != other.VideoResolutionConstraints) return false;
      if (MaxHdcpVersion != other.MaxHdcpVersion) return false;
      if (OemCryptoApiVersion != other.OemCryptoApiVersion) return false;
      if (AntiRollbackUsageTable != other.AntiRollbackUsageTable) return false;
      if (SrmVersion != other.SrmVersion) return false;
      if (CanUpdateSrm != other.CanUpdateSrm) return false;
      if(!supportedCertificateKeyType_.Equals(other.supportedCertificateKeyType_)) return false;
      if (AnalogOutputCapabilities != other.AnalogOutputCapabilities) return false;
      if (CanDisableAnalogOutput != other.CanDisableAnalogOutput) return false;
      if (ResourceRatingTier != other.ResourceRatingTier) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasClientToken) hash ^= ClientToken.GetHashCode();
      if (HasSessionToken) hash ^= SessionToken.GetHashCode();
      if (HasVideoResolutionConstraints) hash ^= VideoResolutionConstraints.GetHashCode();
      if (HasMaxHdcpVersion) hash ^= MaxHdcpVersion.GetHashCode();
      if (HasOemCryptoApiVersion) hash ^= OemCryptoApiVersion.GetHashCode();
      if (HasAntiRollbackUsageTable) hash ^= AntiRollbackUsageTable.GetHashCode();
      if (HasSrmVersion) hash ^= SrmVersion.GetHashCode();
      if (HasCanUpdateSrm) hash ^= CanUpdateSrm.GetHashCode();
      hash ^= supportedCertificateKeyType_.GetHashCode();
      if (HasAnalogOutputCapabilities) hash ^= AnalogOutputCapabilities.GetHashCode();
      if (HasCanDisableAnalogOutput) hash ^= CanDisableAnalogOutput.GetHashCode();
      if (HasResourceRatingTier) hash ^= ResourceRatingTier.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasClientToken) {
        output.WriteRawTag(8);
        output.WriteBool(ClientToken);
      }
      if (HasSessionToken) {
        output.WriteRawTag(16);
        output.WriteBool(SessionToken);
      }
      if (HasVideoResolutionConstraints) {
        output.WriteRawTag(24);
        output.WriteBool(VideoResolutionConstraints);
      }
      if (HasMaxHdcpVersion) {
        output.WriteRawTag(32);
        output.WriteEnum((int) MaxHdcpVersion);
      }
      if (HasOemCryptoApiVersion) {
        output.WriteRawTag(40);
        output.WriteUInt32(OemCryptoApiVersion);
      }
      if (HasAntiRollbackUsageTable) {
        output.WriteRawTag(48);
        output.WriteBool(AntiRollbackUsageTable);
      }
      if (HasSrmVersion) {
        output.WriteRawTag(56);
        output.WriteUInt32(SrmVersion);
      }
      if (HasCanUpdateSrm) {
        output.WriteRawTag(64);
        output.WriteBool(CanUpdateSrm);
      }
      supportedCertificateKeyType_.WriteTo(output, _repeated_supportedCertificateKeyType_codec);
      if (HasAnalogOutputCapabilities) {
        output.WriteRawTag(80);
        output.WriteEnum((int) AnalogOutputCapabilities);
      }
      if (HasCanDisableAnalogOutput) {
        output.WriteRawTag(88);
        output.WriteBool(CanDisableAnalogOutput);
      }
      if (HasResourceRatingTier) {
        output.WriteRawTag(96);
        output.WriteUInt32(ResourceRatingTier);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasClientToken) {
        output.WriteRawTag(8);
        output.WriteBool(ClientToken);
      }
      if (HasSessionToken) {
        output.WriteRawTag(16);
        output.WriteBool(SessionToken);
      }
      if (HasVideoResolutionConstraints) {
        output.WriteRawTag(24);
        output.WriteBool(VideoResolutionConstraints);
      }
      if (HasMaxHdcpVersion) {
        output.WriteRawTag(32);
        output.WriteEnum((int) MaxHdcpVersion);
      }
      if (HasOemCryptoApiVersion) {
        output.WriteRawTag(40);
        output.WriteUInt32(OemCryptoApiVersion);
      }
      if (HasAntiRollbackUsageTable) {
        output.WriteRawTag(48);
        output.WriteBool(AntiRollbackUsageTable);
      }
      if (HasSrmVersion) {
        output.WriteRawTag(56);
        output.WriteUInt32(SrmVersion);
      }
      if (HasCanUpdateSrm) {
        output.WriteRawTag(64);
        output.WriteBool(CanUpdateSrm);
      }
      supportedCertificateKeyType_.WriteTo(ref output, _repeated_supportedCertificateKeyType_codec);
      if (HasAnalogOutputCapabilities) {
        output.WriteRawTag(80);
        output.WriteEnum((int) AnalogOutputCapabilities);
      }
      if (HasCanDisableAnalogOutput) {
        output.WriteRawTag(88);
        output.WriteBool(CanDisableAnalogOutput);
      }
      if (HasResourceRatingTier) {
        output.WriteRawTag(96);
        output.WriteUInt32(ResourceRatingTier);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasClientToken) {
        size += 1 + 1;
      }
      if (HasSessionToken) {
        size += 1 + 1;
      }
      if (HasVideoResolutionConstraints) {
        size += 1 + 1;
      }
      if (HasMaxHdcpVersion) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) MaxHdcpVersion);
      }
      if (HasOemCryptoApiVersion) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(OemCryptoApiVersion);
      }
      if (HasAntiRollbackUsageTable) {
        size += 1 + 1;
      }
      if (HasSrmVersion) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SrmVersion);
      }
      if (HasCanUpdateSrm) {
        size += 1 + 1;
      }
      size += supportedCertificateKeyType_.CalculateSize(_repeated_supportedCertificateKeyType_codec);
      if (HasAnalogOutputCapabilities) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) AnalogOutputCapabilities);
      }
      if (HasCanDisableAnalogOutput) {
        size += 1 + 1;
      }
      if (HasResourceRatingTier) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ResourceRatingTier);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ClientCapabilities other) {
      if (other == null) {
        return;
      }
      if (other.HasClientToken) {
        ClientToken = other.ClientToken;
      }
      if (other.HasSessionToken) {
        SessionToken = other.SessionToken;
      }
      if (other.HasVideoResolutionConstraints) {
        VideoResolutionConstraints = other.VideoResolutionConstraints;
      }
      if (other.HasMaxHdcpVersion) {
        MaxHdcpVersion = other.MaxHdcpVersion;
      }
      if (other.HasOemCryptoApiVersion) {
        OemCryptoApiVersion = other.OemCryptoApiVersion;
      }
      if (other.HasAntiRollbackUsageTable) {
        AntiRollbackUsageTable = other.AntiRollbackUsageTable;
      }
      if (other.HasSrmVersion) {
        SrmVersion = other.SrmVersion;
      }
      if (other.HasCanUpdateSrm) {
        CanUpdateSrm = other.CanUpdateSrm;
      }
      supportedCertificateKeyType_.Add(other.supportedCertificateKeyType_);
      if (other.HasAnalogOutputCapabilities) {
        AnalogOutputCapabilities = other.AnalogOutputCapabilities;
      }
      if (other.HasCanDisableAnalogOutput) {
        CanDisableAnalogOutput = other.CanDisableAnalogOutput;
      }
      if (other.HasResourceRatingTier) {
        ResourceRatingTier = other.ResourceRatingTier;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ClientToken = input.ReadBool();
            break;
          }
          case 16: {
            SessionToken = input.ReadBool();
            break;
          }
          case 24: {
            VideoResolutionConstraints = input.ReadBool();
            break;
          }
          case 32: {
            MaxHdcpVersion = (global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities.Types.HdcpVersion) input.ReadEnum();
            break;
          }
          case 40: {
            OemCryptoApiVersion = input.ReadUInt32();
            break;
          }
          case 48: {
            AntiRollbackUsageTable = input.ReadBool();
            break;
          }
          case 56: {
            SrmVersion = input.ReadUInt32();
            break;
          }
          case 64: {
            CanUpdateSrm = input.ReadBool();
            break;
          }
          case 74:
          case 72: {
            supportedCertificateKeyType_.AddEntriesFrom(input, _repeated_supportedCertificateKeyType_codec);
            break;
          }
          case 80: {
            AnalogOutputCapabilities = (global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities.Types.AnalogOutputCapabilities) input.ReadEnum();
            break;
          }
          case 88: {
            CanDisableAnalogOutput = input.ReadBool();
            break;
          }
          case 96: {
            ResourceRatingTier = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ClientToken = input.ReadBool();
            break;
          }
          case 16: {
            SessionToken = input.ReadBool();
            break;
          }
          case 24: {
            VideoResolutionConstraints = input.ReadBool();
            break;
          }
          case 32: {
            MaxHdcpVersion = (global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities.Types.HdcpVersion) input.ReadEnum();
            break;
          }
          case 40: {
            OemCryptoApiVersion = input.ReadUInt32();
            break;
          }
          case 48: {
            AntiRollbackUsageTable = input.ReadBool();
            break;
          }
          case 56: {
            SrmVersion = input.ReadUInt32();
            break;
          }
          case 64: {
            CanUpdateSrm = input.ReadBool();
            break;
          }
          case 74:
          case 72: {
            supportedCertificateKeyType_.AddEntriesFrom(ref input, _repeated_supportedCertificateKeyType_codec);
            break;
          }
          case 80: {
            AnalogOutputCapabilities = (global::AudibleUtilities.Widevine.ClientIdentification.Types.ClientCapabilities.Types.AnalogOutputCapabilities) input.ReadEnum();
            break;
          }
          case 88: {
            CanDisableAnalogOutput = input.ReadBool();
            break;
          }
          case 96: {
            ResourceRatingTier = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ClientCapabilities message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      internal enum HdcpVersion {
        [pbr::OriginalName("HDCP_NONE")] HdcpNone = 0,
        [pbr::OriginalName("HDCP_V1")] HdcpV1 = 1,
        [pbr::OriginalName("HDCP_V2")] HdcpV2 = 2,
        [pbr::OriginalName("HDCP_V2_1")] HdcpV21 = 3,
        [pbr::OriginalName("HDCP_V2_2")] HdcpV22 = 4,
        [pbr::OriginalName("HDCP_V2_3")] HdcpV23 = 5,
        [pbr::OriginalName("HDCP_NO_DIGITAL_OUTPUT")] HdcpNoDigitalOutput = 255,
      }

      internal enum CertificateKeyType {
        [pbr::OriginalName("RSA_2048")] Rsa2048 = 0,
        [pbr::OriginalName("RSA_3072")] Rsa3072 = 1,
        [pbr::OriginalName("ECC_SECP256R1")] EccSecp256R1 = 2,
        [pbr::OriginalName("ECC_SECP384R1")] EccSecp384R1 = 3,
        [pbr::OriginalName("ECC_SECP521R1")] EccSecp521R1 = 4,
      }

      internal enum AnalogOutputCapabilities {
        [pbr::OriginalName("ANALOG_OUTPUT_UNKNOWN")] AnalogOutputUnknown = 0,
        [pbr::OriginalName("ANALOG_OUTPUT_NONE")] AnalogOutputNone = 1,
        [pbr::OriginalName("ANALOG_OUTPUT_SUPPORTED")] AnalogOutputSupported = 2,
        [pbr::OriginalName("ANALOG_OUTPUT_SUPPORTS_CGMS_A")] AnalogOutputSupportsCgmsA = 3,
      }

    }
    #endregion

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  internal sealed partial class ClientCredentials : pb::IMessage<ClientCredentials>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ClientCredentials> _parser = new pb::MessageParser<ClientCredentials>(() => new ClientCredentials());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ClientCredentials> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AudibleUtilities.Widevine.ClientIdentification.Descriptor.NestedTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ClientCredentials() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ClientCredentials(ClientCredentials other) : this() {
      _hasBits0 = other._hasBits0;
      type_ = other.type_;
      token_ = other.token_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ClientCredentials Clone() {
      return new ClientCredentials(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private readonly static global::AudibleUtilities.Widevine.ClientIdentification.Types.TokenType TypeDefaultValue = global::AudibleUtilities.Widevine.ClientIdentification.Types.TokenType.Keybox;

    private global::AudibleUtilities.Widevine.ClientIdentification.Types.TokenType type_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AudibleUtilities.Widevine.ClientIdentification.Types.TokenType Type {
      get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        type_ = value;
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "token" field.</summary>
    public const int TokenFieldNumber = 2;
    private readonly static pb::ByteString TokenDefaultValue = pb::ByteString.Empty;

    private pb::ByteString token_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Token {
      get { return token_ ?? TokenDefaultValue; }
      set {
        token_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "token" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasToken {
      get { return token_ != null; }
    }
    /// <summary>Clears the value of the "token" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearToken() {
      token_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ClientCredentials);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ClientCredentials other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (Token != other.Token) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasType) hash ^= Type.GetHashCode();
      if (HasToken) hash ^= Token.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (HasToken) {
        output.WriteRawTag(18);
        output.WriteBytes(Token);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (HasToken) {
        output.WriteRawTag(18);
        output.WriteBytes(Token);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (HasToken) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Token);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ClientCredentials other) {
      if (other == null) {
        return;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasToken) {
        Token = other.Token;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Type = (global::AudibleUtilities.Widevine.ClientIdentification.Types.TokenType) input.ReadEnum();
            break;
          }
          case 18: {
            Token = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Type = (global::AudibleUtilities.Widevine.ClientIdentification.Types.TokenType) input.ReadEnum();
            break;
          }
          case 18: {
            Token = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

}
#endregion

}

/// <summary>
/// EncryptedClientIdentification message used to hold ClientIdentification
/// messages encrypted for privacy purposes.
/// </summary>
[global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
internal sealed partial class EncryptedClientIdentification : pb::IMessage<EncryptedClientIdentification>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  , pb::IBufferMessage
#endif
{
private static readonly pb::MessageParser<EncryptedClientIdentification> _parser = new pb::MessageParser<EncryptedClientIdentification>(() => new EncryptedClientIdentification());
private pb::UnknownFieldSet _unknownFields;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pb::MessageParser<EncryptedClientIdentification> Parser { get { return _parser; } }

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pbr::MessageDescriptor Descriptor {
  get { return global::AudibleUtilities.Widevine.LicenseProtocolReflection.Descriptor.MessageTypes[7]; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
pbr::MessageDescriptor pb::IMessage.Descriptor {
  get { return Descriptor; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public EncryptedClientIdentification() {
  OnConstruction();
}

partial void OnConstruction();

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public EncryptedClientIdentification(EncryptedClientIdentification other) : this() {
  providerId_ = other.providerId_;
  serviceCertificateSerialNumber_ = other.serviceCertificateSerialNumber_;
  encryptedClientId_ = other.encryptedClientId_;
  encryptedClientIdIv_ = other.encryptedClientIdIv_;
  encryptedPrivacyKey_ = other.encryptedPrivacyKey_;
  _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public EncryptedClientIdentification Clone() {
  return new EncryptedClientIdentification(this);
}

/// <summary>Field number for the "provider_id" field.</summary>
public const int ProviderIdFieldNumber = 1;
private readonly static string ProviderIdDefaultValue = "";

private string providerId_;
/// <summary>
/// Provider ID for which the ClientIdentifcation is encrypted (owner of
/// service certificate).
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public string ProviderId {
  get { return providerId_ ?? ProviderIdDefaultValue; }
  set {
    providerId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "provider_id" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasProviderId {
  get { return providerId_ != null; }
}
/// <summary>Clears the value of the "provider_id" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearProviderId() {
  providerId_ = null;
}

/// <summary>Field number for the "service_certificate_serial_number" field.</summary>
public const int ServiceCertificateSerialNumberFieldNumber = 2;
private readonly static pb::ByteString ServiceCertificateSerialNumberDefaultValue = pb::ByteString.Empty;

private pb::ByteString serviceCertificateSerialNumber_;
/// <summary>
/// Serial number for the service certificate for which ClientIdentification is
/// encrypted.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString ServiceCertificateSerialNumber {
  get { return serviceCertificateSerialNumber_ ?? ServiceCertificateSerialNumberDefaultValue; }
  set {
    serviceCertificateSerialNumber_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "service_certificate_serial_number" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasServiceCertificateSerialNumber {
  get { return serviceCertificateSerialNumber_ != null; }
}
/// <summary>Clears the value of the "service_certificate_serial_number" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearServiceCertificateSerialNumber() {
  serviceCertificateSerialNumber_ = null;
}

/// <summary>Field number for the "encrypted_client_id" field.</summary>
public const int EncryptedClientIdFieldNumber = 3;
private readonly static pb::ByteString EncryptedClientIdDefaultValue = pb::ByteString.Empty;

private pb::ByteString encryptedClientId_;
/// <summary>
/// Serialized ClientIdentification message, encrypted with the privacy key
/// using AES-128-CBC with PKCS#5 padding.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString EncryptedClientId {
  get { return encryptedClientId_ ?? EncryptedClientIdDefaultValue; }
  set {
    encryptedClientId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "encrypted_client_id" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasEncryptedClientId {
  get { return encryptedClientId_ != null; }
}
/// <summary>Clears the value of the "encrypted_client_id" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearEncryptedClientId() {
  encryptedClientId_ = null;
}

/// <summary>Field number for the "encrypted_client_id_iv" field.</summary>
public const int EncryptedClientIdIvFieldNumber = 4;
private readonly static pb::ByteString EncryptedClientIdIvDefaultValue = pb::ByteString.Empty;

private pb::ByteString encryptedClientIdIv_;
/// <summary>
/// Initialization vector needed to decrypt encrypted_client_id.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString EncryptedClientIdIv {
  get { return encryptedClientIdIv_ ?? EncryptedClientIdIvDefaultValue; }
  set {
    encryptedClientIdIv_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "encrypted_client_id_iv" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasEncryptedClientIdIv {
  get { return encryptedClientIdIv_ != null; }
}
/// <summary>Clears the value of the "encrypted_client_id_iv" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearEncryptedClientIdIv() {
  encryptedClientIdIv_ = null;
}

/// <summary>Field number for the "encrypted_privacy_key" field.</summary>
public const int EncryptedPrivacyKeyFieldNumber = 5;
private readonly static pb::ByteString EncryptedPrivacyKeyDefaultValue = pb::ByteString.Empty;

private pb::ByteString encryptedPrivacyKey_;
/// <summary>
/// AES-128 privacy key, encrypted with the service public key using RSA-OAEP.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString EncryptedPrivacyKey {
  get { return encryptedPrivacyKey_ ?? EncryptedPrivacyKeyDefaultValue; }
  set {
    encryptedPrivacyKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "encrypted_privacy_key" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasEncryptedPrivacyKey {
  get { return encryptedPrivacyKey_ != null; }
}
/// <summary>Clears the value of the "encrypted_privacy_key" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearEncryptedPrivacyKey() {
  encryptedPrivacyKey_ = null;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override bool Equals(object other) {
  return Equals(other as EncryptedClientIdentification);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool Equals(EncryptedClientIdentification other) {
  if (ReferenceEquals(other, null)) {
    return false;
  }
  if (ReferenceEquals(other, this)) {
    return true;
  }
  if (ProviderId != other.ProviderId) return false;
  if (ServiceCertificateSerialNumber != other.ServiceCertificateSerialNumber) return false;
  if (EncryptedClientId != other.EncryptedClientId) return false;
  if (EncryptedClientIdIv != other.EncryptedClientIdIv) return false;
  if (EncryptedPrivacyKey != other.EncryptedPrivacyKey) return false;
  return Equals(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override int GetHashCode() {
  int hash = 1;
  if (HasProviderId) hash ^= ProviderId.GetHashCode();
  if (HasServiceCertificateSerialNumber) hash ^= ServiceCertificateSerialNumber.GetHashCode();
  if (HasEncryptedClientId) hash ^= EncryptedClientId.GetHashCode();
  if (HasEncryptedClientIdIv) hash ^= EncryptedClientIdIv.GetHashCode();
  if (HasEncryptedPrivacyKey) hash ^= EncryptedPrivacyKey.GetHashCode();
  if (_unknownFields != null) {
    hash ^= _unknownFields.GetHashCode();
  }
  return hash;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override string ToString() {
  return pb::JsonFormatter.ToDiagnosticString(this);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void WriteTo(pb::CodedOutputStream output) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  output.WriteRawMessage(this);
#else
  if (HasProviderId) {
    output.WriteRawTag(10);
    output.WriteString(ProviderId);
  }
  if (HasServiceCertificateSerialNumber) {
    output.WriteRawTag(18);
    output.WriteBytes(ServiceCertificateSerialNumber);
  }
  if (HasEncryptedClientId) {
    output.WriteRawTag(26);
    output.WriteBytes(EncryptedClientId);
  }
  if (HasEncryptedClientIdIv) {
    output.WriteRawTag(34);
    output.WriteBytes(EncryptedClientIdIv);
  }
  if (HasEncryptedPrivacyKey) {
    output.WriteRawTag(42);
    output.WriteBytes(EncryptedPrivacyKey);
  }
  if (_unknownFields != null) {
    _unknownFields.WriteTo(output);
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
  if (HasProviderId) {
    output.WriteRawTag(10);
    output.WriteString(ProviderId);
  }
  if (HasServiceCertificateSerialNumber) {
    output.WriteRawTag(18);
    output.WriteBytes(ServiceCertificateSerialNumber);
  }
  if (HasEncryptedClientId) {
    output.WriteRawTag(26);
    output.WriteBytes(EncryptedClientId);
  }
  if (HasEncryptedClientIdIv) {
    output.WriteRawTag(34);
    output.WriteBytes(EncryptedClientIdIv);
  }
  if (HasEncryptedPrivacyKey) {
    output.WriteRawTag(42);
    output.WriteBytes(EncryptedPrivacyKey);
  }
  if (_unknownFields != null) {
    _unknownFields.WriteTo(ref output);
  }
}
#endif

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public int CalculateSize() {
  int size = 0;
  if (HasProviderId) {
    size += 1 + pb::CodedOutputStream.ComputeStringSize(ProviderId);
  }
  if (HasServiceCertificateSerialNumber) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(ServiceCertificateSerialNumber);
  }
  if (HasEncryptedClientId) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(EncryptedClientId);
  }
  if (HasEncryptedClientIdIv) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(EncryptedClientIdIv);
  }
  if (HasEncryptedPrivacyKey) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(EncryptedPrivacyKey);
  }
  if (_unknownFields != null) {
    size += _unknownFields.CalculateSize();
  }
  return size;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(EncryptedClientIdentification other) {
  if (other == null) {
    return;
  }
  if (other.HasProviderId) {
    ProviderId = other.ProviderId;
  }
  if (other.HasServiceCertificateSerialNumber) {
    ServiceCertificateSerialNumber = other.ServiceCertificateSerialNumber;
  }
  if (other.HasEncryptedClientId) {
    EncryptedClientId = other.EncryptedClientId;
  }
  if (other.HasEncryptedClientIdIv) {
    EncryptedClientIdIv = other.EncryptedClientIdIv;
  }
  if (other.HasEncryptedPrivacyKey) {
    EncryptedPrivacyKey = other.EncryptedPrivacyKey;
  }
  _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(pb::CodedInputStream input) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  input.ReadRawMessage(this);
#else
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
        break;
      case 10: {
        ProviderId = input.ReadString();
        break;
      }
      case 18: {
        ServiceCertificateSerialNumber = input.ReadBytes();
        break;
      }
      case 26: {
        EncryptedClientId = input.ReadBytes();
        break;
      }
      case 34: {
        EncryptedClientIdIv = input.ReadBytes();
        break;
      }
      case 42: {
        EncryptedPrivacyKey = input.ReadBytes();
        break;
      }
    }
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
        break;
      case 10: {
        ProviderId = input.ReadString();
        break;
      }
      case 18: {
        ServiceCertificateSerialNumber = input.ReadBytes();
        break;
      }
      case 26: {
        EncryptedClientId = input.ReadBytes();
        break;
      }
      case 34: {
        EncryptedClientIdIv = input.ReadBytes();
        break;
      }
      case 42: {
        EncryptedPrivacyKey = input.ReadBytes();
        break;
      }
    }
  }
}
#endif

}

/// <summary>
/// DRM certificate definition for user devices, intermediate, service, and root
/// certificates.
/// </summary>
[global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
internal sealed partial class DrmCertificate : pb::IMessage<DrmCertificate>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  , pb::IBufferMessage
#endif
{
private static readonly pb::MessageParser<DrmCertificate> _parser = new pb::MessageParser<DrmCertificate>(() => new DrmCertificate());
private pb::UnknownFieldSet _unknownFields;
private int _hasBits0;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pb::MessageParser<DrmCertificate> Parser { get { return _parser; } }

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pbr::MessageDescriptor Descriptor {
  get { return global::AudibleUtilities.Widevine.LicenseProtocolReflection.Descriptor.MessageTypes[8]; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
pbr::MessageDescriptor pb::IMessage.Descriptor {
  get { return Descriptor; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public DrmCertificate() {
  OnConstruction();
}

partial void OnConstruction();

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public DrmCertificate(DrmCertificate other) : this() {
  _hasBits0 = other._hasBits0;
  type_ = other.type_;
  serialNumber_ = other.serialNumber_;
  creationTimeSeconds_ = other.creationTimeSeconds_;
  expirationTimeSeconds_ = other.expirationTimeSeconds_;
  publicKey_ = other.publicKey_;
  systemId_ = other.systemId_;
  testDeviceDeprecated_ = other.testDeviceDeprecated_;
  providerId_ = other.providerId_;
  serviceTypes_ = other.serviceTypes_.Clone();
  algorithm_ = other.algorithm_;
  rotId_ = other.rotId_;
  encryptionKey_ = other.encryptionKey_ != null ? other.encryptionKey_.Clone() : null;
  _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public DrmCertificate Clone() {
  return new DrmCertificate(this);
}

/// <summary>Field number for the "type" field.</summary>
public const int TypeFieldNumber = 1;
private readonly static global::AudibleUtilities.Widevine.DrmCertificate.Types.Type TypeDefaultValue = global::AudibleUtilities.Widevine.DrmCertificate.Types.Type.Root;

private global::AudibleUtilities.Widevine.DrmCertificate.Types.Type type_;
/// <summary>
/// Type of certificate. Required.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public global::AudibleUtilities.Widevine.DrmCertificate.Types.Type Type {
  get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
  set {
    _hasBits0 |= 1;
    type_ = value;
  }
}
/// <summary>Gets whether the "type" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasType {
  get { return (_hasBits0 & 1) != 0; }
}
/// <summary>Clears the value of the "type" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearType() {
  _hasBits0 &= ~1;
}

/// <summary>Field number for the "serial_number" field.</summary>
public const int SerialNumberFieldNumber = 2;
private readonly static pb::ByteString SerialNumberDefaultValue = pb::ByteString.Empty;

private pb::ByteString serialNumber_;
/// <summary>
/// 128-bit globally unique serial number of certificate.
/// Value is 0 for root certificate. Required.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString SerialNumber {
  get { return serialNumber_ ?? SerialNumberDefaultValue; }
  set {
    serialNumber_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "serial_number" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasSerialNumber {
  get { return serialNumber_ != null; }
}
/// <summary>Clears the value of the "serial_number" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearSerialNumber() {
  serialNumber_ = null;
}

/// <summary>Field number for the "creation_time_seconds" field.</summary>
public const int CreationTimeSecondsFieldNumber = 3;
private readonly static uint CreationTimeSecondsDefaultValue = 0;

private uint creationTimeSeconds_;
/// <summary>
/// POSIX time, in seconds, when the certificate was created. Required.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public uint CreationTimeSeconds {
  get { if ((_hasBits0 & 2) != 0) { return creationTimeSeconds_; } else { return CreationTimeSecondsDefaultValue; } }
  set {
    _hasBits0 |= 2;
    creationTimeSeconds_ = value;
  }
}
/// <summary>Gets whether the "creation_time_seconds" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasCreationTimeSeconds {
  get { return (_hasBits0 & 2) != 0; }
}
/// <summary>Clears the value of the "creation_time_seconds" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearCreationTimeSeconds() {
  _hasBits0 &= ~2;
}

/// <summary>Field number for the "expiration_time_seconds" field.</summary>
public const int ExpirationTimeSecondsFieldNumber = 12;
private readonly static uint ExpirationTimeSecondsDefaultValue = 0;

private uint expirationTimeSeconds_;
/// <summary>
/// POSIX time, in seconds, when the certificate should expire. Value of zero
/// denotes indefinite expiry time. For more information on limited lifespan
/// DRM certificates see (go/limited-lifespan-drm-certificates).
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public uint ExpirationTimeSeconds {
  get { if ((_hasBits0 & 32) != 0) { return expirationTimeSeconds_; } else { return ExpirationTimeSecondsDefaultValue; } }
  set {
    _hasBits0 |= 32;
    expirationTimeSeconds_ = value;
  }
}
/// <summary>Gets whether the "expiration_time_seconds" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasExpirationTimeSeconds {
  get { return (_hasBits0 & 32) != 0; }
}
/// <summary>Clears the value of the "expiration_time_seconds" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearExpirationTimeSeconds() {
  _hasBits0 &= ~32;
}

/// <summary>Field number for the "public_key" field.</summary>
public const int PublicKeyFieldNumber = 4;
private readonly static pb::ByteString PublicKeyDefaultValue = pb::ByteString.Empty;

private pb::ByteString publicKey_;
/// <summary>
/// Device public key. PKCS#1 ASN.1 DER-encoded. Required.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString PublicKey {
  get { return publicKey_ ?? PublicKeyDefaultValue; }
  set {
    publicKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "public_key" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasPublicKey {
  get { return publicKey_ != null; }
}
/// <summary>Clears the value of the "public_key" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearPublicKey() {
  publicKey_ = null;
}

/// <summary>Field number for the "system_id" field.</summary>
public const int SystemIdFieldNumber = 5;
private readonly static uint SystemIdDefaultValue = 0;

private uint systemId_;
/// <summary>
/// Widevine system ID for the device. Required for intermediate and
/// user device certificates.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public uint SystemId {
  get { if ((_hasBits0 & 4) != 0) { return systemId_; } else { return SystemIdDefaultValue; } }
  set {
    _hasBits0 |= 4;
    systemId_ = value;
  }
}
/// <summary>Gets whether the "system_id" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasSystemId {
  get { return (_hasBits0 & 4) != 0; }
}
/// <summary>Clears the value of the "system_id" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearSystemId() {
  _hasBits0 &= ~4;
}

/// <summary>Field number for the "test_device_deprecated" field.</summary>
public const int TestDeviceDeprecatedFieldNumber = 6;
private readonly static bool TestDeviceDeprecatedDefaultValue = false;

private bool testDeviceDeprecated_;
/// <summary>
/// Deprecated field, which used to indicate whether the device was a test
/// (non-production) device. The test_device field in ProvisionedDeviceInfo
/// below should be observed instead.
/// </summary>
[global::System.ObsoleteAttribute]
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool TestDeviceDeprecated {
  get { if ((_hasBits0 & 8) != 0) { return testDeviceDeprecated_; } else { return TestDeviceDeprecatedDefaultValue; } }
  set {
    _hasBits0 |= 8;
    testDeviceDeprecated_ = value;
  }
}
/// <summary>Gets whether the "test_device_deprecated" field is set</summary>
[global::System.ObsoleteAttribute]
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasTestDeviceDeprecated {
  get { return (_hasBits0 & 8) != 0; }
}
/// <summary>Clears the value of the "test_device_deprecated" field</summary>
[global::System.ObsoleteAttribute]
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearTestDeviceDeprecated() {
  _hasBits0 &= ~8;
}

/// <summary>Field number for the "provider_id" field.</summary>
public const int ProviderIdFieldNumber = 7;
private readonly static string ProviderIdDefaultValue = "";

private string providerId_;
/// <summary>
/// Service identifier (web origin) for the provider which owns the
/// certificate. Required for service and provisioner certificates.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public string ProviderId {
  get { return providerId_ ?? ProviderIdDefaultValue; }
  set {
    providerId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "provider_id" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasProviderId {
  get { return providerId_ != null; }
}
/// <summary>Clears the value of the "provider_id" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearProviderId() {
  providerId_ = null;
}

/// <summary>Field number for the "service_types" field.</summary>
public const int ServiceTypesFieldNumber = 8;
private static readonly pb::FieldCodec<global::AudibleUtilities.Widevine.DrmCertificate.Types.ServiceType> _repeated_serviceTypes_codec
    = pb::FieldCodec.ForEnum(64, x => (int) x, x => (global::AudibleUtilities.Widevine.DrmCertificate.Types.ServiceType) x);
private readonly pbc::RepeatedField<global::AudibleUtilities.Widevine.DrmCertificate.Types.ServiceType> serviceTypes_ = new pbc::RepeatedField<global::AudibleUtilities.Widevine.DrmCertificate.Types.ServiceType>();
/// <summary>
/// This field is used only when type = SERVICE to specify which SDK uses
/// service certificate. This repeated field is treated as a set. A certificate
/// may be used for the specified service SDK if the appropriate ServiceType
/// is specified in this field.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pbc::RepeatedField<global::AudibleUtilities.Widevine.DrmCertificate.Types.ServiceType> ServiceTypes {
  get { return serviceTypes_; }
}

/// <summary>Field number for the "algorithm" field.</summary>
public const int AlgorithmFieldNumber = 9;
private readonly static global::AudibleUtilities.Widevine.DrmCertificate.Types.Algorithm AlgorithmDefaultValue = global::AudibleUtilities.Widevine.DrmCertificate.Types.Algorithm.Rsa;

private global::AudibleUtilities.Widevine.DrmCertificate.Types.Algorithm algorithm_;
/// <summary>
/// Required. The algorithm field contains the curve used to create the
/// |public_key| if algorithm is one of the ECC types.
/// The |algorithm| is used for both to determine the if the certificate is ECC
/// or RSA. The |algorithm| also specifies the parameters that were used to
/// create |public_key| and are used to create an ephemeral session key.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public global::AudibleUtilities.Widevine.DrmCertificate.Types.Algorithm Algorithm {
  get { if ((_hasBits0 & 16) != 0) { return algorithm_; } else { return AlgorithmDefaultValue; } }
  set {
    _hasBits0 |= 16;
    algorithm_ = value;
  }
}
/// <summary>Gets whether the "algorithm" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasAlgorithm {
  get { return (_hasBits0 & 16) != 0; }
}
/// <summary>Clears the value of the "algorithm" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearAlgorithm() {
  _hasBits0 &= ~16;
}

/// <summary>Field number for the "rot_id" field.</summary>
public const int RotIdFieldNumber = 10;
private readonly static pb::ByteString RotIdDefaultValue = pb::ByteString.Empty;

private pb::ByteString rotId_;
/// <summary>
/// Optional. May be present in DEVICE certificate types. This is the root
/// of trust identifier that holds an encrypted value that identifies the
/// keybox or other root of trust that was used to provision a DEVICE drm
/// certificate.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString RotId {
  get { return rotId_ ?? RotIdDefaultValue; }
  set {
    rotId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "rot_id" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasRotId {
  get { return rotId_ != null; }
}
/// <summary>Clears the value of the "rot_id" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearRotId() {
  rotId_ = null;
}

/// <summary>Field number for the "encryption_key" field.</summary>
public const int EncryptionKeyFieldNumber = 11;
private global::AudibleUtilities.Widevine.DrmCertificate.Types.EncryptionKey encryptionKey_;
/// <summary>
/// Optional. May be present in devices that explicitly support dual keys. When
/// present the |public_key| is used for verification of received license
/// request messages.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public global::AudibleUtilities.Widevine.DrmCertificate.Types.EncryptionKey EncryptionKey {
  get { return encryptionKey_; }
  set {
    encryptionKey_ = value;
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override bool Equals(object other) {
  return Equals(other as DrmCertificate);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool Equals(DrmCertificate other) {
  if (ReferenceEquals(other, null)) {
    return false;
  }
  if (ReferenceEquals(other, this)) {
    return true;
  }
  if (Type != other.Type) return false;
  if (SerialNumber != other.SerialNumber) return false;
  if (CreationTimeSeconds != other.CreationTimeSeconds) return false;
  if (ExpirationTimeSeconds != other.ExpirationTimeSeconds) return false;
  if (PublicKey != other.PublicKey) return false;
  if (SystemId != other.SystemId) return false;
  if (TestDeviceDeprecated != other.TestDeviceDeprecated) return false;
  if (ProviderId != other.ProviderId) return false;
  if(!serviceTypes_.Equals(other.serviceTypes_)) return false;
  if (Algorithm != other.Algorithm) return false;
  if (RotId != other.RotId) return false;
  if (!object.Equals(EncryptionKey, other.EncryptionKey)) return false;
  return Equals(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override int GetHashCode() {
  int hash = 1;
  if (HasType) hash ^= Type.GetHashCode();
  if (HasSerialNumber) hash ^= SerialNumber.GetHashCode();
  if (HasCreationTimeSeconds) hash ^= CreationTimeSeconds.GetHashCode();
  if (HasExpirationTimeSeconds) hash ^= ExpirationTimeSeconds.GetHashCode();
  if (HasPublicKey) hash ^= PublicKey.GetHashCode();
  if (HasSystemId) hash ^= SystemId.GetHashCode();
  if (HasTestDeviceDeprecated) hash ^= TestDeviceDeprecated.GetHashCode();
  if (HasProviderId) hash ^= ProviderId.GetHashCode();
  hash ^= serviceTypes_.GetHashCode();
  if (HasAlgorithm) hash ^= Algorithm.GetHashCode();
  if (HasRotId) hash ^= RotId.GetHashCode();
  if (encryptionKey_ != null) hash ^= EncryptionKey.GetHashCode();
  if (_unknownFields != null) {
    hash ^= _unknownFields.GetHashCode();
  }
  return hash;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override string ToString() {
  return pb::JsonFormatter.ToDiagnosticString(this);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void WriteTo(pb::CodedOutputStream output) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  output.WriteRawMessage(this);
#else
  if (HasType) {
    output.WriteRawTag(8);
    output.WriteEnum((int) Type);
  }
  if (HasSerialNumber) {
    output.WriteRawTag(18);
    output.WriteBytes(SerialNumber);
  }
  if (HasCreationTimeSeconds) {
    output.WriteRawTag(24);
    output.WriteUInt32(CreationTimeSeconds);
  }
  if (HasPublicKey) {
    output.WriteRawTag(34);
    output.WriteBytes(PublicKey);
  }
  if (HasSystemId) {
    output.WriteRawTag(40);
    output.WriteUInt32(SystemId);
  }
  if (HasTestDeviceDeprecated) {
    output.WriteRawTag(48);
    output.WriteBool(TestDeviceDeprecated);
  }
  if (HasProviderId) {
    output.WriteRawTag(58);
    output.WriteString(ProviderId);
  }
  serviceTypes_.WriteTo(output, _repeated_serviceTypes_codec);
  if (HasAlgorithm) {
    output.WriteRawTag(72);
    output.WriteEnum((int) Algorithm);
  }
  if (HasRotId) {
    output.WriteRawTag(82);
    output.WriteBytes(RotId);
  }
  if (encryptionKey_ != null) {
    output.WriteRawTag(90);
    output.WriteMessage(EncryptionKey);
  }
  if (HasExpirationTimeSeconds) {
    output.WriteRawTag(96);
    output.WriteUInt32(ExpirationTimeSeconds);
  }
  if (_unknownFields != null) {
    _unknownFields.WriteTo(output);
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
  if (HasType) {
    output.WriteRawTag(8);
    output.WriteEnum((int) Type);
  }
  if (HasSerialNumber) {
    output.WriteRawTag(18);
    output.WriteBytes(SerialNumber);
  }
  if (HasCreationTimeSeconds) {
    output.WriteRawTag(24);
    output.WriteUInt32(CreationTimeSeconds);
  }
  if (HasPublicKey) {
    output.WriteRawTag(34);
    output.WriteBytes(PublicKey);
  }
  if (HasSystemId) {
    output.WriteRawTag(40);
    output.WriteUInt32(SystemId);
  }
  if (HasTestDeviceDeprecated) {
    output.WriteRawTag(48);
    output.WriteBool(TestDeviceDeprecated);
  }
  if (HasProviderId) {
    output.WriteRawTag(58);
    output.WriteString(ProviderId);
  }
  serviceTypes_.WriteTo(ref output, _repeated_serviceTypes_codec);
  if (HasAlgorithm) {
    output.WriteRawTag(72);
    output.WriteEnum((int) Algorithm);
  }
  if (HasRotId) {
    output.WriteRawTag(82);
    output.WriteBytes(RotId);
  }
  if (encryptionKey_ != null) {
    output.WriteRawTag(90);
    output.WriteMessage(EncryptionKey);
  }
  if (HasExpirationTimeSeconds) {
    output.WriteRawTag(96);
    output.WriteUInt32(ExpirationTimeSeconds);
  }
  if (_unknownFields != null) {
    _unknownFields.WriteTo(ref output);
  }
}
#endif

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public int CalculateSize() {
  int size = 0;
  if (HasType) {
    size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
  }
  if (HasSerialNumber) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(SerialNumber);
  }
  if (HasCreationTimeSeconds) {
    size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CreationTimeSeconds);
  }
  if (HasExpirationTimeSeconds) {
    size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ExpirationTimeSeconds);
  }
  if (HasPublicKey) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(PublicKey);
  }
  if (HasSystemId) {
    size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SystemId);
  }
  if (HasTestDeviceDeprecated) {
    size += 1 + 1;
  }
  if (HasProviderId) {
    size += 1 + pb::CodedOutputStream.ComputeStringSize(ProviderId);
  }
  size += serviceTypes_.CalculateSize(_repeated_serviceTypes_codec);
  if (HasAlgorithm) {
    size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Algorithm);
  }
  if (HasRotId) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(RotId);
  }
  if (encryptionKey_ != null) {
    size += 1 + pb::CodedOutputStream.ComputeMessageSize(EncryptionKey);
  }
  if (_unknownFields != null) {
    size += _unknownFields.CalculateSize();
  }
  return size;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(DrmCertificate other) {
  if (other == null) {
    return;
  }
  if (other.HasType) {
    Type = other.Type;
  }
  if (other.HasSerialNumber) {
    SerialNumber = other.SerialNumber;
  }
  if (other.HasCreationTimeSeconds) {
    CreationTimeSeconds = other.CreationTimeSeconds;
  }
  if (other.HasExpirationTimeSeconds) {
    ExpirationTimeSeconds = other.ExpirationTimeSeconds;
  }
  if (other.HasPublicKey) {
    PublicKey = other.PublicKey;
  }
  if (other.HasSystemId) {
    SystemId = other.SystemId;
  }
  if (other.HasTestDeviceDeprecated) {
    TestDeviceDeprecated = other.TestDeviceDeprecated;
  }
  if (other.HasProviderId) {
    ProviderId = other.ProviderId;
  }
  serviceTypes_.Add(other.serviceTypes_);
  if (other.HasAlgorithm) {
    Algorithm = other.Algorithm;
  }
  if (other.HasRotId) {
    RotId = other.RotId;
  }
  if (other.encryptionKey_ != null) {
    if (encryptionKey_ == null) {
      EncryptionKey = new global::AudibleUtilities.Widevine.DrmCertificate.Types.EncryptionKey();
    }
    EncryptionKey.MergeFrom(other.EncryptionKey);
  }
  _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(pb::CodedInputStream input) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  input.ReadRawMessage(this);
#else
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
        break;
      case 8: {
        Type = (global::AudibleUtilities.Widevine.DrmCertificate.Types.Type) input.ReadEnum();
        break;
      }
      case 18: {
        SerialNumber = input.ReadBytes();
        break;
      }
      case 24: {
        CreationTimeSeconds = input.ReadUInt32();
        break;
      }
      case 34: {
        PublicKey = input.ReadBytes();
        break;
      }
      case 40: {
        SystemId = input.ReadUInt32();
        break;
      }
      case 48: {
        TestDeviceDeprecated = input.ReadBool();
        break;
      }
      case 58: {
        ProviderId = input.ReadString();
        break;
      }
      case 66:
      case 64: {
        serviceTypes_.AddEntriesFrom(input, _repeated_serviceTypes_codec);
        break;
      }
      case 72: {
        Algorithm = (global::AudibleUtilities.Widevine.DrmCertificate.Types.Algorithm) input.ReadEnum();
        break;
      }
      case 82: {
        RotId = input.ReadBytes();
        break;
      }
      case 90: {
        if (encryptionKey_ == null) {
          EncryptionKey = new global::AudibleUtilities.Widevine.DrmCertificate.Types.EncryptionKey();
        }
        input.ReadMessage(EncryptionKey);
        break;
      }
      case 96: {
        ExpirationTimeSeconds = input.ReadUInt32();
        break;
      }
    }
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
        break;
      case 8: {
        Type = (global::AudibleUtilities.Widevine.DrmCertificate.Types.Type) input.ReadEnum();
        break;
      }
      case 18: {
        SerialNumber = input.ReadBytes();
        break;
      }
      case 24: {
        CreationTimeSeconds = input.ReadUInt32();
        break;
      }
      case 34: {
        PublicKey = input.ReadBytes();
        break;
      }
      case 40: {
        SystemId = input.ReadUInt32();
        break;
      }
      case 48: {
        TestDeviceDeprecated = input.ReadBool();
        break;
      }
      case 58: {
        ProviderId = input.ReadString();
        break;
      }
      case 66:
      case 64: {
        serviceTypes_.AddEntriesFrom(ref input, _repeated_serviceTypes_codec);
        break;
      }
      case 72: {
        Algorithm = (global::AudibleUtilities.Widevine.DrmCertificate.Types.Algorithm) input.ReadEnum();
        break;
      }
      case 82: {
        RotId = input.ReadBytes();
        break;
      }
      case 90: {
        if (encryptionKey_ == null) {
          EncryptionKey = new global::AudibleUtilities.Widevine.DrmCertificate.Types.EncryptionKey();
        }
        input.ReadMessage(EncryptionKey);
        break;
      }
      case 96: {
        ExpirationTimeSeconds = input.ReadUInt32();
        break;
      }
    }
  }
}
#endif

#region Nested types
/// <summary>Container for nested types declared in the DrmCertificate message type.</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static partial class Types {
  internal enum Type {
    /// <summary>
    /// ProtoBestPractices: ignore.
    /// </summary>
    [pbr::OriginalName("ROOT")] Root = 0,
    [pbr::OriginalName("DEVICE_MODEL")] DeviceModel = 1,
    [pbr::OriginalName("DEVICE")] Device = 2,
    [pbr::OriginalName("SERVICE")] Service = 3,
    [pbr::OriginalName("PROVISIONER")] Provisioner = 4,
  }

  internal enum ServiceType {
    [pbr::OriginalName("UNKNOWN_SERVICE_TYPE")] UnknownServiceType = 0,
    [pbr::OriginalName("LICENSE_SERVER_SDK")] LicenseServerSdk = 1,
    [pbr::OriginalName("LICENSE_SERVER_PROXY_SDK")] LicenseServerProxySdk = 2,
    [pbr::OriginalName("PROVISIONING_SDK")] ProvisioningSdk = 3,
    [pbr::OriginalName("CAS_PROXY_SDK")] CasProxySdk = 4,
  }

  internal enum Algorithm {
    [pbr::OriginalName("UNKNOWN_ALGORITHM")] UnknownAlgorithm = 0,
    [pbr::OriginalName("RSA")] Rsa = 1,
    [pbr::OriginalName("ECC_SECP256R1")] EccSecp256R1 = 2,
    [pbr::OriginalName("ECC_SECP384R1")] EccSecp384R1 = 3,
    [pbr::OriginalName("ECC_SECP521R1")] EccSecp521R1 = 4,
  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  internal sealed partial class EncryptionKey : pb::IMessage<EncryptionKey>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EncryptionKey> _parser = new pb::MessageParser<EncryptionKey>(() => new EncryptionKey());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EncryptionKey> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AudibleUtilities.Widevine.DrmCertificate.Descriptor.NestedTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EncryptionKey() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EncryptionKey(EncryptionKey other) : this() {
      _hasBits0 = other._hasBits0;
      publicKey_ = other.publicKey_;
      algorithm_ = other.algorithm_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EncryptionKey Clone() {
      return new EncryptionKey(this);
    }

    /// <summary>Field number for the "public_key" field.</summary>
    public const int PublicKeyFieldNumber = 1;
    private readonly static pb::ByteString PublicKeyDefaultValue = pb::ByteString.Empty;

    private pb::ByteString publicKey_;
    /// <summary>
    /// Device public key. PKCS#1 ASN.1 DER-encoded. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString PublicKey {
      get { return publicKey_ ?? PublicKeyDefaultValue; }
      set {
        publicKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "public_key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPublicKey {
      get { return publicKey_ != null; }
    }
    /// <summary>Clears the value of the "public_key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPublicKey() {
      publicKey_ = null;
    }

    /// <summary>Field number for the "algorithm" field.</summary>
    public const int AlgorithmFieldNumber = 2;
    private readonly static global::AudibleUtilities.Widevine.DrmCertificate.Types.Algorithm AlgorithmDefaultValue = global::AudibleUtilities.Widevine.DrmCertificate.Types.Algorithm.Rsa;

    private global::AudibleUtilities.Widevine.DrmCertificate.Types.Algorithm algorithm_;
    /// <summary>
    /// Required. The algorithm field contains the curve used to create the
    /// |public_key| if algorithm is one of the ECC types.
    /// The |algorithm| is used for both to determine the if the certificate is
    /// ECC or RSA. The |algorithm| also specifies the parameters that were used
    /// to create |public_key| and are used to create an ephemeral session key.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AudibleUtilities.Widevine.DrmCertificate.Types.Algorithm Algorithm {
      get { if ((_hasBits0 & 1) != 0) { return algorithm_; } else { return AlgorithmDefaultValue; } }
      set {
        _hasBits0 |= 1;
        algorithm_ = value;
      }
    }
    /// <summary>Gets whether the "algorithm" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAlgorithm {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "algorithm" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAlgorithm() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EncryptionKey);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EncryptionKey other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PublicKey != other.PublicKey) return false;
      if (Algorithm != other.Algorithm) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPublicKey) hash ^= PublicKey.GetHashCode();
      if (HasAlgorithm) hash ^= Algorithm.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPublicKey) {
        output.WriteRawTag(10);
        output.WriteBytes(PublicKey);
      }
      if (HasAlgorithm) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Algorithm);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPublicKey) {
        output.WriteRawTag(10);
        output.WriteBytes(PublicKey);
      }
      if (HasAlgorithm) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Algorithm);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasPublicKey) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PublicKey);
      }
      if (HasAlgorithm) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Algorithm);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EncryptionKey other) {
      if (other == null) {
        return;
      }
      if (other.HasPublicKey) {
        PublicKey = other.PublicKey;
      }
      if (other.HasAlgorithm) {
        Algorithm = other.Algorithm;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            PublicKey = input.ReadBytes();
            break;
          }
          case 16: {
            Algorithm = (global::AudibleUtilities.Widevine.DrmCertificate.Types.Algorithm) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            PublicKey = input.ReadBytes();
            break;
          }
          case 16: {
            Algorithm = (global::AudibleUtilities.Widevine.DrmCertificate.Types.Algorithm) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

}
#endregion

}

/// <summary>
/// DrmCertificate signed by a higher (CA) DRM certificate.
/// </summary>
[global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
internal sealed partial class SignedDrmCertificate : pb::IMessage<SignedDrmCertificate>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  , pb::IBufferMessage
#endif
{
private static readonly pb::MessageParser<SignedDrmCertificate> _parser = new pb::MessageParser<SignedDrmCertificate>(() => new SignedDrmCertificate());
private pb::UnknownFieldSet _unknownFields;
private int _hasBits0;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pb::MessageParser<SignedDrmCertificate> Parser { get { return _parser; } }

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pbr::MessageDescriptor Descriptor {
  get { return global::AudibleUtilities.Widevine.LicenseProtocolReflection.Descriptor.MessageTypes[9]; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
pbr::MessageDescriptor pb::IMessage.Descriptor {
  get { return Descriptor; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public SignedDrmCertificate() {
  OnConstruction();
}

partial void OnConstruction();

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public SignedDrmCertificate(SignedDrmCertificate other) : this() {
  _hasBits0 = other._hasBits0;
  drmCertificate_ = other.drmCertificate_;
  signature_ = other.signature_;
  signer_ = other.signer_ != null ? other.signer_.Clone() : null;
  hashAlgorithm_ = other.hashAlgorithm_;
  _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public SignedDrmCertificate Clone() {
  return new SignedDrmCertificate(this);
}

/// <summary>Field number for the "drm_certificate" field.</summary>
public const int DrmCertificateFieldNumber = 1;
private readonly static pb::ByteString DrmCertificateDefaultValue = pb::ByteString.Empty;

private pb::ByteString drmCertificate_;
/// <summary>
/// Serialized certificate. Required.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString DrmCertificate {
  get { return drmCertificate_ ?? DrmCertificateDefaultValue; }
  set {
    drmCertificate_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "drm_certificate" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasDrmCertificate {
  get { return drmCertificate_ != null; }
}
/// <summary>Clears the value of the "drm_certificate" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearDrmCertificate() {
  drmCertificate_ = null;
}

/// <summary>Field number for the "signature" field.</summary>
public const int SignatureFieldNumber = 2;
private readonly static pb::ByteString SignatureDefaultValue = pb::ByteString.Empty;

private pb::ByteString signature_;
/// <summary>
/// Signature of certificate. Signed with root or intermediate
/// certificate specified below. Required.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString Signature {
  get { return signature_ ?? SignatureDefaultValue; }
  set {
    signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "signature" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasSignature {
  get { return signature_ != null; }
}
/// <summary>Clears the value of the "signature" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearSignature() {
  signature_ = null;
}

/// <summary>Field number for the "signer" field.</summary>
public const int SignerFieldNumber = 3;
private global::AudibleUtilities.Widevine.SignedDrmCertificate signer_;
/// <summary>
/// SignedDrmCertificate used to sign this certificate.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public global::AudibleUtilities.Widevine.SignedDrmCertificate Signer {
  get { return signer_; }
  set {
    signer_ = value;
  }
}

/// <summary>Field number for the "hash_algorithm" field.</summary>
public const int HashAlgorithmFieldNumber = 4;
private readonly static global::AudibleUtilities.Widevine.HashAlgorithmProto HashAlgorithmDefaultValue = global::AudibleUtilities.Widevine.HashAlgorithmProto.HashAlgorithmUnspecified;

private global::AudibleUtilities.Widevine.HashAlgorithmProto hashAlgorithm_;
/// <summary>
/// Optional field that indicates the hash algorithm used in signature scheme.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public global::AudibleUtilities.Widevine.HashAlgorithmProto HashAlgorithm {
  get { if ((_hasBits0 & 1) != 0) { return hashAlgorithm_; } else { return HashAlgorithmDefaultValue; } }
  set {
    _hasBits0 |= 1;
    hashAlgorithm_ = value;
  }
}
/// <summary>Gets whether the "hash_algorithm" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasHashAlgorithm {
  get { return (_hasBits0 & 1) != 0; }
}
/// <summary>Clears the value of the "hash_algorithm" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearHashAlgorithm() {
  _hasBits0 &= ~1;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override bool Equals(object other) {
  return Equals(other as SignedDrmCertificate);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool Equals(SignedDrmCertificate other) {
  if (ReferenceEquals(other, null)) {
    return false;
  }
  if (ReferenceEquals(other, this)) {
    return true;
  }
  if (DrmCertificate != other.DrmCertificate) return false;
  if (Signature != other.Signature) return false;
  if (!object.Equals(Signer, other.Signer)) return false;
  if (HashAlgorithm != other.HashAlgorithm) return false;
  return Equals(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override int GetHashCode() {
  int hash = 1;
  if (HasDrmCertificate) hash ^= DrmCertificate.GetHashCode();
  if (HasSignature) hash ^= Signature.GetHashCode();
  if (signer_ != null) hash ^= Signer.GetHashCode();
  if (HasHashAlgorithm) hash ^= HashAlgorithm.GetHashCode();
  if (_unknownFields != null) {
    hash ^= _unknownFields.GetHashCode();
  }
  return hash;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override string ToString() {
  return pb::JsonFormatter.ToDiagnosticString(this);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void WriteTo(pb::CodedOutputStream output) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  output.WriteRawMessage(this);
#else
  if (HasDrmCertificate) {
    output.WriteRawTag(10);
    output.WriteBytes(DrmCertificate);
  }
  if (HasSignature) {
    output.WriteRawTag(18);
    output.WriteBytes(Signature);
  }
  if (signer_ != null) {
    output.WriteRawTag(26);
    output.WriteMessage(Signer);
  }
  if (HasHashAlgorithm) {
    output.WriteRawTag(32);
    output.WriteEnum((int) HashAlgorithm);
  }
  if (_unknownFields != null) {
    _unknownFields.WriteTo(output);
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
  if (HasDrmCertificate) {
    output.WriteRawTag(10);
    output.WriteBytes(DrmCertificate);
  }
  if (HasSignature) {
    output.WriteRawTag(18);
    output.WriteBytes(Signature);
  }
  if (signer_ != null) {
    output.WriteRawTag(26);
    output.WriteMessage(Signer);
  }
  if (HasHashAlgorithm) {
    output.WriteRawTag(32);
    output.WriteEnum((int) HashAlgorithm);
  }
  if (_unknownFields != null) {
    _unknownFields.WriteTo(ref output);
  }
}
#endif

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public int CalculateSize() {
  int size = 0;
  if (HasDrmCertificate) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(DrmCertificate);
  }
  if (HasSignature) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(Signature);
  }
  if (signer_ != null) {
    size += 1 + pb::CodedOutputStream.ComputeMessageSize(Signer);
  }
  if (HasHashAlgorithm) {
    size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) HashAlgorithm);
  }
  if (_unknownFields != null) {
    size += _unknownFields.CalculateSize();
  }
  return size;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(SignedDrmCertificate other) {
  if (other == null) {
    return;
  }
  if (other.HasDrmCertificate) {
    DrmCertificate = other.DrmCertificate;
  }
  if (other.HasSignature) {
    Signature = other.Signature;
  }
  if (other.signer_ != null) {
    if (signer_ == null) {
      Signer = new global::AudibleUtilities.Widevine.SignedDrmCertificate();
    }
    Signer.MergeFrom(other.Signer);
  }
  if (other.HasHashAlgorithm) {
    HashAlgorithm = other.HashAlgorithm;
  }
  _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(pb::CodedInputStream input) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  input.ReadRawMessage(this);
#else
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
        break;
      case 10: {
        DrmCertificate = input.ReadBytes();
        break;
      }
      case 18: {
        Signature = input.ReadBytes();
        break;
      }
      case 26: {
        if (signer_ == null) {
          Signer = new global::AudibleUtilities.Widevine.SignedDrmCertificate();
        }
        input.ReadMessage(Signer);
        break;
      }
      case 32: {
        HashAlgorithm = (global::AudibleUtilities.Widevine.HashAlgorithmProto) input.ReadEnum();
        break;
      }
    }
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
        break;
      case 10: {
        DrmCertificate = input.ReadBytes();
        break;
      }
      case 18: {
        Signature = input.ReadBytes();
        break;
      }
      case 26: {
        if (signer_ == null) {
          Signer = new global::AudibleUtilities.Widevine.SignedDrmCertificate();
        }
        input.ReadMessage(Signer);
        break;
      }
      case 32: {
        HashAlgorithm = (global::AudibleUtilities.Widevine.HashAlgorithmProto) input.ReadEnum();
        break;
      }
    }
  }
}
#endif

}

[global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
internal sealed partial class WidevinePsshData : pb::IMessage<WidevinePsshData>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  , pb::IBufferMessage
#endif
{
private static readonly pb::MessageParser<WidevinePsshData> _parser = new pb::MessageParser<WidevinePsshData>(() => new WidevinePsshData());
private pb::UnknownFieldSet _unknownFields;
private int _hasBits0;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pb::MessageParser<WidevinePsshData> Parser { get { return _parser; } }

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pbr::MessageDescriptor Descriptor {
  get { return global::AudibleUtilities.Widevine.LicenseProtocolReflection.Descriptor.MessageTypes[10]; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
pbr::MessageDescriptor pb::IMessage.Descriptor {
  get { return Descriptor; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public WidevinePsshData() {
  OnConstruction();
}

partial void OnConstruction();

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public WidevinePsshData(WidevinePsshData other) : this() {
  _hasBits0 = other._hasBits0;
  keyIds_ = other.keyIds_.Clone();
  contentId_ = other.contentId_;
  cryptoPeriodIndex_ = other.cryptoPeriodIndex_;
  protectionScheme_ = other.protectionScheme_;
  cryptoPeriodSeconds_ = other.cryptoPeriodSeconds_;
  type_ = other.type_;
  keySequence_ = other.keySequence_;
  groupIds_ = other.groupIds_.Clone();
  entitledKeys_ = other.entitledKeys_.Clone();
  videoFeature_ = other.videoFeature_;
  algorithm_ = other.algorithm_;
  provider_ = other.provider_;
  trackType_ = other.trackType_;
  policy_ = other.policy_;
  groupedLicense_ = other.groupedLicense_;
  _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public WidevinePsshData Clone() {
  return new WidevinePsshData(this);
}

/// <summary>Field number for the "key_ids" field.</summary>
public const int KeyIdsFieldNumber = 2;
private static readonly pb::FieldCodec<pb::ByteString> _repeated_keyIds_codec
    = pb::FieldCodec.ForBytes(18);
private readonly pbc::RepeatedField<pb::ByteString> keyIds_ = new pbc::RepeatedField<pb::ByteString>();
/// <summary>
/// Entitlement or content key IDs. Can onnly present in SINGLE or ENTITLEMENT
/// PSSHs. May be repeated to facilitate delivery of multiple keys in a
/// single license. Cannot be used in conjunction with content_id or
/// group_ids, which are the preferred mechanism.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pbc::RepeatedField<pb::ByteString> KeyIds {
  get { return keyIds_; }
}

/// <summary>Field number for the "content_id" field.</summary>
public const int ContentIdFieldNumber = 4;
private readonly static pb::ByteString ContentIdDefaultValue = pb::ByteString.Empty;

private pb::ByteString contentId_;
/// <summary>
/// Content identifier which may map to multiple entitlement or content key
/// IDs to facilitate the delivery of multiple keys in a single license.
/// Cannot be present in conjunction with key_ids, but if used must be in all
/// PSSHs.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString ContentId {
  get { return contentId_ ?? ContentIdDefaultValue; }
  set {
    contentId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "content_id" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasContentId {
  get { return contentId_ != null; }
}
/// <summary>Clears the value of the "content_id" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearContentId() {
  contentId_ = null;
}

/// <summary>Field number for the "crypto_period_index" field.</summary>
public const int CryptoPeriodIndexFieldNumber = 7;
private readonly static uint CryptoPeriodIndexDefaultValue = 0;

private uint cryptoPeriodIndex_;
/// <summary>
/// Crypto period index, for media using key rotation. Always corresponds to
/// The content key period. This means that if using entitlement licensing
/// the ENTITLED_KEY PSSHs will have sequential crypto_period_index's, whereas
/// the ENTITELEMENT PSSHs will have gaps in the sequence. Required if doing
/// key rotation.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public uint CryptoPeriodIndex {
  get { if ((_hasBits0 & 2) != 0) { return cryptoPeriodIndex_; } else { return CryptoPeriodIndexDefaultValue; } }
  set {
    _hasBits0 |= 2;
    cryptoPeriodIndex_ = value;
  }
}
/// <summary>Gets whether the "crypto_period_index" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasCryptoPeriodIndex {
  get { return (_hasBits0 & 2) != 0; }
}
/// <summary>Clears the value of the "crypto_period_index" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearCryptoPeriodIndex() {
  _hasBits0 &= ~2;
}

/// <summary>Field number for the "protection_scheme" field.</summary>
public const int ProtectionSchemeFieldNumber = 9;
private readonly static uint ProtectionSchemeDefaultValue = 0;

private uint protectionScheme_;
/// <summary>
/// Protection scheme identifying the encryption algorithm. The protection
/// scheme is represented as a uint32 value. The uint32 contains 4 bytes each
/// representing a single ascii character in one of the 4CC protection scheme
/// values. To be deprecated in favor of signaling from content.
/// 'cenc' (AES-CTR) protection_scheme = 0x63656E63,
/// 'cbc1' (AES-CBC) protection_scheme = 0x63626331,
/// 'cens' (AES-CTR pattern encryption) protection_scheme = 0x63656E73,
/// 'cbcs' (AES-CBC pattern encryption) protection_scheme = 0x63626373.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public uint ProtectionScheme {
  get { if ((_hasBits0 & 4) != 0) { return protectionScheme_; } else { return ProtectionSchemeDefaultValue; } }
  set {
    _hasBits0 |= 4;
    protectionScheme_ = value;
  }
}
/// <summary>Gets whether the "protection_scheme" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasProtectionScheme {
  get { return (_hasBits0 & 4) != 0; }
}
/// <summary>Clears the value of the "protection_scheme" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearProtectionScheme() {
  _hasBits0 &= ~4;
}

/// <summary>Field number for the "crypto_period_seconds" field.</summary>
public const int CryptoPeriodSecondsFieldNumber = 10;
private readonly static uint CryptoPeriodSecondsDefaultValue = 0;

private uint cryptoPeriodSeconds_;
/// <summary>
/// Optional. For media using key rotation, this represents the duration
/// of each crypto period in seconds.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public uint CryptoPeriodSeconds {
  get { if ((_hasBits0 & 8) != 0) { return cryptoPeriodSeconds_; } else { return CryptoPeriodSecondsDefaultValue; } }
  set {
    _hasBits0 |= 8;
    cryptoPeriodSeconds_ = value;
  }
}
/// <summary>Gets whether the "crypto_period_seconds" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasCryptoPeriodSeconds {
  get { return (_hasBits0 & 8) != 0; }
}
/// <summary>Clears the value of the "crypto_period_seconds" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearCryptoPeriodSeconds() {
  _hasBits0 &= ~8;
}

/// <summary>Field number for the "type" field.</summary>
public const int TypeFieldNumber = 11;
private readonly static global::AudibleUtilities.Widevine.WidevinePsshData.Types.Type TypeDefaultValue = global::AudibleUtilities.Widevine.WidevinePsshData.Types.Type.Single;

private global::AudibleUtilities.Widevine.WidevinePsshData.Types.Type type_;
/// <summary>
/// Type of PSSH. Required if not SINGLE.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public global::AudibleUtilities.Widevine.WidevinePsshData.Types.Type Type {
  get { if ((_hasBits0 & 16) != 0) { return type_; } else { return TypeDefaultValue; } }
  set {
    _hasBits0 |= 16;
    type_ = value;
  }
}
/// <summary>Gets whether the "type" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasType {
  get { return (_hasBits0 & 16) != 0; }
}
/// <summary>Clears the value of the "type" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearType() {
  _hasBits0 &= ~16;
}

/// <summary>Field number for the "key_sequence" field.</summary>
public const int KeySequenceFieldNumber = 12;
private readonly static uint KeySequenceDefaultValue = 0;

private uint keySequence_;
/// <summary>
/// Key sequence for Widevine-managed keys. Optional.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public uint KeySequence {
  get { if ((_hasBits0 & 32) != 0) { return keySequence_; } else { return KeySequenceDefaultValue; } }
  set {
    _hasBits0 |= 32;
    keySequence_ = value;
  }
}
/// <summary>Gets whether the "key_sequence" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasKeySequence {
  get { return (_hasBits0 & 32) != 0; }
}
/// <summary>Clears the value of the "key_sequence" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearKeySequence() {
  _hasBits0 &= ~32;
}

/// <summary>Field number for the "group_ids" field.</summary>
public const int GroupIdsFieldNumber = 13;
private static readonly pb::FieldCodec<pb::ByteString> _repeated_groupIds_codec
    = pb::FieldCodec.ForBytes(106);
private readonly pbc::RepeatedField<pb::ByteString> groupIds_ = new pbc::RepeatedField<pb::ByteString>();
/// <summary>
/// Group identifiers for all groups to which the content belongs. This can
/// be used to deliver licenses to unlock multiple titles / channels.
/// Optional, and may only be present in ENTITLEMENT and ENTITLED_KEY PSSHs, and
/// not in conjunction with key_ids.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pbc::RepeatedField<pb::ByteString> GroupIds {
  get { return groupIds_; }
}

/// <summary>Field number for the "entitled_keys" field.</summary>
public const int EntitledKeysFieldNumber = 14;
private static readonly pb::FieldCodec<global::AudibleUtilities.Widevine.WidevinePsshData.Types.EntitledKey> _repeated_entitledKeys_codec
    = pb::FieldCodec.ForMessage(114, global::AudibleUtilities.Widevine.WidevinePsshData.Types.EntitledKey.Parser);
private readonly pbc::RepeatedField<global::AudibleUtilities.Widevine.WidevinePsshData.Types.EntitledKey> entitledKeys_ = new pbc::RepeatedField<global::AudibleUtilities.Widevine.WidevinePsshData.Types.EntitledKey>();
/// <summary>
/// Copy/copies of the content key used to decrypt the media stream in which
/// the PSSH box is embedded, each wrapped with a different entitlement key.
/// May also contain sub-licenses to support devices with OEMCrypto 13 or
/// older. May be repeated if using group entitlement keys. Present only in
/// PSSHs of type ENTITLED_KEY.
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pbc::RepeatedField<global::AudibleUtilities.Widevine.WidevinePsshData.Types.EntitledKey> EntitledKeys {
  get { return entitledKeys_; }
}

/// <summary>Field number for the "video_feature" field.</summary>
public const int VideoFeatureFieldNumber = 15;
private readonly static string VideoFeatureDefaultValue = "";

private string videoFeature_;
/// <summary>
/// Video feature identifier, which is used in conjunction with |content_id|
/// to determine the set of keys to be returned in the license. Cannot be
/// present in conjunction with |key_ids|.
/// Current values are "HDR".
/// </summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public string VideoFeature {
  get { return videoFeature_ ?? VideoFeatureDefaultValue; }
  set {
    videoFeature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "video_feature" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasVideoFeature {
  get { return videoFeature_ != null; }
}
/// <summary>Clears the value of the "video_feature" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearVideoFeature() {
  videoFeature_ = null;
}

/// <summary>Field number for the "algorithm" field.</summary>
public const int AlgorithmFieldNumber = 1;
private readonly static global::AudibleUtilities.Widevine.WidevinePsshData.Types.Algorithm AlgorithmDefaultValue = global::AudibleUtilities.Widevine.WidevinePsshData.Types.Algorithm.Unencrypted;

private global::AudibleUtilities.Widevine.WidevinePsshData.Types.Algorithm algorithm_;
[global::System.ObsoleteAttribute]
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public global::AudibleUtilities.Widevine.WidevinePsshData.Types.Algorithm Algorithm {
  get { if ((_hasBits0 & 1) != 0) { return algorithm_; } else { return AlgorithmDefaultValue; } }
  set {
    _hasBits0 |= 1;
    algorithm_ = value;
  }
}
/// <summary>Gets whether the "algorithm" field is set</summary>
[global::System.ObsoleteAttribute]
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasAlgorithm {
  get { return (_hasBits0 & 1) != 0; }
}
/// <summary>Clears the value of the "algorithm" field</summary>
[global::System.ObsoleteAttribute]
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearAlgorithm() {
  _hasBits0 &= ~1;
}

/// <summary>Field number for the "provider" field.</summary>
public const int ProviderFieldNumber = 3;
private readonly static string ProviderDefaultValue = "";

private string provider_;
/// <summary>
/// Content provider name.
/// </summary>
[global::System.ObsoleteAttribute]
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public string Provider {
  get { return provider_ ?? ProviderDefaultValue; }
  set {
    provider_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "provider" field is set</summary>
[global::System.ObsoleteAttribute]
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasProvider {
  get { return provider_ != null; }
}
/// <summary>Clears the value of the "provider" field</summary>
[global::System.ObsoleteAttribute]
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearProvider() {
  provider_ = null;
}

/// <summary>Field number for the "track_type" field.</summary>
public const int TrackTypeFieldNumber = 5;
private readonly static string TrackTypeDefaultValue = "";

private string trackType_;
/// <summary>
/// Track type. Acceptable values are SD, HD and AUDIO. Used to
/// differentiate content keys used by an asset.
/// </summary>
[global::System.ObsoleteAttribute]
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public string TrackType {
  get { return trackType_ ?? TrackTypeDefaultValue; }
  set {
    trackType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "track_type" field is set</summary>
[global::System.ObsoleteAttribute]
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasTrackType {
  get { return trackType_ != null; }
}
/// <summary>Clears the value of the "track_type" field</summary>
[global::System.ObsoleteAttribute]
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearTrackType() {
  trackType_ = null;
}

/// <summary>Field number for the "policy" field.</summary>
public const int PolicyFieldNumber = 6;
private readonly static string PolicyDefaultValue = "";

private string policy_;
/// <summary>
/// The name of a registered policy to be used for this asset.
/// </summary>
[global::System.ObsoleteAttribute]
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public string Policy {
  get { return policy_ ?? PolicyDefaultValue; }
  set {
    policy_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "policy" field is set</summary>
[global::System.ObsoleteAttribute]
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasPolicy {
  get { return policy_ != null; }
}
/// <summary>Clears the value of the "policy" field</summary>
[global::System.ObsoleteAttribute]
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearPolicy() {
  policy_ = null;
}

/// <summary>Field number for the "grouped_license" field.</summary>
public const int GroupedLicenseFieldNumber = 8;
private readonly static pb::ByteString GroupedLicenseDefaultValue = pb::ByteString.Empty;

private pb::ByteString groupedLicense_;
/// <summary>
/// Optional protected context for group content. The grouped_license is a
/// serialized SignedMessage.
/// </summary>
[global::System.ObsoleteAttribute]
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString GroupedLicense {
  get { return groupedLicense_ ?? GroupedLicenseDefaultValue; }
  set {
    groupedLicense_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "grouped_license" field is set</summary>
[global::System.ObsoleteAttribute]
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasGroupedLicense {
  get { return groupedLicense_ != null; }
}
/// <summary>Clears the value of the "grouped_license" field</summary>
[global::System.ObsoleteAttribute]
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearGroupedLicense() {
  groupedLicense_ = null;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override bool Equals(object other) {
  return Equals(other as WidevinePsshData);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool Equals(WidevinePsshData other) {
  if (ReferenceEquals(other, null)) {
    return false;
  }
  if (ReferenceEquals(other, this)) {
    return true;
  }
  if(!keyIds_.Equals(other.keyIds_)) return false;
  if (ContentId != other.ContentId) return false;
  if (CryptoPeriodIndex != other.CryptoPeriodIndex) return false;
  if (ProtectionScheme != other.ProtectionScheme) return false;
  if (CryptoPeriodSeconds != other.CryptoPeriodSeconds) return false;
  if (Type != other.Type) return false;
  if (KeySequence != other.KeySequence) return false;
  if(!groupIds_.Equals(other.groupIds_)) return false;
  if(!entitledKeys_.Equals(other.entitledKeys_)) return false;
  if (VideoFeature != other.VideoFeature) return false;
  if (Algorithm != other.Algorithm) return false;
  if (Provider != other.Provider) return false;
  if (TrackType != other.TrackType) return false;
  if (Policy != other.Policy) return false;
  if (GroupedLicense != other.GroupedLicense) return false;
  return Equals(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override int GetHashCode() {
  int hash = 1;
  hash ^= keyIds_.GetHashCode();
  if (HasContentId) hash ^= ContentId.GetHashCode();
  if (HasCryptoPeriodIndex) hash ^= CryptoPeriodIndex.GetHashCode();
  if (HasProtectionScheme) hash ^= ProtectionScheme.GetHashCode();
  if (HasCryptoPeriodSeconds) hash ^= CryptoPeriodSeconds.GetHashCode();
  if (HasType) hash ^= Type.GetHashCode();
  if (HasKeySequence) hash ^= KeySequence.GetHashCode();
  hash ^= groupIds_.GetHashCode();
  hash ^= entitledKeys_.GetHashCode();
  if (HasVideoFeature) hash ^= VideoFeature.GetHashCode();
  if (HasAlgorithm) hash ^= Algorithm.GetHashCode();
  if (HasProvider) hash ^= Provider.GetHashCode();
  if (HasTrackType) hash ^= TrackType.GetHashCode();
  if (HasPolicy) hash ^= Policy.GetHashCode();
  if (HasGroupedLicense) hash ^= GroupedLicense.GetHashCode();
  if (_unknownFields != null) {
    hash ^= _unknownFields.GetHashCode();
  }
  return hash;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override string ToString() {
  return pb::JsonFormatter.ToDiagnosticString(this);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void WriteTo(pb::CodedOutputStream output) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  output.WriteRawMessage(this);
#else
  if (HasAlgorithm) {
    output.WriteRawTag(8);
    output.WriteEnum((int) Algorithm);
  }
  keyIds_.WriteTo(output, _repeated_keyIds_codec);
  if (HasProvider) {
    output.WriteRawTag(26);
    output.WriteString(Provider);
  }
  if (HasContentId) {
    output.WriteRawTag(34);
    output.WriteBytes(ContentId);
  }
  if (HasTrackType) {
    output.WriteRawTag(42);
    output.WriteString(TrackType);
  }
  if (HasPolicy) {
    output.WriteRawTag(50);
    output.WriteString(Policy);
  }
  if (HasCryptoPeriodIndex) {
    output.WriteRawTag(56);
    output.WriteUInt32(CryptoPeriodIndex);
  }
  if (HasGroupedLicense) {
    output.WriteRawTag(66);
    output.WriteBytes(GroupedLicense);
  }
  if (HasProtectionScheme) {
    output.WriteRawTag(72);
    output.WriteUInt32(ProtectionScheme);
  }
  if (HasCryptoPeriodSeconds) {
    output.WriteRawTag(80);
    output.WriteUInt32(CryptoPeriodSeconds);
  }
  if (HasType) {
    output.WriteRawTag(88);
    output.WriteEnum((int) Type);
  }
  if (HasKeySequence) {
    output.WriteRawTag(96);
    output.WriteUInt32(KeySequence);
  }
  groupIds_.WriteTo(output, _repeated_groupIds_codec);
  entitledKeys_.WriteTo(output, _repeated_entitledKeys_codec);
  if (HasVideoFeature) {
    output.WriteRawTag(122);
    output.WriteString(VideoFeature);
  }
  if (_unknownFields != null) {
    _unknownFields.WriteTo(output);
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
  if (HasAlgorithm) {
    output.WriteRawTag(8);
    output.WriteEnum((int) Algorithm);
  }
  keyIds_.WriteTo(ref output, _repeated_keyIds_codec);
  if (HasProvider) {
    output.WriteRawTag(26);
    output.WriteString(Provider);
  }
  if (HasContentId) {
    output.WriteRawTag(34);
    output.WriteBytes(ContentId);
  }
  if (HasTrackType) {
    output.WriteRawTag(42);
    output.WriteString(TrackType);
  }
  if (HasPolicy) {
    output.WriteRawTag(50);
    output.WriteString(Policy);
  }
  if (HasCryptoPeriodIndex) {
    output.WriteRawTag(56);
    output.WriteUInt32(CryptoPeriodIndex);
  }
  if (HasGroupedLicense) {
    output.WriteRawTag(66);
    output.WriteBytes(GroupedLicense);
  }
  if (HasProtectionScheme) {
    output.WriteRawTag(72);
    output.WriteUInt32(ProtectionScheme);
  }
  if (HasCryptoPeriodSeconds) {
    output.WriteRawTag(80);
    output.WriteUInt32(CryptoPeriodSeconds);
  }
  if (HasType) {
    output.WriteRawTag(88);
    output.WriteEnum((int) Type);
  }
  if (HasKeySequence) {
    output.WriteRawTag(96);
    output.WriteUInt32(KeySequence);
  }
  groupIds_.WriteTo(ref output, _repeated_groupIds_codec);
  entitledKeys_.WriteTo(ref output, _repeated_entitledKeys_codec);
  if (HasVideoFeature) {
    output.WriteRawTag(122);
    output.WriteString(VideoFeature);
  }
  if (_unknownFields != null) {
    _unknownFields.WriteTo(ref output);
  }
}
#endif

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public int CalculateSize() {
  int size = 0;
  size += keyIds_.CalculateSize(_repeated_keyIds_codec);
  if (HasContentId) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(ContentId);
  }
  if (HasCryptoPeriodIndex) {
    size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CryptoPeriodIndex);
  }
  if (HasProtectionScheme) {
    size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ProtectionScheme);
  }
  if (HasCryptoPeriodSeconds) {
    size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CryptoPeriodSeconds);
  }
  if (HasType) {
    size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
  }
  if (HasKeySequence) {
    size += 1 + pb::CodedOutputStream.ComputeUInt32Size(KeySequence);
  }
  size += groupIds_.CalculateSize(_repeated_groupIds_codec);
  size += entitledKeys_.CalculateSize(_repeated_entitledKeys_codec);
  if (HasVideoFeature) {
    size += 1 + pb::CodedOutputStream.ComputeStringSize(VideoFeature);
  }
  if (HasAlgorithm) {
    size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Algorithm);
  }
  if (HasProvider) {
    size += 1 + pb::CodedOutputStream.ComputeStringSize(Provider);
  }
  if (HasTrackType) {
    size += 1 + pb::CodedOutputStream.ComputeStringSize(TrackType);
  }
  if (HasPolicy) {
    size += 1 + pb::CodedOutputStream.ComputeStringSize(Policy);
  }
  if (HasGroupedLicense) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(GroupedLicense);
  }
  if (_unknownFields != null) {
    size += _unknownFields.CalculateSize();
  }
  return size;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(WidevinePsshData other) {
  if (other == null) {
    return;
  }
  keyIds_.Add(other.keyIds_);
  if (other.HasContentId) {
    ContentId = other.ContentId;
  }
  if (other.HasCryptoPeriodIndex) {
    CryptoPeriodIndex = other.CryptoPeriodIndex;
  }
  if (other.HasProtectionScheme) {
    ProtectionScheme = other.ProtectionScheme;
  }
  if (other.HasCryptoPeriodSeconds) {
    CryptoPeriodSeconds = other.CryptoPeriodSeconds;
  }
  if (other.HasType) {
    Type = other.Type;
  }
  if (other.HasKeySequence) {
    KeySequence = other.KeySequence;
  }
  groupIds_.Add(other.groupIds_);
  entitledKeys_.Add(other.entitledKeys_);
  if (other.HasVideoFeature) {
    VideoFeature = other.VideoFeature;
  }
  if (other.HasAlgorithm) {
    Algorithm = other.Algorithm;
  }
  if (other.HasProvider) {
    Provider = other.Provider;
  }
  if (other.HasTrackType) {
    TrackType = other.TrackType;
  }
  if (other.HasPolicy) {
    Policy = other.Policy;
  }
  if (other.HasGroupedLicense) {
    GroupedLicense = other.GroupedLicense;
  }
  _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(pb::CodedInputStream input) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  input.ReadRawMessage(this);
#else
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
        break;
      case 8: {
        Algorithm = (global::AudibleUtilities.Widevine.WidevinePsshData.Types.Algorithm) input.ReadEnum();
        break;
      }
      case 18: {
        keyIds_.AddEntriesFrom(input, _repeated_keyIds_codec);
        break;
      }
      case 26: {
        Provider = input.ReadString();
        break;
      }
      case 34: {
        ContentId = input.ReadBytes();
        break;
      }
      case 42: {
        TrackType = input.ReadString();
        break;
      }
      case 50: {
        Policy = input.ReadString();
        break;
      }
      case 56: {
        CryptoPeriodIndex = input.ReadUInt32();
        break;
      }
      case 66: {
        GroupedLicense = input.ReadBytes();
        break;
      }
      case 72: {
        ProtectionScheme = input.ReadUInt32();
        break;
      }
      case 80: {
        CryptoPeriodSeconds = input.ReadUInt32();
        break;
      }
      case 88: {
        Type = (global::AudibleUtilities.Widevine.WidevinePsshData.Types.Type) input.ReadEnum();
        break;
      }
      case 96: {
        KeySequence = input.ReadUInt32();
        break;
      }
      case 106: {
        groupIds_.AddEntriesFrom(input, _repeated_groupIds_codec);
        break;
      }
      case 114: {
        entitledKeys_.AddEntriesFrom(input, _repeated_entitledKeys_codec);
        break;
      }
      case 122: {
        VideoFeature = input.ReadString();
        break;
      }
    }
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
        break;
      case 8: {
        Algorithm = (global::AudibleUtilities.Widevine.WidevinePsshData.Types.Algorithm) input.ReadEnum();
        break;
      }
      case 18: {
        keyIds_.AddEntriesFrom(ref input, _repeated_keyIds_codec);
        break;
      }
      case 26: {
        Provider = input.ReadString();
        break;
      }
      case 34: {
        ContentId = input.ReadBytes();
        break;
      }
      case 42: {
        TrackType = input.ReadString();
        break;
      }
      case 50: {
        Policy = input.ReadString();
        break;
      }
      case 56: {
        CryptoPeriodIndex = input.ReadUInt32();
        break;
      }
      case 66: {
        GroupedLicense = input.ReadBytes();
        break;
      }
      case 72: {
        ProtectionScheme = input.ReadUInt32();
        break;
      }
      case 80: {
        CryptoPeriodSeconds = input.ReadUInt32();
        break;
      }
      case 88: {
        Type = (global::AudibleUtilities.Widevine.WidevinePsshData.Types.Type) input.ReadEnum();
        break;
      }
      case 96: {
        KeySequence = input.ReadUInt32();
        break;
      }
      case 106: {
        groupIds_.AddEntriesFrom(ref input, _repeated_groupIds_codec);
        break;
      }
      case 114: {
        entitledKeys_.AddEntriesFrom(ref input, _repeated_entitledKeys_codec);
        break;
      }
      case 122: {
        VideoFeature = input.ReadString();
        break;
      }
    }
  }
}
#endif

#region Nested types
/// <summary>Container for nested types declared in the WidevinePsshData message type.</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static partial class Types {
  internal enum Type {
    /// <summary>
    /// Single PSSH to be used to retrieve content keys.
    /// </summary>
    [pbr::OriginalName("SINGLE")] Single = 0,
    /// <summary>
    /// Primary PSSH used to retrieve entitlement keys.
    /// </summary>
    [pbr::OriginalName("ENTITLEMENT")] Entitlement = 1,
    /// <summary>
    /// Secondary PSSH containing entitled key(s).
    /// </summary>
    [pbr::OriginalName("ENTITLED_KEY")] EntitledKey = 2,
  }

  /// <summary>
  ///&#x2F;/////////////////////////  Deprecated Fields  ////////////////////////////
  /// </summary>
  internal enum Algorithm {
    [pbr::OriginalName("UNENCRYPTED")] Unencrypted = 0,
    [pbr::OriginalName("AESCTR")] Aesctr = 1,
  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  internal sealed partial class EntitledKey : pb::IMessage<EntitledKey>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EntitledKey> _parser = new pb::MessageParser<EntitledKey>(() => new EntitledKey());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EntitledKey> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AudibleUtilities.Widevine.WidevinePsshData.Descriptor.NestedTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EntitledKey() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EntitledKey(EntitledKey other) : this() {
      _hasBits0 = other._hasBits0;
      entitlementKeyId_ = other.entitlementKeyId_;
      keyId_ = other.keyId_;
      key_ = other.key_;
      iv_ = other.iv_;
      entitlementKeySizeBytes_ = other.entitlementKeySizeBytes_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EntitledKey Clone() {
      return new EntitledKey(this);
    }

    /// <summary>Field number for the "entitlement_key_id" field.</summary>
    public const int EntitlementKeyIdFieldNumber = 1;
    private readonly static pb::ByteString EntitlementKeyIdDefaultValue = pb::ByteString.Empty;

    private pb::ByteString entitlementKeyId_;
    /// <summary>
    /// ID of entitlement key used for wrapping |key|.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString EntitlementKeyId {
      get { return entitlementKeyId_ ?? EntitlementKeyIdDefaultValue; }
      set {
        entitlementKeyId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "entitlement_key_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEntitlementKeyId {
      get { return entitlementKeyId_ != null; }
    }
    /// <summary>Clears the value of the "entitlement_key_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEntitlementKeyId() {
      entitlementKeyId_ = null;
    }

    /// <summary>Field number for the "key_id" field.</summary>
    public const int KeyIdFieldNumber = 2;
    private readonly static pb::ByteString KeyIdDefaultValue = pb::ByteString.Empty;

    private pb::ByteString keyId_;
    /// <summary>
    /// ID of the entitled key.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString KeyId {
      get { return keyId_ ?? KeyIdDefaultValue; }
      set {
        keyId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "key_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKeyId {
      get { return keyId_ != null; }
    }
    /// <summary>Clears the value of the "key_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKeyId() {
      keyId_ = null;
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 3;
    private readonly static pb::ByteString KeyDefaultValue = pb::ByteString.Empty;

    private pb::ByteString key_;
    /// <summary>
    /// Wrapped key. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Key {
      get { return key_ ?? KeyDefaultValue; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKey {
      get { return key_ != null; }
    }
    /// <summary>Clears the value of the "key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKey() {
      key_ = null;
    }

    /// <summary>Field number for the "iv" field.</summary>
    public const int IvFieldNumber = 4;
    private readonly static pb::ByteString IvDefaultValue = pb::ByteString.Empty;

    private pb::ByteString iv_;
    /// <summary>
    /// IV used for wrapping |key|. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Iv {
      get { return iv_ ?? IvDefaultValue; }
      set {
        iv_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "iv" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIv {
      get { return iv_ != null; }
    }
    /// <summary>Clears the value of the "iv" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIv() {
      iv_ = null;
    }

    /// <summary>Field number for the "entitlement_key_size_bytes" field.</summary>
    public const int EntitlementKeySizeBytesFieldNumber = 5;
    private readonly static uint EntitlementKeySizeBytesDefaultValue = 32;

    private uint entitlementKeySizeBytes_;
    /// <summary>
    /// Size of entitlement key used for wrapping |key|.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint EntitlementKeySizeBytes {
      get { if ((_hasBits0 & 1) != 0) { return entitlementKeySizeBytes_; } else { return EntitlementKeySizeBytesDefaultValue; } }
      set {
        _hasBits0 |= 1;
        entitlementKeySizeBytes_ = value;
      }
    }
    /// <summary>Gets whether the "entitlement_key_size_bytes" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEntitlementKeySizeBytes {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "entitlement_key_size_bytes" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEntitlementKeySizeBytes() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EntitledKey);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EntitledKey other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (EntitlementKeyId != other.EntitlementKeyId) return false;
      if (KeyId != other.KeyId) return false;
      if (Key != other.Key) return false;
      if (Iv != other.Iv) return false;
      if (EntitlementKeySizeBytes != other.EntitlementKeySizeBytes) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasEntitlementKeyId) hash ^= EntitlementKeyId.GetHashCode();
      if (HasKeyId) hash ^= KeyId.GetHashCode();
      if (HasKey) hash ^= Key.GetHashCode();
      if (HasIv) hash ^= Iv.GetHashCode();
      if (HasEntitlementKeySizeBytes) hash ^= EntitlementKeySizeBytes.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasEntitlementKeyId) {
        output.WriteRawTag(10);
        output.WriteBytes(EntitlementKeyId);
      }
      if (HasKeyId) {
        output.WriteRawTag(18);
        output.WriteBytes(KeyId);
      }
      if (HasKey) {
        output.WriteRawTag(26);
        output.WriteBytes(Key);
      }
      if (HasIv) {
        output.WriteRawTag(34);
        output.WriteBytes(Iv);
      }
      if (HasEntitlementKeySizeBytes) {
        output.WriteRawTag(40);
        output.WriteUInt32(EntitlementKeySizeBytes);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasEntitlementKeyId) {
        output.WriteRawTag(10);
        output.WriteBytes(EntitlementKeyId);
      }
      if (HasKeyId) {
        output.WriteRawTag(18);
        output.WriteBytes(KeyId);
      }
      if (HasKey) {
        output.WriteRawTag(26);
        output.WriteBytes(Key);
      }
      if (HasIv) {
        output.WriteRawTag(34);
        output.WriteBytes(Iv);
      }
      if (HasEntitlementKeySizeBytes) {
        output.WriteRawTag(40);
        output.WriteUInt32(EntitlementKeySizeBytes);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasEntitlementKeyId) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(EntitlementKeyId);
      }
      if (HasKeyId) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(KeyId);
      }
      if (HasKey) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Key);
      }
      if (HasIv) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Iv);
      }
      if (HasEntitlementKeySizeBytes) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(EntitlementKeySizeBytes);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EntitledKey other) {
      if (other == null) {
        return;
      }
      if (other.HasEntitlementKeyId) {
        EntitlementKeyId = other.EntitlementKeyId;
      }
      if (other.HasKeyId) {
        KeyId = other.KeyId;
      }
      if (other.HasKey) {
        Key = other.Key;
      }
      if (other.HasIv) {
        Iv = other.Iv;
      }
      if (other.HasEntitlementKeySizeBytes) {
        EntitlementKeySizeBytes = other.EntitlementKeySizeBytes;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            EntitlementKeyId = input.ReadBytes();
            break;
          }
          case 18: {
            KeyId = input.ReadBytes();
            break;
          }
          case 26: {
            Key = input.ReadBytes();
            break;
          }
          case 34: {
            Iv = input.ReadBytes();
            break;
          }
          case 40: {
            EntitlementKeySizeBytes = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            EntitlementKeyId = input.ReadBytes();
            break;
          }
          case 18: {
            KeyId = input.ReadBytes();
            break;
          }
          case 26: {
            Key = input.ReadBytes();
            break;
          }
          case 34: {
            Iv = input.ReadBytes();
            break;
          }
          case 40: {
            EntitlementKeySizeBytes = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

}
#endregion

}

/// <summary>
/// File Hashes for Verified Media Path (VMP) support.
/// </summary>
[global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
internal sealed partial class FileHashes : pb::IMessage<FileHashes>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  , pb::IBufferMessage
#endif
{
private static readonly pb::MessageParser<FileHashes> _parser = new pb::MessageParser<FileHashes>(() => new FileHashes());
private pb::UnknownFieldSet _unknownFields;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pb::MessageParser<FileHashes> Parser { get { return _parser; } }

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static pbr::MessageDescriptor Descriptor {
  get { return global::AudibleUtilities.Widevine.LicenseProtocolReflection.Descriptor.MessageTypes[11]; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
pbr::MessageDescriptor pb::IMessage.Descriptor {
  get { return Descriptor; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public FileHashes() {
  OnConstruction();
}

partial void OnConstruction();

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public FileHashes(FileHashes other) : this() {
  signer_ = other.signer_;
  signatures_ = other.signatures_.Clone();
  _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public FileHashes Clone() {
  return new FileHashes(this);
}

/// <summary>Field number for the "signer" field.</summary>
public const int SignerFieldNumber = 1;
private readonly static pb::ByteString SignerDefaultValue = pb::ByteString.Empty;

private pb::ByteString signer_;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pb::ByteString Signer {
  get { return signer_ ?? SignerDefaultValue; }
  set {
    signer_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
  }
}
/// <summary>Gets whether the "signer" field is set</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool HasSigner {
  get { return signer_ != null; }
}
/// <summary>Clears the value of the "signer" field</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void ClearSigner() {
  signer_ = null;
}

/// <summary>Field number for the "signatures" field.</summary>
public const int SignaturesFieldNumber = 2;
private static readonly pb::FieldCodec<global::AudibleUtilities.Widevine.FileHashes.Types.Signature> _repeated_signatures_codec
    = pb::FieldCodec.ForMessage(18, global::AudibleUtilities.Widevine.FileHashes.Types.Signature.Parser);
private readonly pbc::RepeatedField<global::AudibleUtilities.Widevine.FileHashes.Types.Signature> signatures_ = new pbc::RepeatedField<global::AudibleUtilities.Widevine.FileHashes.Types.Signature>();
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public pbc::RepeatedField<global::AudibleUtilities.Widevine.FileHashes.Types.Signature> Signatures {
  get { return signatures_; }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override bool Equals(object other) {
  return Equals(other as FileHashes);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public bool Equals(FileHashes other) {
  if (ReferenceEquals(other, null)) {
    return false;
  }
  if (ReferenceEquals(other, this)) {
    return true;
  }
  if (Signer != other.Signer) return false;
  if(!signatures_.Equals(other.signatures_)) return false;
  return Equals(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override int GetHashCode() {
  int hash = 1;
  if (HasSigner) hash ^= Signer.GetHashCode();
  hash ^= signatures_.GetHashCode();
  if (_unknownFields != null) {
    hash ^= _unknownFields.GetHashCode();
  }
  return hash;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public override string ToString() {
  return pb::JsonFormatter.ToDiagnosticString(this);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void WriteTo(pb::CodedOutputStream output) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  output.WriteRawMessage(this);
#else
  if (HasSigner) {
    output.WriteRawTag(10);
    output.WriteBytes(Signer);
  }
  signatures_.WriteTo(output, _repeated_signatures_codec);
  if (_unknownFields != null) {
    _unknownFields.WriteTo(output);
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
  if (HasSigner) {
    output.WriteRawTag(10);
    output.WriteBytes(Signer);
  }
  signatures_.WriteTo(ref output, _repeated_signatures_codec);
  if (_unknownFields != null) {
    _unknownFields.WriteTo(ref output);
  }
}
#endif

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public int CalculateSize() {
  int size = 0;
  if (HasSigner) {
    size += 1 + pb::CodedOutputStream.ComputeBytesSize(Signer);
  }
  size += signatures_.CalculateSize(_repeated_signatures_codec);
  if (_unknownFields != null) {
    size += _unknownFields.CalculateSize();
  }
  return size;
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(FileHashes other) {
  if (other == null) {
    return;
  }
  if (other.HasSigner) {
    Signer = other.Signer;
  }
  signatures_.Add(other.signatures_);
  _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public void MergeFrom(pb::CodedInputStream input) {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  input.ReadRawMessage(this);
#else
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
        break;
      case 10: {
        Signer = input.ReadBytes();
        break;
      }
      case 18: {
        signatures_.AddEntriesFrom(input, _repeated_signatures_codec);
        break;
      }
    }
  }
#endif
}

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
  uint tag;
  while ((tag = input.ReadTag()) != 0) {
  if ((tag & 7) == 4) {
    // Abort on any end group tag.
    return;
  }
  switch(tag) {
      default:
        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
        break;
      case 10: {
        Signer = input.ReadBytes();
        break;
      }
      case 18: {
        signatures_.AddEntriesFrom(ref input, _repeated_signatures_codec);
        break;
      }
    }
  }
}
#endif

#region Nested types
/// <summary>Container for nested types declared in the FileHashes message type.</summary>
[global::System.Diagnostics.DebuggerNonUserCodeAttribute]
[global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
public static partial class Types {
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  internal sealed partial class Signature : pb::IMessage<Signature>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Signature> _parser = new pb::MessageParser<Signature>(() => new Signature());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Signature> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AudibleUtilities.Widevine.FileHashes.Descriptor.NestedTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Signature() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Signature(Signature other) : this() {
      _hasBits0 = other._hasBits0;
      filename_ = other.filename_;
      testSigning_ = other.testSigning_;
      sHA512Hash_ = other.sHA512Hash_;
      mainExe_ = other.mainExe_;
      signature_ = other.signature_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Signature Clone() {
      return new Signature(this);
    }

    /// <summary>Field number for the "filename" field.</summary>
    public const int FilenameFieldNumber = 1;
    private readonly static string FilenameDefaultValue = "";

    private string filename_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Filename {
      get { return filename_ ?? FilenameDefaultValue; }
      set {
        filename_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "filename" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFilename {
      get { return filename_ != null; }
    }
    /// <summary>Clears the value of the "filename" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFilename() {
      filename_ = null;
    }

    /// <summary>Field number for the "test_signing" field.</summary>
    public const int TestSigningFieldNumber = 2;
    private readonly static bool TestSigningDefaultValue = false;

    private bool testSigning_;
    /// <summary>
    ///0 - release, 1 - testing
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool TestSigning {
      get { if ((_hasBits0 & 1) != 0) { return testSigning_; } else { return TestSigningDefaultValue; } }
      set {
        _hasBits0 |= 1;
        testSigning_ = value;
      }
    }
    /// <summary>Gets whether the "test_signing" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTestSigning {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "test_signing" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTestSigning() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "SHA512Hash" field.</summary>
    public const int SHA512HashFieldNumber = 3;
    private readonly static pb::ByteString SHA512HashDefaultValue = pb::ByteString.Empty;

    private pb::ByteString sHA512Hash_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString SHA512Hash {
      get { return sHA512Hash_ ?? SHA512HashDefaultValue; }
      set {
        sHA512Hash_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "SHA512Hash" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSHA512Hash {
      get { return sHA512Hash_ != null; }
    }
    /// <summary>Clears the value of the "SHA512Hash" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSHA512Hash() {
      sHA512Hash_ = null;
    }

    /// <summary>Field number for the "main_exe" field.</summary>
    public const int MainExeFieldNumber = 4;
    private readonly static bool MainExeDefaultValue = false;

    private bool mainExe_;
    /// <summary>
    ///0 for dlls, 1 for exe, this is field 3 in file
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool MainExe {
      get { if ((_hasBits0 & 2) != 0) { return mainExe_; } else { return MainExeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        mainExe_ = value;
      }
    }
    /// <summary>Gets whether the "main_exe" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMainExe {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "main_exe" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMainExe() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "signature" field.</summary>
    public const int Signature_FieldNumber = 5;
    private readonly static pb::ByteString Signature_DefaultValue = pb::ByteString.Empty;

    private pb::ByteString signature_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Signature_ {
      get { return signature_ ?? Signature_DefaultValue; }
      set {
        signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "signature" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSignature_ {
      get { return signature_ != null; }
    }
    /// <summary>Clears the value of the "signature" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSignature_() {
      signature_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Signature);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Signature other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Filename != other.Filename) return false;
      if (TestSigning != other.TestSigning) return false;
      if (SHA512Hash != other.SHA512Hash) return false;
      if (MainExe != other.MainExe) return false;
      if (Signature_ != other.Signature_) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasFilename) hash ^= Filename.GetHashCode();
      if (HasTestSigning) hash ^= TestSigning.GetHashCode();
      if (HasSHA512Hash) hash ^= SHA512Hash.GetHashCode();
      if (HasMainExe) hash ^= MainExe.GetHashCode();
      if (HasSignature_) hash ^= Signature_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasFilename) {
        output.WriteRawTag(10);
        output.WriteString(Filename);
      }
      if (HasTestSigning) {
        output.WriteRawTag(16);
        output.WriteBool(TestSigning);
      }
      if (HasSHA512Hash) {
        output.WriteRawTag(26);
        output.WriteBytes(SHA512Hash);
      }
      if (HasMainExe) {
        output.WriteRawTag(32);
        output.WriteBool(MainExe);
      }
      if (HasSignature_) {
        output.WriteRawTag(42);
        output.WriteBytes(Signature_);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasFilename) {
        output.WriteRawTag(10);
        output.WriteString(Filename);
      }
      if (HasTestSigning) {
        output.WriteRawTag(16);
        output.WriteBool(TestSigning);
      }
      if (HasSHA512Hash) {
        output.WriteRawTag(26);
        output.WriteBytes(SHA512Hash);
      }
      if (HasMainExe) {
        output.WriteRawTag(32);
        output.WriteBool(MainExe);
      }
      if (HasSignature_) {
        output.WriteRawTag(42);
        output.WriteBytes(Signature_);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasFilename) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Filename);
      }
      if (HasTestSigning) {
        size += 1 + 1;
      }
      if (HasSHA512Hash) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(SHA512Hash);
      }
      if (HasMainExe) {
        size += 1 + 1;
      }
      if (HasSignature_) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Signature_);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Signature other) {
      if (other == null) {
        return;
      }
      if (other.HasFilename) {
        Filename = other.Filename;
      }
      if (other.HasTestSigning) {
        TestSigning = other.TestSigning;
      }
      if (other.HasSHA512Hash) {
        SHA512Hash = other.SHA512Hash;
      }
      if (other.HasMainExe) {
        MainExe = other.MainExe;
      }
      if (other.HasSignature_) {
        Signature_ = other.Signature_;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Filename = input.ReadString();
            break;
          }
          case 16: {
            TestSigning = input.ReadBool();
            break;
          }
          case 26: {
            SHA512Hash = input.ReadBytes();
            break;
          }
          case 32: {
            MainExe = input.ReadBool();
            break;
          }
          case 42: {
            Signature_ = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Filename = input.ReadString();
            break;
          }
          case 16: {
            TestSigning = input.ReadBool();
            break;
          }
          case 26: {
            SHA512Hash = input.ReadBytes();
            break;
          }
          case 32: {
            MainExe = input.ReadBool();
            break;
          }
          case 42: {
            Signature_ = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

}
#endregion

}

#endregion

#endregion Designer generated code
